[TOC]



## 一、泛型

#### 泛型概述

- 使用泛型可以让编译器对类型进行检查，避免插入错误类型的对象。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。

- 泛型的好处：安全性、可读性。安全性是指编译器会帮检测类型错误，使类型安全。

  
  
    

#### 泛型用处分类

##### 泛型类

- 一个泛型类就是具有一个或多个**类型变量**的类。

```java
// 一个简单的泛型类
public class Pair<T> 
{
   private T first;
   private T second;

   public Pair() { first = null; second = null; }
   public Pair(T first, T second) { 
        this.first = first;  this.second = second; 
   }

   public T getFirst() { return first; }
   public T getSecond() { return second; }

   public void setFirst(T newValue) { first = newValue; }
   public void setSecond(T newValue) { second = newValue; }
}

// 两个类型变量的泛型类
public class Pair<T, U>{...}
```

用具体的类型替换类型变量就可以实例化泛型类型。

```java
public class PairTest1 {        // 测试类
   public static void main(String[] args)   {
      String[] words = { "Mary", "had", "a", "little", "lamb" };
      Pair<String> mm = ArrayAlg.minmax(words);
      System.out.println("min = " + mm.getFirst());
      System.out.println("max = " + mm.getSecond());
   }
}

class ArrayAlg{
   /**
    * Gets the minimum and maximum of an array of strings.
    * @param a an array of strings
    * @return a pair with the min and max value, or null if a is null or empty
    */
   public static Pair<String> minmax(String[] a) {
      if (a == null || a.length == 0) return null;
      String min = a[0];
      String max = a[0];
      for (int i = 1; i < a.length; i++)      {
         if (min.compareTo(a[i]) > 0) min = a[i];
         if (max.compareTo(a[i]) < 0) max = a[i];
      }
      return new Pair<>(min, max);
   }
}

```

------

##### 泛型方法

- 一个方法是不是泛型的，与其所在的类是不是泛型的没有关系。

- 可以定义带有**类型参数**的方法。调用泛型方法时，在**方法名前的尖括号**中放人具体的类型。
- \<T>是类型参数，T 是返回类型，类型参数放在返回值之前。
- 与泛型类不同，调用方法时一般不需要特意指定类型参数的实际类型， 一般Java 编译器可以自动推断出来。

```java
// 不是泛型类
class ArrayAlg{
    // <T>是类型参数，T 是返回类型，参数为类型T的不定数目参数
    public static <T> T getMiddle(T... a){
        return a[a.length / 2];
    }
    
    
   public static <T> int indexOf(T[] arr, T elm) {
       for(int i = 0; i < arr.length; i++) {
           if(arr[i].equals(elm)) {
               return i;
           }
       }
       return -1;
   }
}

// 调用泛型方法
String middle = ArrayAlg.<String>getMiddle("]ohnM, "Test", "Public");
String middle = ArrayAlg.getMiddle("]ohnM, "Test", "Public");   // 省略类型参数
                                   
indexOf(new Integer[]{1, 3, 5, 6, 8}, 10);
```

- 泛型方法可以定义在**普通类**中，也可以定义在泛型类中。

```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

##### 泛型接口

接口也可以是泛型的，如下。使用时需要指定具体的类型。

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

```java
public class Book implements Comparable<Integer> {
    public int compareTo(Integer bookPage) {
        return compare(this.bookpage, anotherBook.bookPage);
    }
}
```

------

#### 类型变量的限定

- 类型擦除的过程即擦除(erased) 类型变量, 并替换为相应的**限定类型** (无限定的变量用 **Object**)。相当于给类型擦除指定一个边界，指定边界之后，类型擦除之后就不会变为 Object。

- 对类型进行限定

```java
// 限定min方法只能被实现了Comparab1e接口的类调用
public static <T extends Comparab1e> T min(T[] a){...}
```

- 如果有多个类型变量和多个限定类型，限定类型用&分隔，类型变量用逗号分隔。
- 如果用一个类作为限定，它必须是限定列表中的第一个。

```java
// 多个限定类型，且Students类为第一个
public static <T extends Students & Comparab1e & Serializable> Pair<T> min(T[] a){...}
```

- 上界可以是一个具体的类，也可以是一个接口，此时 T 必须实现这个接口。

```java
/**
* 泛型方法 <T extends Comparable> 为类型限定  Pair<T> 为返回类型  T[]为入参
*/
public static <T extends Comparable> Pair<T> minmax(T[] a) 
   {
      if (a == null || a.length == 0) return null;
      T min = a[0];
      T max = a[0];
      for (int i = 1; i < a.length; i++)
      {
         if (min.compareTo(a[i]) > 0) min = a[i];
         if (max.compareTo(a[i]) < 0) max = a[i];
      }
      return new Pair<>(min, max);
   }
```

------

#### 类型擦除

虚拟机**没有**泛型类型对象，虚拟机不知道泛型，所有对象都属于普通类。无论何时定义一个泛型类型，都自动提供了一个相应的**原始类型**(raw type)。

Java 泛型是通过**类型擦除**实现的。

原始类型的名字就是删去类型参数后的泛型类型名。擦除(erased) 类型变量, 并替换为**限定类型** (无限定的变量用 **Object**)。如下泛型方法

```java
public Pair(T first, T second) { 
    this.first = first;  this.second = second; 
}
```

类型擦除后原始类型变为

```java
public Pair(Object first, Object second) { 
    this.first = first;  this.second = second; 
}
```

由于没有限定类型，所以 T 换为 **Object**。另一个类如下

```java
public class Test <T extends Comparable & Serializable> implements Serializable{
    private T lower;
    private T upper;
    public Test (T first, T second){
        if (first.compareTo(second) <= 0) { lower = first; upper = second; }
        else { lower = second; upper = first; }
    }
}
```

由于其有限定类型 Comparable，所以其原始类型中 T 变为 Comparable 得到如下类。类型擦除也会出现在泛型方法中。

```java
// 擦除后变成限定类型
public class Test implements Serializable {
    private Comparable lower;
    private Coiparable upper;
    public Test (Coiparable first, Coiparable second) { . . . }
}
```

Java 泛型转换的事实：

- 虚拟机中没有泛型，只有普通的类和方法。
- 所有的类型参数都用它们的**限定类型替换**。
- **桥方法被合成来保持多态**。
- 为保持类型安全性，必要时插入强制类型转换。

------

#### 通配符

**为什么要用通配符？**

在java中，数组是可以协变的，比如dog extends Animal，那么Animal[] 与dog[]是兼容的。而集合是不能协变的，也就是说List\<Animal>不是List\<dog>的父类，这时候就可以用到通配符了。

**一、基本概念：**

在学习Java泛型的过程中, 通配符是较难理解的一部分. 主要有以下三类:

- 无边界的通配符(Unbounded Wildcards), 就是 \<?>, 比如List<?>.
    　　无边界的通配符的主要作用就是让**泛型能够接受未知类型**的数据. 
- 固定上边界的通配符(Upper Bounded Wildcards):
    　　使用**固定上边界**的通配符的泛型, 就能够接受**指定类及其子类**类型的数据. 要声明使用该类通配符, 采用   **<? extends E> ** 的形式, 这里的 **E** 就是该泛型的**上边界**. 注意: 这里虽然用的是 extends 关键字, 却不仅限于继承了父类 E 的子类, 也可以代指显现了**接口** E 的类. 
- 固定下边界的通配符(Lower Bounded Wildcards):
    　　使用固定**下边界**的通配符的泛型, 就能够接受指定**类及其父类类型**的数据. 要声明使用该类通配符, 采用   **<? super E>** 的形式, 这里的 **E** 就是该泛型的**下边界**。注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界.

**二、基本使用方法：**

**1. 无边界的通配符的使用, 我们以在集合List中使用<?>为例.** 

```java
public static void printList(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}

public static void main(String[] args) {
    List<String> l1 = new ArrayList<>();
    l1.add("aa");
    l1.add("bb");
    l1.add("cc");
    printList(l1);
    List<Integer> l2 = new ArrayList<>();
    l2.add(11);
    l2.add(22);
    l2.add(33);
    printList(l2);
    
}
```

这种使用 List<?> 的方式就是父类引用指向子类对象. 注意, 这里的 printList 方法不能写成 public static void printList(List\<Object> list)的形式, 原因我在上一篇博文中已经讲过, 虽然 Object 类是所有类的父类, 但是List\<Object> 跟其他泛型的 List 如 List\<String> ,  List\<Integer> 不存在继承关系, 因此会报错.

有一点我们必须明确, **我们不能对 List<?> 使用add方法, 仅有一个例外, 就是add(null)**. 为什么呢? 因为我们**不确定**该 List 的类型, 不知道 add 什么类型的数据才对, 只有 null 是所有引用数据类型都具有的元素。即只能读不能写，问号  ？ 就是表示类型安全无知。请看下面代码:

```java
public static void addTest(List<?> list) {
    Object o = new Object();
    // list.add(o); // 编译报错
    // list.add(1); // 编译报错
    // list.add("ABC"); // 编译报错
    list.add(null);
}
```

由于我们根本不知道 list 会接受到具有什么样的泛型 List, 所以除了 null 之外什么也不能 add。
还有, **List<?> 也不能使用 get 方法, 只有 Object 类型是个例外**. 原因也很简单, 因为我们不知道传入的 List 是什么泛型的, 所以无法接受得到的 get, 但是 Object 是所有数据类型的父类, 所以只有接受他可以, 请看下面代码:

```java
public static void getTest(List<?> list) {
    // String s = list.get(0);  // 编译报错
    // Integer i = list.get(1); // 编译报错
    Object o = list.get(2);
}
```

不是有强制类型转换么? 是有, 但是我们不知道会传入什么类型, 比如我们将其强转为 String, 编译是通过了, 但是如果传入个 Integer 泛型的 List, 一运行还会出错。那么保证传入的String类型的数据不就好了么? 那样是没问题了, 但是那还用 <?> 干嘛呀? 直接 List\<String> 不就行了。

**2. 固定上边界的通配符的使用**

 仍旧以List为例来说明。

```java
public static double sumOfList(List<? extends Number> list) {
    double s = 0.0;
    for (Number n : list) {
        // 注意这里得到的n是其上边界类型的, 也就是Number, 需要将其转换为double.
        s += n.doubleValue();
    }
    return s;
}

public static void main(String[] args) {
    List<Integer> list1 = Arrays.asList(1, 2, 3, 4);
    System.out.println(sumOfList(list1));
    List<Double> list2 = Arrays.asList(1.1, 2.2, 3.3, 4.4);
    System.out.println(sumOfList(list2));
}
```

有一点我们需要记住的是, **List<? extends E> 不能使用 add 方法**, 请看如下代码:

```java
public static void addTest2(List<? extends Number> l) {
    // l.add(1);   // 编译报错
    // l.add(1.1); //编译报错
    l.add(null);
}
```

原因很简单, 泛型 <? extends E> 指的是 E 及其子类, 这里传入的可能是 Integer, 也可能是 Double, 我们在写这个方法时不能确定传入的什么类型的数据, 如果我们调用:

```java
List<Integer> list = new ArrayList<>();
addTest(list);
```

那么我们之前写的 add(1.1) 就会出错, 反之亦然, 所以除了 null 之外什么也不能 add. 但是 get 的时候是可以得到一个 Number, 也就是**上边界类型**的数据的, 因为不管存入什么数据类型都是 Number 的子类型, 得到这些就是一个**父类引用指向子类**对象. 

**3. 固定下边界通配符的使用**

这个较前面的两个有点难理解, 首先仍以List为例.

```java
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}

public static void main(String[] args) {
    List<Object> list1 = new ArrayList<>();
    addNumbers(list1);
    System.out.println(list1);
    List<Number> list2 = new ArrayList<>();
    addNumbers(list2);
    System.out.println(list2);
    List<Double> list3 = new ArrayList<>();
    // addNumbers(list3); // 编译报错
}
```

我们看到, List<? super E> 是能够调用 add 方法的, 因为我们在 addNumbers 所 add 的元素就是 Integer 类型的, 而传入的 list 不管是什么, 都一定是 Integer 或其父类泛型的 List, 这时 add 一个 Integer 元素是没有任何疑问的. 但是, **我们不能使用get方法**, 除非使用 Object 类型来接收，请看如下代码:

```java
public static void getTest2(List<? super Integer> list) {
    // Integer i = list.get(0); // 编译报错
    Object o = list.get(1);
}
```

这个原因也是很简单的, 因为我们所传入的类都是 Integer 的类或其父类, 所传入的数据类型可能是 Integer 到Object 之间的任何类型, 这是**无法预料**的, 也就无法接收. 唯一能确定的就是 Object, 因为所有类型都是其**子类型**.
使用 <? super E> 还有个常见的场景就是 **Comparator**. 

**通配符总结**

上述几种通配符的使用原则，有人将其称为 PECS (即"Producer Extends, Consumer Super", 网上翻译为"**生产者使用 extends, 消费者使用 super**"。

- <?> <? extends E> 用于**灵活读取**，使用方法可以读取 E 或者 E 的任意子类型的容器对象。可将该对象当成只读对象，类似生产者。
- <? super E> 用于**灵活写入与比较**，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象。可将该对象当成只能写对象，类似消费者。

---

#### 泛型的约束与局限性

局限性多半是由类型擦除引起。

**1. 不能用基本类型实例化类型参数**

不能用类型参数代替基本类型。因此没有 Pair\<double>, 只有 **Pair\<Double>**。其原因是类型擦除。擦除之后，Pair类含有 **Object** 类型的域，而 Object 不能存储 double 值。

**2. 运行时类型查询只适用于原始类型**

虚拟机中的对象总有一个特定的非泛型类型。因此所有的类型查询只产生原始类型。
**getClass** 方法总是返回**原始类型**。例如：

```java
Pair<String> stringPair = . .
Pair<Employee> employeePair = . .
if (stringPair.getClass() == employeePair.getClass()) // they are equal
```

其比较的结果是 true, 这是因为两次调用 getClass 都将返回 Pair.class。

**3. 不能创建参数化类型的数组**

不能实例化参数化类型的数组， 例如：

```java
Pair<String>[] table = new Pair<String>[10]; // 错误 传入String已经是参数化了
```

擦除之后，table的类型是 Pair[]。 可以把它转换为 Object[]:

```java
Object[] objarray = table;
```

数组会**记住**它的元素类型， 如果试图存储其他类型的元素，就会抛出一个 ArrayStoreException 异常。

**但是**可以向参数个数可变的方法传递一个泛型类型的实例。如下面的参数可变的方法:

```java
public static <T> void addAll(Collections coll, T... ts){
    for (t : ts) coll.add(t);
}
```

为了调用这个方法，Java 虚拟机必须建立一个 Pair\<String> 数组，这就违反了前面的规则。不过，这种情况只会得到一个**警告**，而不是错误。
可以在addAll方法上标注解@SafeVarargs或注解@SuppressWanings("unchecked")来抑制此警告。可以使用 @SafeVarargs标注来消除创建泛型数组的有关限制，但是有些危险。

**4. 不能通过类型参数创建对象**

不能使用像 new T(...)  new T[...]  或  T.class  这样的表达式中的类型变量。最好的是让调用者提供一个**构造器**表达式。

```java
public Pair() { 
    first = new T(); 
    second = new T(); 
} // 非法

Pair<String> p = Pair.makePair(String::new);    // 提供构造表达式 合法
```

如果需要根据类型创建对象，可以通过反射的方式实现。

```java
first = T.class.newInstance(); // 非法 T.class非法，会转为Object.class
// 可以通过以下的API得到class对象
public static <T> Pair<T> makePair(Class<T> cl){
    try { 
        return new Pair<>(cl.newInstance(), cl.newInstance()); }
    catch (Exception ex) { 
        return null; 
    }
}
// 使用如下方式调用
Pair<String> p = Pair.makePair(String.class);
```

**5. 不能创建泛型数组**

数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被**擦除**。

```java
public static <T extends Comparable>T[] minmax(T[] a) { T[] mm = new T[2]; ...} // 非法
```

类型擦除会让这个方法**永远构造 Comparable[2] 数组**。如果现实需要能够存放泛型对象的容器，可以使用**原始类型**的数组。如。

```java
Pair[] options = new Pair {
    new Pair<String, Integer>("1", 2),
    new Pair<String, Integer>("2", 2)
};
```

泛型容器内部使用 Object 数组，如果要转换泛型容器为对应类型的数组，需要使用反射。

 最好让用户提供一个**数组构造器表达式**：

```java
String[] ss = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");
```

----

#### 泛型面试题

**Java的泛型是如何工作的 ? 什么是类型擦除 ?**

泛型是通过**类型擦除**来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List\<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行**兼容**。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了**原始类型**。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。

**什么是泛型中的限定通配符和非限定通配符 ?**

这是另一个非常流行的Java泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是 \<? extends T> 它通过确保类型必须是T的子类来设定类型的上界，另一种是 \<? super T> 它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 \<?> 表示了非限定通配符，因为 <?> 可以用**任意类型**来替代。

 **List<? extends T>和List <? super T>之间有什么区别 ?**

这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个List的声明都是限定通配符的例子，List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。例如List<? extends Number>可以接受List\<Integer>或List\<Float>。

**编写一段泛型程序来实现LRU缓存?**

对于喜欢Java编程的人来说这相当于是一次练习。给个提示，LinkedHashMap 可以用来实现固定大小的LRU缓存，当LRU缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap 提供了一个称为removeEldestEntry() 的方法，该方法会被 put() 和 putAll() 调用来删除最老的键值对。当然，如果你已经编写了一个可运行的JUnit测试，你也可以随意编写你自己的实现代码。

**你可以把List\<String>传递给一个接受List\<Object>参数的方法吗？**

对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List\<String>应当可以用在需要List\<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List\<Object>可以存储任何类型的对象包括String, Integer等等，而List\<String>却只能用来存储Strings。　

```java
List<Object> objectList;
List<String> stringList;
objectList = stringList;  // compilation error incompatible types
```

**Array中可以用泛型吗?**

这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道 Array 事实上并不支持泛型，这也是为什么 Effective Java 一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。





## 二、通用容器类

### 概览

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。

#### Collection

![1563604728498](assets/1563604728498.png)

##### 1. Set

- TreeSet：基于**红黑树**实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于**哈希表**实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。

##### 2. List

- ArrayList：基于**动态数组**实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于**双向链表**实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

##### 3. Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于**堆结构**实现，可以用它来实现优先队列。

------

#### Map

![1563604743962](assets/1563604743962.png)

- TreeMap：基于**红黑树**实现。
- HashMap：基于**哈希表**实现。
- HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是**遗留类**，不应该去使用它。现在可以使用 **ConcurrentHashMap** 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了**分段锁**。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（**LRU**）顺序。



### 容器中的设计模式

#### 迭代器模式

![1563604760815](assets/1563604760815.png)

Collection 继承了 **Iterable** 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。

从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

```java
List<String> list = new ArrayList<>();
list.add("a");
list.add("b");
for (String item : list) {
    System.out.println(item);
}
```

------

#### 适配器模式

java.util.Arrays.asList() 可以把**数组**类型转换为 List 类型。

```java
@SafeVarargs
public static <T> List<T> asList(T... a)
```

应该注意的是 asList() 的参数为泛型的变长参数，**不能使用基本类型**数组作为参数，只能使用相应的包装类型数组。

```java
Integer[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
```

也可以使用以下方式调用 asList()：

```java
List list = Arrays.asList(1, 2, 3);
```





## 三、列表与队列

### ArrayList

#### 1. 概览

- 使用时需要实例化泛型参数。
- 不是线程安全的。
- 可以随机访问，按照索引进行访问的效率很高，效率为 O(1)。
- 除非数组已经排序，否则按照内容查找元素效率较低，效率为 O(N)。
- 添加元素效率还行，但是会面临数组扩容与内容复制等开销问题。
- 插入与删除元素效率较低，因为需要移动元素。



因为 ArrayList 是基于**数组**实现的，所以支持**快速随机访问**。RandomAccess 接口标识着该类支持快速随机访问，RandomAccess 是一个标记接口，没有任何方法。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

数组的默认大小为 10。

```java
private static final int DEFAULT_CAPACITY = 10;
```

![1563604782084](assets/1563604782084.png)

#### 2. 扩容

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，也就是旧容量的 **1.5 倍**。elementData 数组会随着实际元素个数的增多而重新分配。

扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就**指定**大概的容量大小，**减少扩容操作的次数**。

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;		// size 用于记录实际的元素个数	
    return true;
}

// 确保数组容量足够
private void ensureCapacityInternal(int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    // 表示内部修改次数
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

// 增加数组容量
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    // 右移一位相当于除2，因此扩容为原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

#### 3. 删除元素

需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是**非常高**的。

```java
public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // 释放引用以便原对象被垃圾回收
    return oldValue;
}
```

**迭代与删除**

迭代器的常见误用就是在迭代的中间调用容器的删除方法。

```java
List<String> list = new ArrayList<>();
list.add("str1");
list.add("str2");
list.add("str3");
for (String s : list) {
    if ("str1".equals(s)) {
        list.remove(s);
    }
}
```

这段代码看起来好像没有什么问题，但是如果我们运行，就会抛出 **ConcurrentModificationException** 异常。

其实这不是特例，每当我们使用迭代器遍历元素时，如果修改了元素内容（添加、删除元素），就会抛出异常，由于 **foreach** 同样使用的是迭代器，所以也有同样的情况。

remove 方法的源码

```java
public class ArrayList<E> {

    void remove() {
        modCount++;  // 继承自AbstractList的属性，保存对其中元素的修改次数，每次增加或删除时加1
        // 具体删除操作代码
        //...
    }
  
    public Iterator<E> iterator() {
        return new Itr();
    }

    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        // 在创建迭代器时将当前ArrayList的修改次数赋值给 expectedModCount 保存
        int expectedModCount = modCount;
        public boolean hasNext() {
            return cursor != size;
        }
        
        @SuppressWarnings("unchecked")
        public E next() {
            // 检查当前所在的 ArrayList 的 modCount 是否与创建 Itr 时的值一致，
            // 也就是判断获取了Itr迭代器后 ArrayList 中的元素是否被 Itr 外部的方法改变过。
            checkForComodification();
            // 具体的获取下一个元素的代码
            // ...
        }
        
        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            // 同 next 中的 checkForComodification 方法
            checkForComodification();
            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                // Itr 内部的删除元素操作，会更新 expectedModCount 值，而外部的则不会
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
}
```

可以明显的看到共有两个`remove()`方法，一个属于 ArrayList 本身，还有一个属于其内部类 Itr。ArrayList 类中有一个 modCount 属性，这个属性是继承子AbstractList，其保存了我们对 ArrayList 进行的的**操作次数**，当我们添加或者删除元素时，modeCount 都会进行对应次数的**增加**。相当于记录了结构性变化，即添加、插入、删除元素，只是修改元素的内容不算结构性变化。

在我们使用 ArrayList 的 `iterator()` 方法获取到迭代器进行遍历时，会把 ArrayList 当前状态下的 modCount 赋值给 Itr 类的 expectedModeCount 属性。如果我们在迭代过程中，使用了 ArrayList 的 `remove()`或`add()`方法，这时 modCount 就会加 1 ，但是迭代器中的expectedModeCount 并没有变化，当我们再使用迭代器的`next()`方法时，它会调用`checkForComodification()`方法，即

```java
final void checkForComodification() {
    if (modCount != expectedModCount)
    throw new ConcurrentModificationException();
}
```

发现现在的 modCount 已经与 expectedModCount **不一致**了，则会抛出`ConcurrentModificationException`异常。

但是如果我们使用迭代器提供的`remove()`方法，由于其有一个操作：`expectedModCount = modCount;`，会修改expectedModCount 的值，所以就不会存在上述问题。调用remove 方法之前需要先调用 next 方法。



#### 4. Fail-Fast

fail-fast 机制在遍历一个集合时，当集合结构被修改，会抛出 ConcurrentModificationException。

modCount 用来记录 ArrayList **结构发生变化的次数**。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。

在进行**序列化或者迭代**等操作时，需要**比较**操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。

```java
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
```

#### 5. 序列化

ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么**就没必要全部**进行序列化。

保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认**不会被序列化**。

```java
transient Object[] elementData; // non-private to simplify nested class access
```

ArrayList 实现了 writeObject() 和 readObject() 来控制**只序列化数组中有元素填充那部分**内容。数组没有存元素的部分不序列化。

```java
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size > 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            a[i] = s.readObject();
        }
    }
}
```

```java
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i<size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}
```

序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为**字节流**并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去**反射**调用该对象的 writeObject() 来实现**序列化**。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。

```java
ArrayList list = new ArrayList();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
oos.writeObject(list);
```

#### 6. Arrays.asList()

Arrays类的静态方法 asList() 将数组转为集合。

```java
String[] str = new String[]{"1","2","3"};
List aslist = Arrays.asList(str);
aslsit.add("4");
// Exception in thread "main" java.lang.UnsupportedOperationException
//    at java.util.AbstractList.add(Unknown Source)
//    at java.util.AbstractList.add(Unknown Source)
//    at test.LinkedListTest.main(LinkedListTest.java:13)
```

其实 asList() 返回的是 java.util.Arrays.ArrayList 对象，不是上述的 ArrayList 类！！！！

看 Arrays 类的部分源码

```java
public class Arrays {
    
    // 省略其他方法
    
    public static <T> List<T> asList(T... a) {
        return new ArrayList<>(a);
    }
        
    // 就是这个家伙             👇
    private static class ArrayList<E> extends AbstractList<E>
            implements RandomAccess, java.io.Serializable{
    
        private final E[] a;
    
        ArrayList(E[] array) {
            a = Objects.requireNonNull(array);
        }
    
        @Override
        public int size() {
            return a.length;
        }
        //省略其他方法
    }
}
```

Arrays.ArrayList 是工具类 Arrays 的一个**内部静态类**，它**没有完全**实现 List 的方法，而 ArrayList 直接实现了List 接口，实现了 List 所有方法。Arrays.ArrayList 是一个定长集合，因为它**没有重写** add, remove 方法，所以一旦初始化元素后，集合的 size 就是不可变的。所以使用这种方法会抛 UnsupportedOperationException 异常。

**正确**的使用方式：

```java
String[] str = new String[]{"1","2","3"};
ArrayList al = new ArrayList(Arrays.asList(str)); // 将数组元素添加到集合的一种快捷方式
```





### LinkedList

#### 1. 概览

- 同样实现了 List 接口，其特点与 ArrayList 几乎相反。
- LinkedList 还实现了 Deque 和 Queue 接口，可以按照队列、栈和双端队列的方式进行操作。
- LinkedList 是线程不安全的队列。

#### 2. 与 ArrayList 的比较

- ArrayList 基于**动态数组**实现，LinkedList 基于**双向链表**实现；
- ArrayList 支持**随机访问**，LinkedList 不支持；
- LinkedList 在任意位置添加删除元素**更快**。

#### 3. 基本使用

##### 构造方法

```java
LinkedList() 	// 用于创建一个新的空linkedList
LinkedList(Collection<? extends E> c) // 使用一个集合创建一个新的linkedList
```

```java
public class Main {
    public static void main(String[] args) {
        LinkedList<String> linkedList1 = new LinkedList<>();
        System.out.println(linkedList1);
        String[] arr = {"H", "E", "L", "L", "O"};
        LinkedList<String> linkedList2 = new LinkedList<>(Arrays.asList(arr));
        System.out.println(linkedList2);
    }
}
```

##### 其他方法

```java
int size();  	// 它返回此列表中元素的数量
void clear();  	// 它删除列表中的所有元素
Object clone();	//它用于制作现有链接列表的副本
Object set(int index，Object element);  // 它用于用新元素替换列表中的现有元素
boolean contains(Object element);		// 如果元素存在于列表中，则返回true
boolean add(Object element);			// 它将元素附加到列表的末尾
void add(int index，Object element);	   // 它将元素插入列表中'index'位置
boolean addAll(Collection C);			// 它将一个集合追加到链接列表
boolean addAll(int index，Collection C);// 它将一个集合追加到指定位置的链表中
void addFirst(Object element);			// 它将元素插入列表的开头
void addLast(Object element);			// 它将元素附加在列表的末尾
Object get(int index);	// 它返回列表中位置'index'处的元素。如果索引超出了列表的范围，它会抛出'IndexOutOfBoundsException'
Object getFirst();		// 它返回链表的第一个元素
Object getLast();		// 它返回链接列表的最后一个元素
int indexOf(Object element);	// 如果找到元素，它将返回元素第一次出现的索引。否则，它返回-1
int lastIndexOf(Object element);// 如果找到元素，它将返回元素最后一次出现的索引。否则，它返回-1
Object remove();		// 它用于从列表头部删除并返回元素
Object remove(int index);		// 它删除此列表中位置'index'处的元素。如果列表为空，它会抛出'NoSuchElementException'
boolean remove(Object O);		// 它用于从链表中移除一个特定的元素并返回一个布尔值
Object removeLast();			// 它用于删除并返回链接列表的最后一个元素
```

#### 4. 源码解析

基于**双向链表**实现，使用 Node 存储链表节点信息，并维护了长度、头结点和尾结点。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
     
    Node(Node<E> prev, E element, Node<E> next) {
    	this.item = element;
     	this.next = next;
     	this.prev = prev;
 	}
}
```

每个链表存储了 first 和 last 指针，LinkedList 中的属性如下

```java
// 链表的节点个数
transient int size = 0;
// 指向头节点的指针
transient Node<E> first;
// 指向尾节点的指针
transient Node<E> last;
```

![1567326494424](assets/1567326494424.png)

**添加元素**

对于链表这种数据结构来说，添加元素的操作无非就是在表头/表尾插入元素，又或者在指定位置插入元素。因为 LinkedList 有头指针和尾指针，所以在表头或表尾进行插入元素只需要 O(1) 的时间，而在指定位置插入元素则需要先遍历一下链表，所以复杂度为 O(n)。

在表头添加元素的过程如下：

![1567329260161](assets/1567329260161.png)

当向**表头**插入一个节点时，很显然当前节点的**前驱**一定为 **null**，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点，源码的实现如下：

```java
private void linkFirst(E e) {
    final Node<E> f = first;
    // 当前节点的前驱指向 null，后继指针原来的头节点
    final Node<E> newNode = new Node<>(null, e, f);
    // 头指针指向新的头节点
    first = newNode;
    // 如果原来有头节点，则更新原来节点的前驱指针，否则更新尾指针
    if (f == null) {
        last = newNode;
    } else {
        f.prev = newNode;
    }
    size++;
    modCount++;
}
```

当向**表尾**插入一个节点时，很显然当前节点的**后继**一定为 **null**，而前驱结点是 last指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾节点的后继指针，使它指向新的尾节点，此处不赘述。

最后，在指定节点之前插入，如图所示

![1567329526899](assets/1567329526899.png)

当向指定节点之前插入一个节点时，当前节点的**后继为指定节点**，而**前驱结点为指定节点的前驱节点**。此外，还要修改前驱节点的后继为当前节点，以及后继节点的前驱为当前节点，源码的实现如下：

```java
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    //指定节点的前驱
    final Node<E> pred = succ.prev;
    //当前节点的前驱为指点节点的前驱，后继为指定的节点
    final Node<E> newNode = new Node<>(pred, e, succ);
    //更新指定节点的前驱为当前节点
    succ.prev = newNode;
    //更新前驱节点的后继
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

**数据包含**

```java
public boolean contains(Object o) {
     return indexOf(o) != -1;
 }
 // 从前向后查找，返回“值为对象(o)的节点对应的索引”  不存在就返回-1 
 public int indexOf(Object o) {
      int index = 0;
      if (o==null) {
          for (Entry e = header.next; e != header; e = e.next) {
              if (e.element==null)
                  return index;
              index++;
         }
      } else {
         for (Entry e = header.next; e != header; e = e.next) {
             if (o.equals(e.element))
                 return index;
             index++;
        }
    }
     return -1;
 }
```

indexOf(Object o)判断o链表中是否存在节点的element和o相等，若相等则返回该节点在链表中的索引位置，若不存在则放回-1。

contains(Object o)方法通过判断indexOf(Object o)方法返回的值是否是-1来判断链表中是否包含对象o。

**获取数据**

Get(int) 方法用于获取指定位置的数据。首先判断位置信息是否合法（大于等于0，小于当前 LinkedList 实例的Size），然后**遍历**到具体位置，获得节点的业务数据（element）并返回。

注意：为了提高效率，需要根据获取的位置判断是从头还是从尾开始遍历。

```java
// 获取双向链表中指定位置的节点    
private Entry<E> entry(int index) {    
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size); 
    }   
   
    Entry<E> e = header;    
    // 获取index处的节点。    
    // 若index < 双向链表长度的1/2,则从前先后查找;    
    // 否则，从后向前查找。    
    if (index < (size >> 1)) {    
        for (int i = 0; i <= index; i++)    
            e = e.next;    
    } else {    
        for (int i = size; i > index; i--)    
            e = e.previous;    
    }    
    return e;    
}
```

注意细节：**位运算**与直接做除法的区别。先将 index 与长度 size 的**一半**比较，如果 index < size / 2，就只从位置0 往后遍历到位置 index 处，而如果 index > size / 2，就只从位置 size 往前遍历到位置 index 处。这样可以减少一部分不必要的遍历。

**删除数据remove()**

几个remove方法最终都是调用了一个私有方法：remove(Entry\<E> e)，只是其他简单逻辑上的区别。下面分析remove(Entry\<E> e) 方法。

![1567330247769](assets/1567330247769.png)

```java
private E remove(Entry<E> e) {
    if (e == header){
        throw new NoSuchElementException();
    }
    // 保留将被移除的节点e的内容
    E result = e.element;
    // 将前一节点的next引用赋值为e的下一节点
    e.previous.next = e.next;
    // 将e的下一节点的previous赋值为e的上一节点
    e.next.previous = e.previous;
    // 上面两条语句的执行已经导致了无法在链表中访问到e节点，而下面解除了e节点对前后节点的引用
    e.next = e.previous = null;
    // 将被移除的节点的内容设为null
    e.element = null;
    // 修改size大小
    size--;
    modCount++;
    // 返回移除节点e的内容
    return result;
}
```

由于删除了某一节点因此调整相应节点的前后指针信息，如下：

```java
e.previous.next = e.next;	// 预删除节点的前一节点的后指针指向预删除节点的后一个节点
e.next.previous = e.previous;	// 预删除节点的后一节点的前指针指向预删除节点的前一个节点
```

清空预删除节点：

```java
e.next = e.previous = null;
e.element = null;
```

交给gc完成资源回收，删除操作结束。

与ArrayList比较而言，LinkedList的删除动作不需要“移动”很多数据，从而效率更高。







### Vector

#### 1. 同步

它的实现与 ArrayList 类似，但是使用了 **synchronized** 进行同步。在方法上加 synchronized 。

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

#### 2. 与 ArrayList 的比较

- Vector 是**同步**的，因此**开销**就比 ArrayList 要**大**，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；
- Vector 每次扩容请求其大小的 **2 倍**空间，而 ArrayList 是 **1.5 倍**。

#### 3. 替代方案

可以使用 `Collections.synchronizedList();` 得到一个**线程安全的 ArrayList**。

```java
List<String> list = new ArrayList<>();
List<String> synList = Collections.synchronizedList(list);	// ※
```

也可以使用 concurrent 并发包下的 **CopyOnWriteArrayList** 类。

```java
List<String> list = new CopyOnWriteArrayList<>();
```





### ArrayDeque

#### 概述

- Queue 也是 Java 集合框架中定义的一种接口，直接继承自 Collection 接口。除了基本的 Collection 接口规定测操作外，Queue 接口还定义一组针对队列的特殊操作。通常来说，Queue 是按照先进先出 (FIFO) 的方式来管理其中的元素的，但是优先队列是一个例外。

- Deque 接口继承自 Queue接口，但 Deque 支持同时从两端添加或移除元素，因此又被成为双端队列。鉴于此，Deque 接口的实现可以被当作  FIFO 队列使用，也可以当作LIFO队列（栈）来使用。官方也是推荐使用 Deque 的实现来替代 Stack。

- ArrayDeque 是 Deque 接口的一种具体实现，是依赖于可变数组来实现的。ArrayDeque 没有容量限制，可根据需求自动进行扩容。ArrayDeque**不支持**值为 **null** 的元素。

- ArrayDeque 可以作为**栈**来使用，效率要高于 Stack；ArrayDeque 也可以作为**队列**来使用，效率相较于基于双向链表的 LinkedList 也要更好一些。

#### 源码分析

**Queue 接口**

```java
public interface Queue<E> extends Collection<E> {
    // 向队列中插入一个元素，并返回true
    // 如果队列已满，抛出IllegalStateException异常
    boolean add(E e);

    // 向队列中插入一个元素，并返回true
    // 如果队列已满，返回false
    boolean offer(E e);

    // 取出队列头部的元素，并从队列中移除
    // 队列为空，抛出NoSuchElementException异常
    E remove();

    // 取出队列头部的元素，并从队列中移除
    // 队列为空，返回null
    E poll();

    // 取出队列头部的元素，但并不移除
    // 如果队列为空，抛出NoSuchElementException异常
    E element();

    // 取出队列头部的元素，但并不移除
    // 队列为空，返回null
    E peek();
}
```

Deque 和 Queue 方法的的对应关系如下：

| Queue Method | Equivalent Deque Method |
| :----------: | :---------------------: |
|    add(e)    |       addLast(e)        |
|   offer(e)   |      offerLast(e)       |
|   remove()   |      removeFirst()      |
|    poll()    |       pollFirst()       |
|  element()   |       getFirst()        |
|    peek()    |       peekFirst()       |

Deque 和 Stack 方法的对应关系如下：

| Stack Method | Equivalent Deque Method |
| :----------: | :---------------------: |
|   push(e)    |       addFirst(e)       |
|    pop()     |      removeFirst()      |
|    peek()    |       peekFirst()       |

ArrayList 实现了 Deque 接口中的所有方法。因为 ArrayList 会根据需求自动扩充容量，因而在插入元素的时候不会抛出IllegalStateException异常。

**底层结构**

```java
// 用数组存储元素
transient Object[] elements; // non-private to simplify nested class access
// 头部元素的索引
transient int head;
// 尾部下一个将要被加入的元素的索引
transient int tail;
// 最小容量，必须为2的幂次方
private static final int MIN_INITIAL_CAPACITY = 8;
```

在 ArrayDeque 底部是使用**数组**存储元素，同时还使用了**两个索引**来表征当前数组的状态，分别是 head 和 tail。head 是头部元素的索引，但注意 **tail *不是尾部元素的索引，而是尾部元素的下一位***，即下一个将要被加入的元素的索引。

**初始化**

ArrayDeque 提供了三个构造方法，分别是默认容量，指定容量及依据给定的集合中的元素进行创建。默认容量为16。

```java
public ArrayDeque() {
    elements = new Object[16];
}

public ArrayDeque(int numElements) {
    allocateElements(numElements);
}

public ArrayDeque(Collection<? extends E> c) {
    allocateElements(c.size());
    addAll(c);
}
```

ArrayDeque 对数组的大小(即队列的容量)有特殊的要求，必须是 **2^n**。通过 `allocateElements`方法计算初始容量：

```java
private void allocateElements(int numElements) {
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // Find the best power of two to hold elements.
    // Tests "<=" because arrays aren't kept full.
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>>  1);
        initialCapacity |= (initialCapacity >>>  2);
        initialCapacity |= (initialCapacity >>>  4);
        initialCapacity |= (initialCapacity >>>  8);
        initialCapacity |= (initialCapacity >>> 16);
        initialCapacity++;

        if (initialCapacity < 0)   // Too many elements, must back off
            initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
    }
    elements = new Object[initialCapacity];
}
```

`>>>`是无符号右移操作，`|`是位或操作，经过五次右移和位或操作可以保证得到大小为 **2^k-1** 的数。看一下这个例子：

```java
0 0 0 0 1 ? ? ? ? ?     // n
0 0 0 0 1 1 ? ? ? ?     // n |= n >>> 1;
0 0 0 0 1 1 1 1 ? ?     // n |= n >>> 2;
0 0 0 0 1 1 1 1 1 1     // n |= n >>> 4;
```

在进行 5 次位移操作和位或操作后就可以得到 **2^k-1**，最后加1即可

**添加元素**

向末尾添加元素：

```java
public void addLast(E e) {
    if (e == null)
        throw new NullPointerException();
    // tail 中保存的是即将加入末尾的元素的索引
    elements[tail] = e;
    // tail 向后移动一位
    // 把数组当作环形的，越界后到0索引
    if ( (tail = (tail + 1) & (elements.length - 1)) == head)
        // tail 和 head相遇，空间用尽，需要扩容
        doubleCapacity();
}
```

这段代码中，`(tail = (tail + 1) & (elements.length - 1)) == head`这句有点难以理解。其实，在 ArrayDeque 中数组是当作**环形**来使用的，索引 0 看作是紧挨着索引 (length-1) 之后的。参考下面的图片（tail 指向的是**下一个**即将存放元素的位置）

![1567335804367](assets/1567335804367.png)

那么为什么`(tail + 1) & (elements.length - 1)`就能保证按照环形取得正确的下一个索引值呢？这就和前面说到的 ArrayDeque 对容量的**特殊要求**有关了。下面对其正确性加以验证：

```
length = 2^n，二进制表示为: 第 n 位为1，低位 (n-1位) 全为0 
length - 1 = 2^n-1，二进制表示为：低位(n-1位)全为1

如果 tail + 1 <= length - 1，则位与后低 (n-1) 位保持不变，高位全为0
如果 tail + 1 = length，则位与后低 n 全为0，高位也全为0，结果为 0
```

可见，在容量保证为 **2^n** 的情况下，仅仅通过**位与**操作就可以完成***环形*索引**的计算，而不需要进行边界的判断，在实现上更为高效。

向头部添加元素的代码如下：

```java
public void addFirst(E e) {
    if (e == null) // 不支持值为null的元素
        throw new NullPointerException();
    elements[head = (head - 1) & (elements.length - 1)] = e;
    if (head == tail)
        doubleCapacity();
}
```

其它的诸如add，offer，offerFirst，offerLast 等方法都是基于上面这两个方法实现的，不再赘述。

**扩容**

在每次添加元素后，如果**头索引和尾部索引**相遇，则说明数组空间已满，需要进行**扩容**操作。 ArrayDeque 每次扩容都会在原有的容量上**翻倍**，这也是对容量必须是 2 的幂次方的保证。如下图所示，扩容后会复制内容，复制的时候会进行重排，将 head 放在第一个。

![1567336287071](assets/1567336287071.png)

```java
private void doubleCapacity() {
    assert head == tail; // 扩容时头部索引和尾部索引肯定相等
    int p = head;
    int n = elements.length;
    // 头部索引到数组末端(length-1处)共有多少元素
    int r = n - p; // number of elements to the right of p
    // 容量翻倍
    int newCapacity = n << 1;
    // 容量过大，溢出了
    if (newCapacity < 0)
        throw new IllegalStateException("Sorry, deque too big");
    // 分配新空间
    Object[] a = new Object[newCapacity];
    // 复制头部索引到数组末端的元素到新数组的头部
    System.arraycopy(elements, p, a, 0, r);
    // 复制其余元素
    System.arraycopy(elements, 0, a, r, p);
    elements = a;
    // 重置头尾索引
    head = 0;
    tail = n;
}
```

**移除元素**

ArrayDeque 支持从**头尾两端**移除元素，remove 方法是通过 poll 来实现的。因为是基于数组的，在了解了环的原理后这段代码就比较容易理解了。

```java
public E pollFirst() {
    int h = head;
    @SuppressWarnings("unchecked")
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null)
        return null;
    elements[h] = null;     // Must null out slot
    head = (h + 1) & (elements.length - 1);
    return result;
}

public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    @SuppressWarnings("unchecked")
    E result = (E) elements[t];
    if (result == null)
        return null;
    elements[t] = null;
    tail = t;
    return result;
}
```

**获取队头和队尾的元素**

```java
@SuppressWarnings("unchecked")
public E peekFirst() {
    // elements[head] is null if deque empty
    return (E) elements[head];
}

@SuppressWarnings("unchecked")
public E peekLast() {
    return (E) elements[(tail - 1) & (elements.length - 1)];
}
```

**迭代器**

ArrayDeque 在迭代是检查并发修改**并没有使用**类似于 ArrayList 等容器中使用的 **modCount**，而是通过**尾部索引**来确定的。具体参考 next 方法中的注释。但是这样**不一定**能保证检测到所有的并发修改情况，加入先移除了尾部元素，又添加了一个尾部元素，这种情况下迭代器是没法检测出来的。

```java
private class DeqIterator implements Iterator<E> {
    /**
     * Index of element to be returned by subsequent call to next.
     */
    private int cursor = head;

    /**
     * Tail recorded at construction (also in remove), to stop
     * iterator and also to check for comodification.
     */
    private int fence = tail;

    /**
     * Index of element returned by most recent call to next.
     * Reset to -1 if element is deleted by a call to remove.
     */
    private int lastRet = -1;

    public boolean hasNext() {
        return cursor != fence;
    }

    public E next() {
        if (cursor == fence)
            throw new NoSuchElementException();
        @SuppressWarnings("unchecked")
        E result = (E) elements[cursor];
        // This check doesn't catch all possible comodifications,
        // but does catch the ones that corrupt traversal
        // 如果移除了尾部元素，会导致tail != fence
        // 如果移除了头部元素，会导致 result == null
        if (tail != fence || result == null)
            throw new ConcurrentModificationException();
        lastRet = cursor;
        cursor = (cursor + 1) & (elements.length - 1);
        return result;
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        if (delete(lastRet)) { // if left-shifted, undo increment in next()
            cursor = (cursor - 1) & (elements.length - 1);
            fence = tail;
        }
        lastRet = -1;
    }

    public void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        Object[] a = elements;
        int m = a.length - 1, f = fence, i = cursor;
        cursor = f;
        while (i != f) {
            @SuppressWarnings("unchecked") E e = (E)a[i];
            i = (i + 1) & m;
            if (e == null)
                throw new ConcurrentModificationException();
            action.accept(e);
        }
    }
}
```









### PriorityQueue

#### 概述

- 优先级队列，基于堆实现。
- 堆是一种数据结构，**概念上是==树==，存储上是==数组==**，父子有特殊顺序，根是最大/最小值，构建、添加、删除效率都很高。
- 实现了队列接口 Queue，每个元素都有优先级，**队头**的元素永远都是**优先级最高**的。
- 内部元素**不是完全有序**，但是**逐个**出队列会得到**完全有序**的输出。
- 最先出队的总是优先级最高的，即排序中的第一个。
- 查看头部元素效率很高，为O(1)， 入队、出队效率比较高，为O(log2(N))，构建堆 heapify 的效率为 O(N)。



#### 应用实例

##### TopK问题

用 PriorityQueue 默认是自然顺序排序，**要选择最大的k个数，构造最小堆**，每次取数组中剩余数与堆顶的元素进行比较，如果新数比堆顶元素大，则删除堆顶元素，并添加这个新数到堆中。可用于元素个数不确定还需要实时**动态添加**的问题。也可以求**第 K 个**元素。

Java中的PriorityQueue来实现堆，用PriorityQueue的实现的代码如下：

```java
public class findTopK {
    // 找出前k个最大数，采用小顶堆实现
    public static int[] findKMax(int[] nums, int k) {
        // 队列默认自然顺序排列，小顶堆，不必重写compare
        PriorityQueue<Integer> pq = new PriorityQueue<>(k);

        for (int num : nums) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (pq.peek() < num) { // 如果堆顶元素 < 新数，则删除堆顶，加入新数入堆
                pq.poll();
                pq.offer(num);
            }
        }

        int[] result = new int[k];
        for (int i = 0; i < k && !pq.isEmpty(); i++) {
            result[i] = pq.poll();
        }
        return result;
    }

    public static void main(String[] args) {
        int[]arr=new int[]{1, 6, 2, 3, 5, 4, 8, 7, 9};
        System.out.println(Arrays.toString(findKMax(arr,5)));
    }
}
/**
* 输出：[5, 6, 7, 8, 9]
*/
```



##### 求中值

求中值的一个基本思路是排序，排序之后找到中间值。如果元素会动态添加，就可以使用堆。维护两个堆，一个最大堆，一个最小堆。

思路如下：

- 设当前中位数为 m, 最大堆维护的是 ≤ m 的元素，最小堆维护的是 ≥ m 的元素，但两个堆都不包含 m。
- 当新元素到达时，将新元素与 m 进行比较，若新元素 ≤ m， 则将其加入最大堆，否则加入最小堆。
- 第二步后，如果此时最小堆与最大堆的元素个数差值 ≥ 2，则将 m 加入元素个数少的堆中，然后从元素个数多的堆中将根节点移除并幅值给 m 即可。

```java
import java.util.Collection;
import java.util.Collections;
import java.util.PriorityQueue;

public class Midian<E> {
    private PriorityQueue<E> minP;
    private PriorityQueue<E> maxP;
	// 中值
    private E m;
    public Midian(){
        this.minP = new PriorityQueue<>();
        this.maxP = new PriorityQueue<>(11,Collections.<E>reverseOrder());
    }

    private int compare(E e , E m){
        Comparable<? super E>  cmpr = (Comparable<? super E>) e;
        return cmpr.compareTo(m);
    }

    public void add(E e){
		// 第一个元素
        if (m == null){
            m = e;
            return;
        }
		// 小于中值加入最大堆
        if (compare(e , m) <= 0){
            maxP.add(e);
        }else {
            minP.add(e);
        }

        if (minP.size() - maxP.size() >=2){
			// 最小堆元素个数多，将m加入最大堆中，然后最小堆中根移除赋值给m
            maxP.add(this.m);
            this.m = minP.poll();
        }else if (maxP.size() - minP.size() >= 2){
            minP.add(this.m);
            this.m = maxP.poll();
        }
    }

    public void addAll(Collection<? extends E> c){
        for(E e:c){
            add(e);
        }
    }

    public E getM(){
        return m;
    }
}

public static void main(String[] args) {
    Midian<Integer> integerMidian = new Midian<>();
    List<Integer> list = Arrays.asList(new Integer[] {1,2,3,4,5,6,7,8,9,10});
    integerMidian.addAll(list);
    System.out.println(integerMidian.getM());
}
```







## 四、Map与Set

### ※ HashMap

#### 概述

- 键不能重复，重复就会覆盖值。



为了便于理解，以下源码分析以 JDK 1.7 为主。

#### 1. 存储结构

内部包含了一个 **Entry 类型**的数组 table。

```java
transient Entry[] table;
```

Entry 存储着**键值对**。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个**链表**。即数组中的每个位置被当成一个**桶**，一个桶存放一个**链表**。HashMap 使用**拉链法**来解决冲突，同一个链表中存放哈希值相同的 Entry。

![1563604844175](assets/1563604844175.png)

![1567483909960](assets/1567483909960.png)

```java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;

    Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null && k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null && v1.equals(v2)))
                return true;
        }
        return false;
    }

    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + "=" + getValue();
    }
}
```

#### 2. 拉链法的工作原理

```java
HashMap<String, String> map = new HashMap<>();
map.put("K1", "V1");
map.put("K2", "V2");
map.put("K3", "V3");
```

- 新建一个 HashMap，默认大小为 16；
- 插入 &lt;K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的**桶下标** 115%16 = 3。
- 插入 &lt;K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16 = 6。
- 插入 &lt;K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16 = 6，插在 &lt;K2,V2> 前面。

应该注意到链表的插入是以==头插法方式==进行的，例如上面的 &lt;K3,V3> 不是插在 &lt;K2,V2> 后面，而是插入在**链表头部**。

**查找**需要分成两步进行：

- 计算键值对所在的**桶**；
- 在链表上顺序查找，时间复杂度显然和链表的长度成正比。

![1563604859596](assets/1563604859596.png)

#### 3. put 操作

```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 单独处理
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++; 	// 记录结构变化
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
```

HashMap **允许**插入键为 **null** 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用**第0 个桶存放键为 null 的键值对**。

```java
private V putForNullKey(V value) {
    for (Entry<K,V> e = table[0]; e != null; e = e.next) {
        if (e.key == null) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(0, null, value, 0);
    return null;
}
```

使用链表的头插法，也就是新的键值对插在链表的**头部**，而不是链表的尾部。

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    size++;
}
```

```java
Entry(int h, K k, V v, Entry<K,V> n) {
    value = v;
    next = n;
    key = k;
    hash = h;
}
```

#### 4. 确定桶下标

很多操作都需要先确定一个键值对所在的**桶下标**。

```java
int hash = hash(key);
int i = indexFor(hash, table.length);
```

##### 4.1 计算 hash 值

```java
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

```java
public final int hashCode() {
    return Objects.hashCode(key) ^ Objects.hashCode(value);
}
```

##### 4.2 取模 

令 x = 1<<4，即 x 为 2 的 4 次方，它具有以下性质：

```
x   : 00010000
x-1 : 00001111
```

令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：

```
y       : 10110010
x-1     : 00001111
y&(x-1) : 00000010
```

这个性质和 y 对 x 取模效果是一样的：

```
y   : 10110010
x   : 00010000
y%x : 00000010
```

我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用**位运算**的话能带来更高的性能。

确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash % capacity，如果能保证 **capacity 为 2 的 n 次方**，那么就可以将这个操作转换为**位运算**。

```java
static int indexFor(int h, int length) {
    return h & (length - 1);
}
```

#### 5. 扩容-基本原理

设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的**长度**大约为 **N/M**，因此平均查找次数的复杂度为 **O(N/M)**。

为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。

和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。

|    参数    | 含义                                                         |
| :--------: | :----------------------------------------------------------- |
|  capacity  | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 **2 的 n 次方**。 |
|    size    | 键值对数量。                                                 |
| threshold  | size 的**临界值**，当 size 大于等于 threshold 就必须进行扩容操作。 |
| loadFactor | **装载因**子，table 能够使用的比例，threshold = capacity * loadFactor。 |

```java
// 默认初始容量
static final int DEFAULT_INITIAL_CAPACITY = 16;

static final int MAXIMUM_CAPACITY = 1 << 30;
// 默认装载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

transient Entry[] table;

transient int size;

int threshold;

final float loadFactor;

transient int modCount;
```

从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的**两倍**。

```java
void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    if (size++ >= threshold)
        resize(2 * table.length);
}
```

扩容使用 resize() 实现，需要注意的是，**扩容**操作同样需要把 oldTable 的所有键值对**重新插入 newTable** 中，因此这一步是很**费时**的。

```java
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    for (int j = 0; j < src.length; j++) {
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry<K,V> next = e.next;
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
```

#### 6. 扩容-重新计算桶下标

在进行扩容时，需要把键值对**重新**放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。

假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：

```html
capacity     : 00010000
new capacity : 00100000
```

对于一个 **Key**，

- 它的哈希值如果在**第 5 位上为 0**，那么取模得到的结果和之前**一样**；
- 如果为 **1**，那么得到的结果为原来的**结果 +16**。

#### 7. 计算数组容量

HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以**自动地**将传入的容量转换为 2 的 n 次方。

先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：

```
mask |= mask >> 1    11011000
mask |= mask >> 2    11111110
mask |= mask >> 4    11111111
```

mask + 1 是大于原始数字的最小的 2 的 n 次方。

```
num     10010000
mask+1 100000000
```

以下是 HashMap 中计算数组容量的代码，自动转为2 的整数次方：

```java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

#### 8. 链表转红黑树

从 JDK 1.8 开始，一个桶存储的**链表长度大于 8** 时会将链表转换为**红黑树**。

#### 9. 与 HashTable 的比较

- HashTable 使用 **synchronized** 来进行同步。
- HashMap 可以插入键为 null 的 Entry。
- HashMap 的迭代器是 fail-fast 迭代器。
- HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。



#### HashMap相关面试题

**Q：HashMap 的数据结构？**

A：**哈希表结构（链表散列：数组+链表）**实现，结合数组和链表的优点。当链表长度超过 **8** 时，链表转换为**红黑树**。
transient Node<K,V>[] table;

![1567084676248](assets/1567084676248.png)

**Q：HashMap 的工作原理？**

A：HashMap 底层是 **hash 数组**和**单向链表**实现，数组中的每个元素都是**链表**，由 **Node 内部类（实现 Map.Entry<K,V>接口）**实现，HashMap 通过 put & get 方法存储和获取。

**存储对象**时，将 K/V 键值传给 put() 方法：1、调用 hash(K) 方法**计算 K 的 hash 值**，然后结合数组长度，计算得数组下标；2、**调整数组大小**（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；3、①.如果 **K 的 hash 值**在 HashMap 中**不存在**，则执行**插入**，若存在，则发生**碰撞**；
 ②.如果 K 的 hash 值在 HashMap 中**存在**，且它们两者 **equals 返回 true**，则**更新键值对**；
 ③. 如果 K 的 hash 值在 HashMap 中**存在**，且它们两者 **equals 返回 false**，则**插入链表的尾部（尾插法）或者红黑树中（树的添加方式）**。

（**JDK 1.7** 之前使用**头插法**、**JDK 1.8** 使用**尾插法**）
 （注意：当碰撞导致链表大于 TREEIFY_THRESHOLD =  8 时，就把链表转换成红黑树）

**获取对象**时，将 K 传给 get() 方法：①、调用 hash(K) 方法（**计算 K 的 hash 值**）从而**获取该键值所在链表的数组下标**；②、顺序遍历链表，equals()方法查找**相同 Node 链表中 K 值**对应的 V 值。

hashCode 是定位的，**存储位置**；equals是定性的，**比较两者是否相等**。

**Q：当两个对象的 hashCode 相同会发生什么？**

A：因为 hashCode 相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，**"碰撞"**就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。

**Q：你知道 hash 的实现吗？为什么要这样实现？**

A：JDK 1.8 中，是通过 hashCode() 的**高 16 位异或低 16 位**实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度，功效和质量来考虑的，**减少系统的开销**，也不会造成**因为高位没有参与**下标的计算，从而引起的**碰撞**。

**Q：为什么要用异或运算符？**
A：保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。

**Q：HashMap 的 table 的容量如何确定？loadFactor 是什么？ 该容量如何变化？这种变化会带来什么问题？**

A：1、**table 数组大小**是由 **capacity** 这个参数确定的，默认是**16**，也可以构造时传入，最大限制是1<<30；
 2、**loadFactor 是装载因子**，主要目的是用来**确认table 数组是否需要动态扩展**，默认值是**0.75**，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；
 3、扩容时，调用 resize() 方法，将 **table 长度变为原来的两倍**（注意是 **table 长度**，而不是 threshold）
 4、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。

**Q：HashMap 和 HashTable 有什么区别？**

A：1、**HashMap** 是线程不安全的，**HashTable** 是**线程安全**的；
 2、由于线程安全，所以 HashTable 的效率比不上 HashMap；
 3、**HashMap**最多只允许**一条记录的键为null**，允许**多条记录的值为null**，而 **HashTable** 不允许；
 4、**HashMap** 默认初始化数组的大小为**16**，**HashTable** 为 **11**，前者扩容时，扩大**两倍**，后者**扩大两倍+1**；
 5、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode

**Q：Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？**

A：**ConcurrentHashMap** 类（是 Java并发包 java.util.concurrent 中提供的一个**线程安全且高效**的 HashMap 实现）。
 **HashTable** 是使用 **synchronize** 关键字加锁的原理（就是对**对象**加锁）；
 而针对 **ConcurrentHashMap**，在 **JDK 1.7** 中采用 **分段锁**的方式；**JDK 1.8** 中直接采用了**CAS（无锁算法）+ synchronized**。

**Q：HashMap & ConcurrentHashMap 的区别？**

A：除了加锁，原理上无太大区别。

另外，**HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许**。

**Q：为什么 ConcurrentHashMap  比 HashTable 效率要高？**

A：**HashTable** 使用**一把锁（锁住整个链表结构）**处理并发问题，多个线程竞争一把锁，容易**阻塞**；

**ConcurrentHashMap**  
 **JDK 1.7** 中使用**分段锁（ReentrantLock + Segment + HashEntry）**，相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：**基于 Segment**，包含多个 HashEntry。
 **JDK 1.8** 中使用 **CAS + synchronized + Node + 红黑树**。锁粒度：**Node（首结点）**（实现 Map.Entry<K,V>）。锁粒度降低了。

**Q：Java1.7和1.8的HashMap的不同点**

A：1、JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法就是能够提高插入的效率，但是也会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。

2、扩容后数据存储位置的计算方式也不一样：

① 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash 值 & length-1） 。

② 而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置 + 扩容的大小值 = JDK1.8的计算方式，而不再是 JDK1.7 的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。

3、JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（N）变成O（logN）提高了效率）。







### HashSet

#### 概述

- HashSet 的底层通过 **HashMap** 实现的。而 HashMap 在1.7之前使用的是数组 + 链表实现，在1.8 + 使用的数组 + 链表 + 红黑树实现。其实也可以这样理解，HashSet 的底层实现和 HashMap 使用的是相同的方式，因为 Map 是无序的，因此 HashSet 也**无法保证顺序**。
- Set **没有重复元素**。相同的元素添加进去也只会保留一份。
- HashSet 的方法，也是借助 HashMap 的方法来实现的。
- 可以高效的添加、删除元素、判断元素是否存在，效率都为O(1)。

#### 源码解析

```java
public class HashSet<E> extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {

    static final long serialVersionUID = -5024744406713321676L; // 序列化版本号

    private transient HashMap<E,Object> map;  // HashMap变量，用于存放HashSet的值

    private static final Object PRESENT = new Object(); // map中的值

    // 构造方法
    public HashSet() {
        map = new HashMap<>();
    }

    // 构造方法，将指定的集合转化为HashSet
    public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }

    // 构造方法，指定初始化的大小和负载因子
    public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap<>(initialCapacity, loadFactor);
    }
    // 指定初始化大小
    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }

    // 构造方法，采用default修饰，只能是同一个包下的成员访问。包不相同无法访问
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }

    // HashSet的遍历操作
    // 通过这个方法可以发现，HashSet调用了HashMap存放，因为HashSet并不是键值对存储，所以它只是把它的值做了Map中的键，在遍历HashSet的集合元素时，实际上是遍历的Map中Key的集合。
    public Iterator<E> iterator() {
        return map.keySet().iterator();
    }

    // 返回集合中元素的容量
    public int size() {
        return map.size();
    }

    // 判断是否为空
    public boolean isEmpty() {
        return map.isEmpty();
    }

    // 是否包含指定的元素
    public boolean contains(Object o) {
        return map.containsKey(o);
    }

    // 添加元素，添加的元素作为了Map中的key,value使用了一个常量表示
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

    // 删除元素
    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }

    // 清空集合
    public void clear() {
        map.clear();
    }

    // 克隆方法
    public Object clone() {
        try {
            HashSet<E> newSet = (HashSet<E>) super.clone();
            newSet.map = (HashMap<E, Object>) map.clone();
            return newSet;
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }
    }

    // 写入输出流操作
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out any hidden serialization magic
        s.defaultWriteObject();

        // Write out HashMap capacity and load factor
        s.writeInt(map.capacity());
        s.writeFloat(map.loadFactor());

        // Write out size
        s.writeInt(map.size());

        // Write out all elements in the proper order.
        for (E e : map.keySet())
            s.writeObject(e);
    }

    // 从输入流中读取对象
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in any hidden serialization magic
        s.defaultReadObject();

        // Read in HashMap capacity and load factor and create backing HashMap
        int capacity = s.readInt();
        float loadFactor = s.readFloat();
        map = (((HashSet)this) instanceof LinkedHashSet ?
               new LinkedHashMap<E,Object>(capacity, loadFactor) :
               new HashMap<E,Object>(capacity, loadFactor));

        // Read in size
        int size = s.readInt();

        // Read in all elements in the proper order.
        for (int i=0; i<size; i++) {
            E e = (E) s.readObject();
            map.put(e, PRESENT);
        }
    }
}
```



### TreeMap

#### 概述

- TreeMap 是一个**有序的key-value集合**，它是通过红黑树实现的。
- TreeMap 是按照键而不是值有序，都是对**键**进行比较。
- 



#### 基本使用

##### 构造方法

- `TreeMap()`：创建一个空 TreeMap，keys按照**自然排序**。要求 Map 中的键实现 Comparable 接口。

    ```java
    TreeMap<Integer, String> treeMap = new TreeMap<>();
    ```

- `TreeMap(Comparator comparator)`：创建一个空TreeMap，按照指定的 **comparator** 排序。即创建自定义的比较器。

    ```java
    TreeMap<Integer, String> map = new TreeMap<>(Comparator.reverseOrder());
    map.put(3, "val");
    map.put(2, "val");
    map.put(1, "val");
    map.put(5, "val");
    map.put(4, "val");
    System.out.println(map); // {5 = val, 4 = val, 3 = val, 2 = val, 1 = val} 逆序
    ```

    ```java
    // String.CASE_INSENSITIVE_ORDER是String类中的一个忽略大小写的Comparator
    Map<String, String> map = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    // 逆序并忽略大小写
    Map<String, String> map = new TreeMap<>(Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));
    ```

- `TreeMap(Map m)`：由给定的 map 创建一个 TreeMap，keys 按照自然排序。

    ```java
    Map<Integer, String> map = new HashMap<>();
    map.put(1, "val");
    ...
    TreeMap<Integer, String> treeMap = new TreeMap<>(map);
    ```

- `TreeMap(SortedMap m)`：由给定的有序 map 创建 TreeMap，keys 按照原顺序排序。



##### 其他方法

**增添元素**

- `V put(K key, V value)`：将指定映射放入该TreeMap中
- `V putAll(Map map)`：将指定map放入该TreeMap中

**删除元素**

- `void clear()`：清空TreeMap中的所有元素
- `V remove(Object key)`：从TreeMap中移除指定key对应的映射

**修改元素**

- `V replace(K key, V value)`：替换指定key对应的value值
- `boolean replace(K key, V oldValue, V newValue)`：当指定key的对应的value为指定值时，替换该值为新值

**查找元素**

- `boolean containsKey(Object key)`：判断该TreeMap中是否包含指定key的映射
- `boolean containsValue(Object value)`：判断该TreeMap中是否包含有关指定value的映射
- `Map.Entry<K, V> firstEntry()`：返回该TreeMap的第一个（最小的）映射
- `K firstKey()`：返回该TreeMap的第一个（最小的）映射的key
- `Map.Entry<K, V> lastEntry()`：返回该TreeMap的最后一个（最大的）映射
- `K lastKey()`：返回该TreeMap的最后一个（最大的）映射的key
- `v get(K key)`：返回指定key对应的value
- `SortedMap<K, V> headMap(K toKey)`：返回该TreeMap中严格小于指定key的映射集合
- `SortedMap<K, V> subMap(K fromKey, K toKey)`：返回该TreeMap中指定范围的映射集合（大于等于fromKey，小于toKey）

**遍历接口**

- `Set<Map<K, V>> entrySet()`：返回由该TreeMap中的所有映射组成的Set对象
- `void forEach(BiConsumer<? super K,? super V> action)`：对该TreeMap中的每一个映射执行指定操作
- `Collection<V> values()`：返回由该TreeMap中所有的values构成的集合

**其他方法**

- `Object clone()`：返回TreeMap实例的浅拷贝
- `Comparator<? super K> comparator()`：返回给该TreeMap的keys排序的comparator，若为自然排序则返回null
- `int size()`：返回该TreepMap中包含的映射的数量

```java
TreeMap<Integer, String> treeMap = new TreeMap<>();
treeMap.put(1, "a");
treeMap.put(2, "b");
treeMap.put(3, "c");
treeMap.put(4, "d"); 	// treeMap: {1 = a, 2 = b, 3 = c, 4 = d}

treeMap.remove(4); // treeMap: {1 = a, 2 = b, 3 = c}
int sizeOfTreeMap = treeMap.size(); // sizeOfTreeMap: 3

treeMap.replace(2, "e"); // treeMap: {1 = a, 2 = e, 3 = c}

Map.Entry entry = treeMap.firstEntry(); // entry: 1 -> a
Integer key = treeMap.firstKey(); // key: 1
entry = treeMap.lastEntry(); // entry: 3 -> c
key = treeMap.lastKey(); // key: 3
String value = treeMap.get(3); // value: c
SortedMap sortedMap = treeMap.headMap(2); // sortedMap: {1 = a}
sortedMap = treeMap.subMap(1, 3); // sortedMap: {1 = a, 2 = e}

Set setOfEntry = treeMap.entrySet(); // setOfEntry: [1 = a, 2 = e, 3 = c]
Collection<String> values = treeMap.values(); // values: [a, e, c]
treeMap.forEach((integer, s) -> System.out.println(integer + "->" + s)); 
// output：
// 1 -> a
// 2 -> e
// 3 -> c
```

##### 遍历方式

- for循环

    ```java
    for (Map.Entry entry : treeMap.entrySet()) {
          System.out.println(entry);
    }
    ```

- 迭代器循环

    ```java
    Iterator iterator = treeMap.entrySet().iterator();
    while (iterator.hasNext()) {
          System.out.println(iterator.next());
    }
    ```



#### 源码解析

TreeMap 的基本数据结构 Entry 的部分源码：

```java
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key;
    V value;
    Entry<K,V> left;
    Entry<K,V> right;
    Entry<K,V> parent;
    boolean color = BLACK;
    // ......
}
```

可以看出，Entry 中除了基本的 key、value  之外，还有左节点、右节点以及父节点，另外还有颜色黑色为 true，红色为 false。

具体看看这个：

[红黑树实现TreeMap原理解析](https://www.cnblogs.com/Joe-Go/p/10497115.html)





### TreeSet

- TreeSet 是 Set 的一个子类，TreeSet 集合是用来对象元素进行排序的，没有重复元素。实现了**排重与有序**。
- 需要传入一个 Comparator 比较器对象进行排序，或者添加的元素实现了 Comparable 接口。
- 内部基于 TreeMap 实现。
- 













### ※ LinkedHashMap

#### 概述

- LinkedHashMap 是 HashMap 的子类，但可以保持元素按插入或访问有序，与 TreeMap 按键排序不同。
- HashMap 是线程不安全的，LinkedHashMap 同样是线程**不安全**的。





#### 基本使用

HashMap是无序的，当我们希望有顺序地去存储key-value时，就需要使用LinkedHashMap

```java
// 使用HashMap
Map<String, String> hashMap = new HashMap<String, String>();
hashMap.put("name1", "josan1");
hashMap.put("name2", "josan2");
hashMap.put("name3", "josan3");
Set<Entry<String, String>> set = hashMap.entrySet();
Iterator<Entry<String, String>> iterator = set.iterator();
while(iterator.hasNext()) {
    Entry entry = iterator.next();
    String key = (String) entry.getKey();
    String value = (String) entry.getValue();
    System.out.println("key:" + key + ",value:" + value);
}
// key:name3,value:josan3
// key:name1,value:josan1
// key:name2,value:josan2

// 使用LinkedHashMap
Map<String, String> linkedHashMap = new LinkedHashMap<>();
linkedHashMap.put("name1", "josan1");
linkedHashMap.put("name2", "josan2");
linkedHashMap.put("name3", "josan3");
Set<Entry<String, String>> set = linkedHashMap.entrySet();
Iterator<Entry<String, String>> iterator = set.iterator();
while(iterator.hasNext()) {
    Entry entry = iterator.next();
    String key = (String) entry.getKey();
    String value = (String) entry.getValue();
    System.out.println("key:" + key + ",value:" + value);
}
// key:name1,value:josan1
// key:name2,value:josan2
// key:name3,value:josan3
```

结果可知，LinkedHashMap是有序的，且默认为**插入顺序**。

跟HashMap一样，它也是提供了 key-value 的存储方式，并提供了 put 和 get 方法来进行数据存取。



#### 源码分析

LinkedHashMap 结构如下图。

![1567478530282](assets/1567478530282.png)

继承自 HashMap，因此具有和 HashMap 一样的**快速查找**特性。

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>
```

**构造方法**

有多个构造方法，无参的如下

```java
public LinkedHashMap() {
    // 调用HashMap的构造方法，其实就是初始化Entry[] table
    super();
    // 这里是指是否基于访问排序，默认为false
    accessOrder = false;
}    public LinkedHashMap() {
    // 调用HashMap的构造方法，其实就是初始化Entry[] table
    super();
    // 这里是指是否基于访问排序，默认为false
    accessOrder = false;
}
```

首先使用 super 调用了父类 HashMap 的构造方法，其实就是根据初始容量、负载因子去初始化Entry[] table。

然后把 accessOrder 设置为 false，这就跟存储的顺序有关了，LinkedHashMap 存储数据是有序的，而且分为两种：**插入顺序和访问顺序。**

这里 accessOrder 设置为 false，表示不是访问顺序而是插入顺序存储的，这也是默认值，表示 LinkedHashMap中存储的顺序是按照调用 put 方法插入的顺序进行排序的。

LinkedHashMap 也提供了可以设置 accessOrder 的构造方法，如下设置是按照访问顺序进行存储，此时非常适合用于 LRU 缓存。

```java
// 第三个参数用于指定accessOrder值
Map<String, String> linkedHashMap = new LinkedHashMap<>(16, 0.75f, true);
linkedHashMap.put("name1", "josan1");
linkedHashMap.put("name2", "josan2");
linkedHashMap.put("name3", "josan3");
System.out.println("开始时顺序：");
Set<Entry<String, String>> set = linkedHashMap.entrySet();
Iterator<Entry<String, String>> iterator = set.iterator();
while(iterator.hasNext()) {
    Entry entry = iterator.next();
    String key = (String) entry.getKey();
    String value = (String) entry.getValue();
    System.out.println("key:" + key + ",value:" + value);
}
System.out.println("通过get方法，导致key为name1对应的Entry到表尾");
linkedHashMap.get("name1");
Set<Entry<String, String>> set2 = linkedHashMap.entrySet();
Iterator<Entry<String, String>> iterator2 = set2.iterator();
while(iterator2.hasNext()) {
    Entry entry = iterator2.next();
    String key = (String) entry.getKey();
    String value = (String) entry.getValue();
    System.out.println("key:" + key + ",value:" + value);
}
// 开始时顺序：
// key:name1,value:josan1
// key:name2,value:josan2
// key:name3,value:josan3
// 通过get方法，导致key为name1对应的Entry到表尾
// key:name2,value:josan2
// key:name3,value:josan3
// key:name1,value:josan1
```

因为调用了get("name1")导致了 name1 对应的 Entry 移动到了 Map 最后。

**初始化**

在 HashMap 的构造函数中，调用了 init 方法，而在 HashMap 中 init 方法是空实现，但 LinkedHashMap 重写了该方法，所以在 LinkedHashMap 的构造方法里，调用了自身的 init 方法，init 的重写实现如下：

```java
/**
 * Called by superclass constructors and pseudoconstructors (clone,
 * readObject) before any entries are inserted into the map.  Initializes
 * the chain.
 */
@Override
void init() {
    // 创建了一个hash = -1，key、value、next都为null的Entry
    header = new Entry<>(-1, null, null, null);
    // 让创建的Entry的before和after都指向自身，注意after不是之前提到的next
    // 其实就是创建了一个只有头部节点的双向链表
    header.before = header.after = header;
}
```

**存储结构**

HashMap 中静态内部类 Entry 是这样定义的。

```java
static class Entry<K,V> implements Map.Entry<K,V> {
    final K key;
    V value;
    Entry<K,V> next;
    int hash;
}    
```

LinkedHashMap有自己的静态内部类 Entry，它**继承**了HashMap.Entry，定义如下:

```java
/**
 * LinkedHashMap entry.
 */
private static class Entry<K,V> extends HashMap.Entry<K,V> {
    // These fields comprise the doubly linked list used for iteration.
    Entry<K,V> before, after;

    Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {
        super(hash, key, value, next);
	}
}    
```

所以 LinkedHashMap 构造函数，主要就是调用 HashMap 构造函数初始化了一个 Entry[] table，然后调用自身的init 初始化了一个**只有头结点的双向链表**。用来维护插入顺序或者 **LRU** 顺序。参数**accessOrder** 用于指定是否按**访问顺序**，默认为 false，此时维护的是**插入顺序**。如果为 true，就是访问顺序。

```java
/**
 * The head (eldest) of the doubly linked list.
 */
transient LinkedHashMap.Entry<K,V> head;

/**
 * The tail (youngest) of the doubly linked list.
 */
transient LinkedHashMap.Entry<K,V> tail;

final boolean accessOrder;
```

完成了如下操作。

![1567483723793](assets/1567483723793.png)

**put 方法**

LinkedHashMap 如下（Java 9）：

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

```java
/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            // 重点
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        // 扩容
        resize();
    // 重点
    afterNodeInsertion(evict);
    return null;
}
```

当 put 元素时，不但要把它加入到 **HashMap** 中去，还要加入到**双向链表**中，所以可以看出LinkedHashMap就是 **HashMap + 双向链表** ，下面用图来表示逐步往 LinkedHashMap 中添加数据的过程，红色部分是双向链表，黑色部分是 HashMap 结构，header 是一个 Entry 类型的双向链表表头，本身不存储数据。

加入一个元素Entry1， 假设 index 为0，如下图。

![1567480305247](assets/1567480305247.png)

加入 Entry2，假设 index 为15，如下：

![1567480481449](assets/1567480481449.png)

再添加一个 Entry3，假设其 index 为 0，如下图。

![1567480711374](assets/1567480711374.png)

以上，就是LinkedHashMap 的 put 的所有过程了，总体来看，跟 HashMap 的 put 类似，只不过多了把新增的Entry 加入到双向列表中。

**扩容**

在 HashMap 的 put 方法中，如果发现前元素个数超过了扩容阀值时，会调用 resize 方法。LinkedHashMap重写了 transfer 方法，数据的迁移。可以看出，LinkedHashMap 扩容时，数据的再散列和 HashMap 是不一样的。

HashMap 是先遍历旧 table，再遍历旧 table 中每个元素的单向链表，取得 Entry 以后，重新计算 hash 值，然后存放到新 table 的对应位置。

LinkedHashMap是遍历的双向链表，取得每一个 Entry，然后重新计算 hash 值，然后存放到新 table 的对应位置。

从遍历的效率来说，遍历双向链表的效率要高于遍历 table，因为遍历双向链表是 N 次（N为元素个数）；而遍历table 是 N + table 的空余个数（N为元素个数）。

**get 方法**

代码如下（Java 9）

```java
public V get(Object key) {
    Node<K,V> e;
    if ((e = getNode(hash(key), key)) == null)
        return null;
    // 如果是true就是访问顺序，就会把最近访问的数据放到末尾
    if (accessOrder)
        // 顺序调整
        afterNodeAccess(e);
    return e.value;
}
```

**顺序维护**

LinkedHashMap 最重要的是以下用于**维护顺序的函数**，它们会在 **put、get** 等方法中调用。

```java
void afterNodeAccess(Node<K,V> p) { }
void afterNodeInsertion(boolean evict) { }
```

**afterNodeAccess**()

当一个节点被**访问**时，如果 accessOrder 为 true （即访问顺序），则会将该节点移到**链表尾部**。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证**链表尾部是最近访问**的节点，那么**链表首部**就是**最近最久未使用**的节点。

```java
void afterNodeAccess(Node<K,V> e) { // move node to last
    LinkedHashMap.Entry<K,V> last;
    if (accessOrder && (last = tail) != e) {
        LinkedHashMap.Entry<K,V> p =
            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
```

**afterNodeInsertion**()

在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会**移除最晚**的节点，也就是链表**首部**节点 first。

evict 只有在构建 Map 的时候才为 false，在这里为 true。

```java
void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry<K,V> first;
    if (evict && (first = head) != null && removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}
```

removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 **LRU 的缓存**中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。

```java
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return false;
}
```

#### HashMap 与 LinkedHashMap 对比

- 看看HashMap和LinkedHashMap的结构图，LinkedHashMap 其实就是可以看成 HashMap 的基础上，多了一个**双向链表**来维持顺序。

![1567483958427](assets/1567483958427.png)



![1567483989341](assets/1567483989341.png)

- LinkedHashMap 是继承于 HashMap，是基于 HashMap 和双向链表来实现的。
- HashMap 无序；LinkedHashMap 有序，可分为插入顺序和访问顺序两种。如果是访问顺序，那 put 和 get操作已存在的 Entry 时，都会把 Entry 移动到双向链表的表尾(其实是先删除再插入)。
- LinkedHashMap 存取数据，还是跟 HashMap 一样使用的 Entry[] 的方式，双向链表只是为了保证顺序。
- LinkedHashMap 是线程不安全的。
- LinkedHashMap 及其节点类 LinkedHashMap.Entry 重写了部分方法来实现了对顺序的控制。



#### LRU 缓存应用

以下是使用 LinkedHashMap 实现的一个 LRU 缓存：

- 设定**最大缓存**空间 MAX_ENTRIES  为 3；
- 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 **true**，开启 LRU 顺序；
- **覆盖** removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    // 覆写
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
```

```java
public static void main(String[] args) {
    LRUCache<Integer, String> cache = new LRUCache<>();
    cache.put(1, "a");
    cache.put(2, "b");
    cache.put(3, "c");
    cache.get(1);
    cache.put(4, "d");
    System.out.println(cache.keySet());
}
```

```html
[3, 1, 4]
```





### WeakHashMap

#### 存储结构

WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会**被回收**。

WeakHashMap 主要用来**实现缓存**，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分**缓存进行回收**。

```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V>
```

#### ConcurrentCache

Tomcat 中的 **ConcurrentCache** 使用了 WeakHashMap 来实现**缓存**功能。

ConcurrentCache 采取的是**分代缓存**：

- 经常使用的对象放入 **eden** 中，eden 使用 **ConcurrentHashMap** 实现，不用担心会被回收（伊甸园）；
- 不常用的对象放入 **longterm**，longterm 使用 **WeakHashMap** 实现，这些老对象会被垃圾收集器回收。
- 当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象**放入 eden** 中，从而保证经常被访问的节点不容易被回收。
- 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象**都放入** longterm 中，利用虚拟机回收掉一部分不经常使用的对象。

```java
public final class ConcurrentCache<K, V> {

    private final int size;
    // 伊甸区
    private final Map<K, V> eden;

    private final Map<K, V> longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap<>(size);
        this.longterm = new WeakHashMap<>(size);
    }

    public V get(K k) {
        V v = this.eden.get(k);
        if (v == null) {
            v = this.longterm.get(k);
            if (v != null)
                this.eden.put(k, v);
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() >= size) {
            this.longterm.putAll(this.eden);
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}
```























### 参考资料

- [Java Collection Framework](https://www.w3resource.com/java-tutorial/java-collections.php)
- [Iterator 模式](https://openhome.cc/Gossip/DesignPattern/IteratorPattern.htm)
- [Java 8 系列之重新认识 HashMap（好！！！！）](https://tech.meituan.com/java_hashmap.html)
- [What is difference between HashMap and Hashtable in Java?](http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html)
- [Java 集合之 HashMap](http://www.zhangchangle.com/2018/02/07/Java%E9%9B%86%E5%90%88%E4%B9%8BHashMap/)
- [The principle of ConcurrentHashMap analysis](http://www.programering.com/a/MDO3QDNwATM.html)
- [探索 ConcurrentHashMap 高并发性的实现机制](https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/)
- [HashMap 相关面试题及其解答（好！！！！！！）](https://www.jianshu.com/p/75adf47958a7)
- [Java 集合细节（二）：asList 的缺陷](http://wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html)

    







