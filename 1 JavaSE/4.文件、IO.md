[TOC]

## 一、文件与磁盘操作

### 概述

#### 杂记

- 文件均以二进制形式保存。
- 文件类型通常以拓展名形式体现，每种文件类型都有一种格式，代表文件含义与二进制之间的映射规则。
- 文件粗略分为文本文件与二进制文件。
- UTF-8编码的文件开头加入三个特殊字节：0XEF 0XBB 0XBF，称为 BOM 头。
- 文件读写：硬盘的访问相对内存慢得多。
- 一般读写文件需要两次数据复制，比如读文件，需要先从硬盘中复制到操作系统的内核，再从内核复制到应用程序分配的内存中。操作系统所在的环境是内核态，用户程序所在环境为用户态，切换会有较大的开销。
- 为了提升文件操作效率，一种方法是使用缓冲区，读文件时，可以预先多更多文件到缓冲区，写文件时先写到缓冲区，满了之后一次写到硬盘，但是写结束的时候记得把缓冲区内容同步到硬盘中。
- 操作系统一般支持成为**内存映射文件**的高效随机读写大文件的方法，将文件映射到内存，操作内存就是操作文件。



#### IO分类

Java 的 I/O 大概可以分成以下几类：

- 磁盘操作：File
- 字节操作：InputStream 和 OutputStream
- 字符操作：Reader 和 Writer
- 对象操作：**Serializable**
- 网络操作：**Socket**
- 新的输入/输出：**NIO**



### File 类

Java 中使用 File 来抽象一个文件，无论是**普通文件或是目录**，都可对应于一个 File 对象。对于 File 这个类型的定位一定要准确：它只是抽象的代表了磁盘上的某个文件或目录，内部实际上是依赖一个平台无关的**本地文件系统类**，并且 File **无法**对其所表示文件内容进行**任何读写操作**（那是流做的事情）。

**File 类**可以用于表示文件和目录的信息，但是它不表示文件的内容。

##### 基本用法

在实际介绍 File 实例构造方法之前，先看看它的几种重要的属性成员。

```java
private static final FileSystem fs = DefaultFileSystem.getFileSystem();
```

这是 File 类中最核心的成员，它表示为当前系统的**文件系统 API**，所有向磁盘发出的操作都是基于这个属性的。

```java
private final String path;
```

path 代表了当前实例的**完整路径名称**，如果当前的 File 实例表示的是目录的话，那么 path 的值就是这个完整的目录名称，如果表示的是纯文件的话，那么这个 path 的值等于该文件的完整路径 + 文件名称。

```java
public static final char separatorChar = fs.getSeparator();
public static final char pathSeparatorChar = fs.getPathSeparator();
```

separatorChar 表示的是目录间的**分隔符**，pathSeparatorChar 表示的是不同路径下的分隔符，这两个值在不同的系统平台下不尽相同。例如 Windows 下这两者的值分别为：「」 和 「;」，其中封号用于分隔多个不同路径。

**构造方法**

File 类提供了四种不同的构造器用于实例化一个 File 对象，但较为常用的只有三个

```java
public File(String pathname)
```

这是最普遍的实例化一个 File 对象的方法，pathname 的值可以是一个**目录**，也可以是一个**纯文件**的名称。例如：

```java
File file = new File("C:\\Users\\yanga\\Desktop");
File file1 = new File("C:\\Users\\yanga\\Desktop\\a.txt");
File file2 = new File("a.txt");
```

当然也可以显式指定一个**父路径**：

```java
public File(String parent, String child)
```

在构造器的内部，程序会为我们**拼接**出一个完整的文件路径，例如：

```java
File file = new File("C:\\Users\\yanga\\Desktop","a.txt");

File file1 = new File("C:\\Users\\yanga\\Desktop","java");
```

第三种构造器其实本质上和第二种是一样的，只不过增加了一个父类 File 实例的封装过程：

```java
public File(File parent, String child)
```

类似的情况，不再举例说明了。我们这里并没有深究这些构造器的内部具体实现情况，并不是说它简单，而是 **File 过度依赖本地文件系统**，很多方法的实现情况都不得直接看到，所以对于 File 的学习，定位为熟练掌握即可，具体实现暂时没法深入学习。

##### 文件名称或路径相关信息获取

**getName** 方法可以用于获取文件名称：

```java
public String getName() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) return path.substring(prefixLength);
    return path.substring(index + 1);
}
```

还记得我们的 separatorChar 表示的是什么了吗？

它表示为路径分隔符，Windows 中为符号「」，path 属性存储的当前 File 实例的完整路径名称，所以最后一次出现的位置后面所有的字符必然是我们的文件名称。

当然你一定发现了，对于纯文件来说，该方法能够返回文件的**简单名称**，而对于一个目录而言，返回值将会是最近的**目录名**。例如：

```java
File file = new File("C:\\Users\\yanga\\Desktop\\a.txt");
System.out.println(file.getName());		// a.txt

File file1 = new File("C:\\Users\\yanga\\Desktop");
System.out.println(file1.getName());	// Desktop
```

**getParent** 方法用于返回当前文件的**父级目录**，无论你是纯文件或是目录，你终有你的父目录（当然，虚拟机生成的临时文件自然不是）。

```java
public String getParent() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) {
        if ((prefixLength > 0) && (path.length() > prefixLength))
            return path.substring(0, prefixLength);
        return null;
    }
    return path.substring(0, index);
}
```

**getPath** 方法可以返回当前 File 实例的**完整文件名称**：

```java
public String getPath() {
    return path;
}
```

以下是一些有关目录的相关操作，实现比较简单，此处简单罗列了：

- public boolean **isAbsolute**()：是否为绝对路径
- public String **getAbsolutePath**()：获取当前 File 实例的绝对路径
- public String **getCanonicalPath**()：返回当前 File 实例的标准路径

这里我们需要对 getCanonicalPath 做一点解释，什么叫标准路径，和绝对路径有区别吗？

一般而言，「../」表示源文件所在目录的上一级目录，「../../」表示源文件所在目录的上上级目录，并以此类推。getAbsolutePath 方法不会做这种转换的操作，而 getCanonicalPath 方法则会将这些特殊字符进行识别并取合适的语义。

例如：

```java
File file = new File("..\\a.txt");
System.out.println(file.getAbsolutePath());
System.out.println(file.getCanonicalPath());
```

输出结果：

```java
C:\Users\yanga\Desktop\Java\workspace2017\TestFile\..\a.txt
C:\Users\yanga\Desktop\Java\workspace2017\a.txt
```

前者会将「..\a.txt」作为文件路径名称的一部分，而后者却能够识别「..\a.txt」表示的是「a.txt」位于当前目录的上级目录中。这就是两者最大的不同之处，适合不同的情境。

##### 文件的属性信息获取

这部分的文件操作其实很简单，无非是一些**文件权限**的问题，是否可读，是否可写，是否为隐藏文件等。常用方法：

|               方法               |                      释义                      |
| :------------------------------: | :--------------------------------------------: |
|   public boolean **canRead**()   |      该抽象的 File 实例对应的文件是否可读      |
|  public boolean **canWrite**()   |    该抽象的 File **实例对应的文件是否可写**    |
|   public boolean **exists**()    |    该抽象的 File 实例对应的文件是否实际存在    |
| public boolean **isDirectory**() |   该抽象的 File 实例对应的文件是否是一个目录   |
|   public boolean **isFile**()    |  该抽象的 File 实例对应的文件是否是一个纯文件  |
|  public boolean **isHidden**()   | 该抽象的 File 实例对应的文件是否是一个隐藏文件 |
|     public long **length**()     |     文件内容所占的字节数（对目录没有意义）     |



##### 文件的操作

文件的操作无外乎「**增删改查**」，下面我们一起来看看。

- public boolean **createNewFile()**：根据抽象的 File 对象创建一个实际存在的磁盘文件
- public boolean **delete()**：删除该 File 对象对应的磁盘文件，删除失败会返回 false

当然，处理上述两个简单的新建和删除操作，File 类还提供了所谓「**查询**」操作，这个我们要好好学习一下。例如：

```java
public String[] list() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(path);
    }
    if (isInvalid()) {
        return null;
    }
    return fs.list(this);
}
```

这个方法会检索出当前实例所代表的目录下所有的「纯文件」和「目录」简单名称集合。例如：

```java
/**
* 检索打印文件目录
*/
File file = new File("C:\\Users\\yanga\\Desktop");
String[] list = file.list();
for (String str : list){
    System.out.println(str);
}
```

需要注意一点，如果我们的 File 实例对应的不是一个目录，而是一个纯文件，那么 list 将返回 **null**。

接着，我们再看一个检索目录文件的方法：

```java
/**
 * 检索打印文件目录 可以根据filter条件进行过滤
 */
public String[] list(FilenameFilter filter) {
    String names[] = list();
    if ((names == null) || (filter == null)) {
        return names;
    }
    List<String> v = new ArrayList<>();
    for (int i = 0 ; i < names.length ; i++) {
        if (filter.accept(this, names[i])) {
            v.add(names[i]);
        }
    }
    return v.toArray(new String[v.size()]);
}
```

这个方法其实是 list 的重载版本，它允许传入一个过滤器用于检索目录时只筛选我们需要的文件及目录。

而这个 FilenameFilter 接口的定义却是如此简单：

```java
public interface FilenameFilter {
    boolean accept(File dir, String name);
}
```

只需要重写这个 accept 方法即可，list 的 for 循环每获取一个文件或目录就会尝试着先调用这个**过滤方法**，如果通过筛选，才会将当前文件的简单名称添加进返回集合中。

```java
File file = new File("C:\\Users\\yanga\\Desktop\\test");
String[] list = file.list(
    new FilenameFilter() {
        @Override
        public boolean accept(File dir, String name) {
            // dir 代表的当前 File 对象
            // name 是当前遍历的文件项的简单名称
            if (!name.endsWith(".txt"))
                return false;
            else
                return true;
        }
    }
);
for (String str : list){
    System.out.println(str);
}
```

使用匿名内部类创建一个 FilenameFilter 的子类实例，然后实现了它的 accept 方法，具体的实现很简单，过滤掉所有的目录并取出所有纯文件 TXT 的简单名称。

所以，list 方法并**不会遍历出目标目录下的所有文件**，即目标目录的子目录中的文件并不会被访问遍历。

**列出文件内容**

**递归**地列出一个目录下所有文件： 

```java
public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
```

从 Java7 开始，可以使用 ==Paths 和 Files== 代替 File。

接下来的两个方法和文件夹的创建有关：

- public boolean mkdir()
- public boolean mkdirs()

两者都是依据的当前 File 实例**创建文件夹**，关于它们的不同点，我们先看一段代码：

```java
File file = new File("C:\\Users\\yanga\\Desktop\\test2");
System.out.println(file.mkdir());

File file2 = new File("C:\\Users\\yanga\\Desktop\\test3\\hello");
System.out.println(file2.mkdir());
```

其中，test2 和 test3 在程序执行之前都不存在。

输出结果如下：

```java
true
false
```

后者创建失败了。这源于 mkdir 方法一次只能**创建一个文件夹**，倘若给定的目录的父级或更上层目录存在未被创建的目录，那么将导致创建失败。

而 mkdirs 方法就是用于解决这种情境的，它会**创建目标路径上所有未创建的目录**，看代码：

```java
File file3 = new File("C:\\Users\\yanga\\Desktop\\test3\\hello\\231");
System.out.println(file3.mkdirs());
```

即便我们 test3 文件夹就不存在，程序运行之后，test3、hello、231 这三个文件夹都会被创建出来。









## 二、字节操作

抽象化磁盘文件的 File 类型，它仅仅用于抽象化描述一个磁盘文件或目录，却**不具备**访问和修改一个文件**内容**的能力。Java 的 **IO 流**就是用于**读写文件内容**的一种设计，它能完成将磁盘文件内容输出到**内存**或者是将内存数据输出到磁盘文件的数据传输工作。

流操作类大致分为两大类，一类是针对二进制文件的**字节流**，另一类是针对文本文件的**字符流**。



### 基类字节流 InputStream/OutputStream

InputStream 和 OutputStream 分别作为读字节流和写字节流的==基类==，所有字节相关的流都必然继承自他们中任意一个，而它们本身作为一个**抽象类**，也定义了最基本的读写操作。

以 InputStream 为例：

```java
public abstract int read() throws IOException;
```

这是一个**抽象**的方法，并没有提供默认实现，要求子类必须实现。**而这个方法的作用就是为你返回当前文件的下一个字节**。

当然，你也会发现这个方法的返回值是使用的整型类型==「**int**」==来接收的，为什么不用「byte」？

首先，read 方法返回的值一定是一个八位的**二进制**，而一个八位的二进制可以取值的值区间为：**「0000 0000，1111 1111」**，也就是范围 [-128,127]。

read 方法同时又规定当读取到文件的末尾，即文件没有下一个字节供读取了，将返回值 ==**-1**== 。所以如果使用 byte 作为返回值类型，那么当方法返回一个 -1 ，我们该判定这是文件中数据内容，还是流的末尾呢？

而 int 类型占四个字节，高位的三个字节全部为 0，我们只使用它的最低位字节，当遇到流结尾标志时，返回四个字节表示的 -1（32 个 1），这就自然的和表示数据的值 -1（24 个 0 + 8 个 1）区别开来了。

接下来也是一个 read 方法，但是 InputStream 提供默认实现：

```java
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}

public int read(byte b[], int off, int len) throws IOException{
    // 方法体可查看 jdk 源码
}
```

这两个方法本质上是一样的，第一个方法是第二个方法的特殊形态，它允许传入一个**字节数组**，并要求程序将文件中读到的字节从数组索引位置 0 开始填充，供填充数组长度个字节数。

而第二个方法更加宽泛一点，它允许你指定起始位置和字节总数。

InputStream 中还有其他几个方法，基本都没怎么具体实现，留待子类实现，如下：

- public long **skip**(long n)：跳过 n 个字节，返回实际跳过的字节数
- public void **close**()：关闭流并释放对应的资源
- public synchronized void **mark**(int readlimit)
- public synchronized void **reset**()
- public boolean **markSupported**()

mark 方法会在当前流读取位置打上一个标志，reset 方法即重置读取指针到该标志处。

事实上，文件读取是**不可能重置回头读取**的，而一般都是将标志位置到重置点之间所有的字节临时保存了，当调用 reset 方法时，其实是从保存的临时字节集合进行重复读取，所以 readlimit 用于限制最大缓存容量。

而 markSupported 方法则用于确定当前流是否支持这种「回退式」读取操作。

OutputStream 和 InputStream 是类似的，只不过一个是写一个是读，不再赘述。

**实现文件复制**

```java
public static void copyFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
```



### 文件字节流 FileInput/OutputStream

依然着重点于 FileInputStream，而 FileOutputStream 是类似的。

首先 FileInputStream 有以下几种构造器实例化一个对象：

```java
public FileInputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null);
}
public FileInputStream(File file) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(name);
    }
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException("Invalid file path");
    }
    fd = new FileDescriptor();
    fd.attach(this);
    path = name;
    open(name);
}
```

这两个构造器本质上也是一样的，前者是后者的特殊形态。后者的方法体大部分都只是在做**安全校验**，核心的就是一个 open 方法，用于打开一个文件。

主要是这两种构造器，如果文件不存在或者文件路径和名称不合法，都将抛出 FileNotFoundException 异常。

记得我们说过，基类 InputStream 中有一个抽象方法 read 要求所有子类进行实现，而 FileInputStream 使用本地方法进行了实现：

```java
public int read() throws IOException {
    return read0();
}

private native int read0() throws IOException;
```

这个 read0 的具体实现我们暂时无从探究，但是你必须明确的是，这个 read 方法的作用，它用于返回流中下一个字节，返回 **-1** 说明读取到文件末尾，已无字节可读。

除此之外，FileInputStream 中还有一些其他的读取相关方法，但大多采用了**本地方法**进行了实现，比如：

- public int **read**(byte b[])：读取 b.length() 个长度的字节到数组中
- public int **read**(byte b[], int off, int len)：读取指定长度的字节数到数组中
- public native long **skip**(long n)：跳过 n 的字节进行读取
- public void **close**()：释放流资源

看一个文件读取的例子：

```java
public static void main(String[] args) throws IOException {
    FileInputStream input = new FileInputStream("C:\\Users\\yanga\\Desktop\\test.txt");
    byte[] buffer = new byte[1024];
    int len = input.read(buffer);
    String str = new String(buffer);
    System.out.println(str);
    System.out.println(len);
    input.close();
}
```

输出结果很简单，会打印出我们 test 文件中的内容和实际读出的字节数，怎么就能保证 test 文件中内容不会超过 1024 个字节呢？

为了能够完整的读出文件中的内容，一种解决办法是：将 **buffer** 定义的足够大，以期望尽可能的能够存储下文件中的所有内容。

这种方法显然是不可取的，因为我们根本不可能实现知道待读文件的实际大小。

第二种方式就是使用的**动态字节数组流**(下一节)，它可以动态调整内部字节数组的大小，保证适当的容量。

关于 FileOutputStream，还需要强调一点的是它的构造器，其中有以下两个构造器：

```java
public FileOutputStream(String name, boolean append)
public FileOutputStream(File file, boolean append)
```

参数 append 指明了此流的写入操作是**覆盖还是追加**，true 表示追加，false 表示覆盖。



### 字节数组流 ByteArrayInput/OutputStream

所谓的「字节数组流」就是围绕一个**字节数组**运作的流，它并不像其他流一样，针对文件进行流的读写操作。

字节数组流虽然**并不是基于文件的流**，但却依然是一个很重要的流，因为它内部封装的字节数组并不是固定的，而是**动态可扩容**的，往往基于某些场景下，非常合适。

ByteArrayInputStream 是**读字节数组流**，可以通过以下构造函数被实例化：

```java
protected byte buf[];
protected int pos;
protected int count;

public ByteArrayInputStream(byte buf[]) {
    this.buf = buf;
    this.pos = 0;
    this.count = buf.length;
}

public ByteArrayInputStream(byte buf[], int offset, int length)
```

**buf** 就是被封装在 ByteArrayInputStream 内部的一个字节数组，ByteArrayInputStream 的所有读操作都是围绕着它进行的。

所以，实例化一个 ByteArrayInputStream 对象的时候，至少传入一个目标字节数组的。

pos 属性用于记录当前流读取的位置，count 记录了目标字节数组最后一个有效字节索引的后一个位置。

理解了这一点，有关它各种的 read 方法就不难了：

```java
// 读取下一个字节
public synchronized int read() {
    return (pos < count) ? (buf[pos++] & 0xff) : -1;
}
// 读取 len 个字节放到字节数组 b 中
public synchronized int read(byte b[], int off, int len){
	// ...
}
```

除此之外，ByteArrayInputStream 还非常简单的实现了「**重复读取**」操作。

```java
public void mark(int readAheadLimit) {
    mark = pos;
}

public synchronized void reset() {
    pos = mark;
}
```

因为 ByteArrayInputStream 是基于字节数组的，所有重复读取操作的实现就比较容易了，**基于索引实现**就可以了。

ByteArrayOutputStream 是**写的字节数组流**。

首先，这两个属性是必须的：

```java
protected byte buf[];

// 这里的 count 表示的是 buf 中有效字节个个数
protected int count;
```

构造器：

```java
public ByteArrayOutputStream() {
    this(32);
}
    
public ByteArrayOutputStream(int size) {
    if (size < 0) {
        throw new IllegalArgumentException("Negative initial size: "+ size);
    }
    buf = new byte[size];
}
```

构造器的核心任务是，初始化内部的字节数组 buf，允许你传入 size 显式限制初始化的字节数组大小，否则将默认长度 32 。

从外部向 ByteArrayOutputStream 写内容：

```java
public synchronized void write(int b) {
    ensureCapacity(count + 1);
    buf[count] = (byte) b;
    count += 1;
}

public synchronized void write(byte b[], int off, int len){
    if ((off < 0) || (off > b.length) || (len < 0) ||
            ((off + len) - b.length > 0)) {
            throw new IndexOutOfBoundsException();
        }
        ensureCapacity(count + len);
        System.arraycopy(b, off, buf, count, len);
        count += len;
}
```

所有写操作的第一步都是 **ensureCapacity** 方法的调用，目的是为了确保当前流内的字节数组能容纳本次写操作。

如果计算后发现，内部的 buf 不能够支持本次写操作，则会调用 grow 方法做一次扩容。扩容的原理和 ArrayList 的实现是类似的，扩大为原来的两倍容量。

除此之外，ByteArrayOutputStream 还有一个 **writeTo** 方法：

```java
public synchronized void writeTo(OutputStream out) throws IOException {
    out.write(buf, 0, count);
}
```

将我们内部封装的字节数组写到某个输出流当中。

剩余的一些方法也很常用：

- public synchronized byte **toByteArray**()[]：返回内部封装的字节数组
- public synchronized int **size**()：返回 buf 的有效字节数
- public synchronized String **toString**()：返回该数组对应的字符串形式

注意到，这两个流虽然被称作「流」，但是它们本质上**并没有像真正的流一样去分配一些资源**，所以我们无需调用它的 close 方法，调了也没用。



### 装饰者缓冲流 BufferedInput/OutputStream

#### 装饰者模式

Java I/O 使用了==装饰者模式==来实现。以 InputStream 为例，

- InputStream 是**抽象**组件；
- FileInputStream 是 InputStream 的子类，属于**具体**组件，提供了字节流的**输入**操作；
- FilterInputStream 属于**抽象装饰者**，装饰者用于装饰组件，为组件提供**额外**的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。

![1563439368833](assets/1563439368833.png)

**实例化**一个具有**缓存**功能的**字节流对象**时，只需要在 FileInputStream 对象上再**套一层** **BufferedInputStream** 对象即可。

```java
FileInputStream fileInputStream = new FileInputStream(filePath);
// 需要新功能再嵌套即可
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);		
```

DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。



#### BufferedInput/OutputStream

装饰者流其实是基于一种设计模式「**装饰者模式**」而实现的一种文件 IO 流，而我们的缓冲流只是其中的一种。

之前使用的文件读写流 FileInputStream 和 FileOutputStream 都是**一个字节一个字节**的从磁盘读取或写入，非常耗时。

而我们的**缓冲流**可以预先从磁盘一次性读出**指定容量**的字节数到内存中，之后的读取操作将直接从**内存**中读取，提高效率。下面我们一起看看缓冲流的具体实现情况：

依然先以 BufferedInputStream 为例，我们简单提一下它的几个**核心属性**：

```java
private static int DEFAULT_BUFFER_SIZE = 8192;
// 缓冲数组
protected volatile byte buf[];
private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
protected int count;
protected int pos;
protected int markpos = -1;
protected int marklimit;
```

buf 就是用于**缓冲读**的字节数组，它的值将随着流的读取而不停的被填充，继而后续的读操作可以直接**基于这个缓冲数组**。

DEFAULT_BUFFER_SIZE 规定了**默认缓冲区**的大小，即 buf 的数组长度。MAX_BUFFER_SIZE 指明了缓冲区的上限。

count 指向缓冲数组中最后一个有效字节索引后一位。pos 指向下一个待读取的字节索引位置。

markpos 和 marklimit 用于**重复读**操作。

接着我们看看 BufferedInputStream 的几个示例构造器：

```java
public BufferedInputStream(InputStream in) {
    this(in, DEFAULT_BUFFER_SIZE);
}
public BufferedInputStream(InputStream in, int size) {
    super(in);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
```

整体上来说，前者只需要传入一个「**被装饰**」的 InputStream **实例**，并使用默认大小的缓冲区。后者则可以显式指明缓冲区的大小。

除此之外，super(in) 会将这个 InputStream 实例保存进父类 FilterInputStream 的 **in 属性**字段中，并且所有实际的磁盘读操作都由这个 InputStream 实例发出。

下面我们来看最重要的读操作以及缓冲区是如何被填充的。

```java
public synchronized int read() throws IOException {
    if (pos >= count) {
        fill();
        if (pos >= count)
            return -1;
    }
    return getBufIfOpen()[pos++] & 0xff;
}
```

即从流中读取下一个字节并返回，但细节上的实现还是稍稍有些不同。

count 指向了缓冲数组中有效字节索引后一位置处，pos 指向下一个待读取的字节索引位置。理论上 pos 是不可能大于 count 的，最多等于。

如果 pos 等于 count，那说明缓冲数组中所有有效字节都已经被读取过了，此时即需要丢弃缓冲区中那些「无用」的数据，从磁盘重新加载一批新数据填充缓冲区。

而事实上，fill 方法就是做的这个事情，它的代码比较多，就解析了。

如果 fill 方法调用之后，pos 依然 等于 count，那么说明 InputStream 实例并没有从流中读取出任何数据，也即文件流中无数据可读。关于这一点，参见 fill 方法 246 行。

总的来说，如果成功填充了缓冲区，那么 read 方法将**直接从缓冲区取出一个字节**返回给调用者。

```java
public synchronized int read(byte b[], int off, int len){
    // .....
}
```

skip 方法用于跳过指定长度的字节数进行文件流的继续读取：

```java
public synchronized long skip(long n){
    // .....
}
```

注意一点的是，skip 方法尽量去跳过 n 个字节，但不保证一定跳过 n 个字节，方法返回的是实际跳过的字节数。如果缓冲数组中剩余可用字节数小于 n，那么最终将跳过缓冲数组中实际可跳过的字节数。

最后要说一说这个 close 方法：

```java
public void close() throws IOException {
    byte[] buffer;
    while ( (buffer = buf) != null) {
        if (bufUpdater.compareAndSet(this, buffer, null)) {
            InputStream input = in;
            in = null;
            if (input != null)
                input.close();
            return;
        }
        // Else retry in case a new buf was CASed in fill()
    }
}
```

close 方法将赋空「**被装饰者**」流，并调用它的 close 方法释放相关资源，最终也会清空缓冲数组所占用的内存空间。

BufferedInputStream 提供了**读缓冲**能力，而 BufferedOutputStream 则提供了**写缓冲**能力，即内存的写操作并不会立马更新到磁盘，**暂时保存在缓冲区**，待缓冲区**满时一并写**入。

```java
protected byte buf[];
protected int count;
```

buf 代表了**内部缓冲区**，count 表示缓冲区中**实际数据容量**，即 buf 中有效字节数，而不是 buf 数组长度。

```java
public BufferedOutputStream(OutputStream out) {
    this(out, 8192);
}

public BufferedOutputStream(OutputStream out, int size) {
    super(out);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
```

一样的实现思路，必须提供的是一个 OutputStream 输出流**实例**，也可以选择性指明缓冲区大小。

```java
public synchronized void write(int b) throws IOException {
    if (count >= buf.length) {
        flushBuffer();
    }
    buf[count++] = (byte)b;
}
```

写方法将首先检查缓冲区是否还能容纳本次写操作，如果不能将发起一次磁盘写操作，将缓冲区数据全部写入磁盘文件，否则将优先写入缓冲区。

当然，BufferedOutputStream 也提供了 flush 方法向外提供接口，也即不一定非要等到缓冲区满了才向磁盘写数据，你也可以显式的调用该方法让它清空缓冲区并更新磁盘文件。

```java
public synchronized void flush() throws IOException {
    flushBuffer();
    out.flush();
}
```

关于缓冲流，核心内容介绍如上，这是一种能够显著提升效率的流，通过它能够减少磁盘访问次数，提升程序执行效率。

















## 三、字符操作

### 概述

字节流处理文件的时候是**基于字节**的，而字符流处理文件则是基于一个个**字符**为基本单元的。

字符流操作的本质就是==「字节流操作」+「编码」==两个过程的**封装**，无论是写一个字符到文件，需要将字符编码成二进制，然后以字节为基本单位写入文件，或是你读一个字符到内存，你需要以字节为基本单位读出，然后转码成字符。

#### 编码与解码

**编码**就是把**字符**转换为**字节**，而**解码**是把**字节**重新组合成**字符**。

如果编码和解码过程使用不同的编码方式那么就出现了乱码。

- GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
- UTF-8 编码中，中文字符占 **3** 个字节，英文字符占 1 个字节；
- UTF-16be 编码中，中文字符和英文字符都占 2 个字节。

UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。

Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。

------

#### String 的编码方式

String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。

```java
String str1 = "中文";
// 指定编码方式
byte[] bytes = str1.getBytes("UTF-8");		
String str2 = new String(bytes, "UTF-8");
System.out.println(str2);
```

在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与**平台有关**，一般为 UTF-8。

```java
byte[] bytes = str1.getBytes();
```

Java 中的默认字符编码为：**UTF-8**，而我们知道 UTF-8 编码的字符使用 **1 到 4** 个字节进行存储，越常用的字符使用越少的字节数。

而 char 类型被定义为两个字节大小，也就是说，对于通常的字符来说，一个 char 即可存储一个字符，但对于一些增补字符集来说，往往会使用两个 char 来表示一个字符。

------

### 基类Reader 与 Writer

不管是磁盘还是网络传输，**最小的存储单元都是字节，而不是字符**。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。

- InputStreamReader 实现从字节流**解码**成**字符流**；
- OutputStreamWriter 实现字符流编码成为字节流。

Reader 作为读字符流的基类，它提供了最基本的字符读取操作。

先看看它的构造器：

```java
protected Object lock;

protected Reader() {
    this.lock = this;
}

protected Reader(Object lock) {
    if (lock == null) {
        throw new NullPointerException();
    }
    this.lock = lock;
}
```

Reader 是一个**抽象类**，这些构造器是给子类调用的，用于初始化 lock 锁对象，这一点后续会详细解释。

```java
public int read() throws IOException {
    char cb[] = new char[1];
    if (read(cb, 0, 1) == -1)
        return -1;
    else
        return cb[0];
}

public int read(char cbuf[]) throws IOException {
    return read(cbuf, 0, cbuf.length);
}

abstract public int read(char cbuf[], int off, int len)
```

基本的读字符操作都在这了，第一个方法用于读取一个**字符**出来，如果已经读到了文件末尾，将返回 **-1**，同样的以 **int** 作为返回值类型接收，为什么不用 char？原因是一样的，都是由于 **-1** 这个值的**解释不确定性**。

第二个方法和第三个方法是类似的，从文件中读取指定长度的字符放置到目标数组当中。第三个方法是抽象方法，需要子类自行实现，而第二个方法却又是基于它的。

还有一些方法也是类似的：

```java
public long skip(long n);	// 跳过 n 个字符
public boolean ready();		// 下一个字符是否可读
public boolean markSupported();	// 见 reset 方法
public void mark(int readAheadLimit); 	// 见 reset 方法
public void reset();	// 用于实现重复读操作
abstract public void close();	// 关闭流
```

这些个方法其实都见名知意，并且和我们的 InputStream 大体上都差不多。

Writer 是**写的字符流**，它用于将一个或多个字符写入到文件中，当然具体的 write 方法依然是一个**抽象**的方法，待子类来实现。



### 适配器 InpustStramReader/OutputStreamWriter

适配器类，能将InputStream/OutputSteam 转换为 Reader/Writer。

适配器字符流继承自基类 Reader 或 Writer。主要的作用就是将一个**字节流转换成一个字符流**，我们先以读适配器为例。

首先就是它最核心的成员：

```java
private final StreamDecoder sd;
```

StreamDecoder 是一个**解码器**，用于将**字节的各种操作转换成字符**的相应操作。

然后就是构造器：

```java
public InputStreamReader(InputStream in) {
    super(in);
    try {
        sd = StreamDecoder.forInputStreamReader(in, this, (String)null); 
    } catch (UnsupportedEncodingException e) {
        throw new Error(e);
    }
}

public InputStreamReader(InputStream in, String charsetName) 
    throws UnsupportedEncodingException
{
    super(in);
    if (charsetName == null)
        throw new NullPointerException("charsetName");
    sd = StreamDecoder.forInputStreamReader(in, this, charsetName);
}
```

这两个构造器的目的都是为了**初始化这个解码器**，都调用的方法 forInputStreamReader，只是参数不同而已。我们不妨看看这个方法的实现：

```java
public static StreamDecoder forInputStreamReader(InputStream in, Object lock, String charsetName) throws UnsupportedEncodingException {
    String csn = charsetName;
    if (csn == null)
        csn = Charset.defaultCharset().name();
    try {
        if (Charset.isSupported(csn))
            return new StreamDecoder(in, lock, Charset.forName(csn));
    } catch (IllegalCharsetNameException x) { }
    throw new UnsupportedEncodingException (csn);
}
```

这是一个典型的**静态工厂模式**，参数 charsetName 其实代表的是一种字符编码的名称，如果为 null，那么将使用系统默认的字符编码：UTF-8 。

最终我们能够得到一个**解码器实例**。

接着介绍的所有方法几乎都是依赖的这个解码器而实现的。

```java
public String getEncoding() {
    return sd.getEncoding();
}

public int read() throws IOException {
    return sd.read();
}

public int read(char cbuf[], int offset, int length){
    return sd.read(cbuf, offset, length);
}

public void close() throws IOException {
    sd.close();
}
```

解码器中相关的方法的实现代码还是相对复杂的，这里我们不做深入的研究，但大体上的实现思路就是：**「字节流读取 + 解码」**的过程。

当然了，OutputStreamWriter 中必然也存在一个**相反的 StreamEncoder 实例**用于**编码字符**。

除了这一点外，其余的操作并没有什么不同，或是通过字符数组向文件中写入，或是通过字符串向文件中写入，又或是通过 int 的低 16 位向文件中写入。



### 文件字符流 FileReader/Writer

FileReader/Writer 不能指定编码类型，只能使用默认编码，如果需要指定编码类型需要使用InpustStramReader/OutputStreamWriter。

FileReader/Writer **没有缓冲**，也**不能按行读写**，一般应该在它们的外面**包装**上对应的**缓冲类**。

文件的字符流可以说非常简单，除了构造器，就不存在任何其他方法了，完全依赖文件字节流。

我们以 FileReader 为例，

FileReader 继承自 InputStreamReader，有且仅有以下三个构造器：

```java
public FileReader(String fileName) throws FileNotFoundException {
    super(new FileInputStream(fileName));
}

public FileReader(File file) throws FileNotFoundException {
    super(new FileInputStream(file));
}

public FileReader(FileDescriptor fd) {
    super(new FileInputStream(fd));
}
```

理论上来说，所有的字符流都应当以我们的**适配器为基类**，因为只有它提供了字符到字节之间的转换，无论你是写或是读都离不开它。

而我们的 FileReader 并没有扩展任何一个自己的方法，父类 InputStreamReader 中预实现的字符操作方法对他来说已经足够，只需要传入一个对应的字节流实例即可。

FileWriter 也是一样的，这里不再赘述了。



### 字符数组流 CharArrayReader/Writer

字符数组和字节数组流是类似的，都是用于解决那种**不确定文件大小**，而需要读取其中大量内容的情况。

由于它们内部提供**动态扩容机制**，所以既可以完全容纳目标文件，也可以控制数组大小，不至于分配过大内存而浪费了大量内存空间。

先以 CharArrayReader 为例

```java
protected char buf[];

public CharArrayReader(char buf[]) {
    this.buf = buf;
    this.pos = 0;
    this.count = buf.length;
}

public CharArrayReader(char buf[], int offset, int length){
    // ....
}
```

构造器核心任务就是初始化一个字符数组到内部的 buf 属性中，以后所有对该字符数组流实例的读操作都基于 buf 这个字符数组。

关于 CharArrayReader 的其他方法以及 CharArrayWriter，这里不再赘述了，和上篇的字节数组流基本类似。

除此之外，这里还涉及一个 StringReader 和 StringWriter，其实本质上和字符数组流是一样的，毕竟 String 的本质就是 char 数组。



### 缓冲数组流 BufferedReader/Writer

同样的，BufferedReader/Writer 作为一种**缓冲流**，也是**装饰者流**，用于提供**缓冲功能**。大体上类似于我们的字节缓冲流，这里简单介绍下。

```java
private Reader in;
private char cb[];
private static int defaultCharBufferSize = 8192;

public BufferedReader(Reader in, int sz){..}

public BufferedReader(Reader in) {
    this(in, defaultCharBufferSize);
}
```

cb 是一个字符数组，用于缓存从文件流中读取出来的部分字符，你可以在构造器中初始化这个数组的长度，否则将使用默认值 **8192** 。

```java
public int read() throws IOException {..}

public int read(char cbuf[], int off, int len){...}
```

关于 read，它依赖成员属性 in 的读方法，而 in 作为一个 Reader 类型，内部往往又依赖的某个 InputStream 实例的读方法。

**所以说，几乎所有的字符流都离不开某个字节流实例。**

关于 BufferedWriter，这里也不再赘述了，大体上都是类似的，只不过一个是读一个是写而已，都围绕着内部的字符数组进行。



 **实现逐行输出文本文件的内容**

```java
public static void readFileContent(String filePath) throws IOException {

    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }

    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}
```





## 四、高级文件操作

### 常见文件操作

#### 属性文件

Java属性文件就是配置文件。其中以**键值对**的形式存放信息。注意，每个键值对结尾**没有分号**。

如：jdbc.properties

```properties
driverClass = com.mysql.jdbc.Driver
url = jdbc:myql:///jdbctest
username = root
password = 123456
```

Java程序可以调用属性文件。方式为：

```java
public class JDBCUtils {
	private static final String driverClass;
	private static final String url;
	private static final String username;
	private static final String password;
	
	static {
		// 加载属性文件并解析
		Properties props = new Properties();
		// 使用类加载器获得属性文件的输入流
		InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
		try {
            // 传入流
			props.load(is);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			System.out.println("加载is失败");
		}
		driverClass=props.getProperty("driverClass");
		url=props.getProperty("url");
		username=props.getProperty("username");
		password=props.getProperty("password");
	}
}
```

步骤可以总结为：

- 编写属性文件xxx.properties;

- 获取属性文件对象：Properties props = new Properties();

- 使用类加载器获得属性文件输入流。这里的路径，属性文件直接放在了eclipse的src文件夹下，当前类在包下，因为package指向的根目录也在src文件夹下，所以可以直接写文件名。

```java
InputStream is = 当前类.class.getClassLoader().getResourceAsStream("属性文件的路径");  
```

- 属性文件对象加载属性文件：props.load(is);

- 获取属性值 xxxx = props.getProperty("key");

java.uitl.Properties 类的好处：

- 可以自动处理空格，分隔符 = 前后的空格自动忽略。
- 可以自动忽略空行。
- 可以添加注释，# 或者 ！开头的行被忽视。
- 限制是不能直接处理中文。



### 随机读写文件

Java.io 包提供了 RandomAccessFile 类用于随机文件的创建和访问。使用这个类，可以跳转到文件的任意位置读写数据。程序可以在随机文件中插入数据，而不会破坏该文件的其他数据。此外，程序也可以更新或删除先前存储的数据，而不用重写整个文件。

用于随机读写，更接近于操作系统的 API，在实现以些系统程序时，它比流更为方便高效。

RandomAccessFile类是Object类的直接子类，包含两个主要的构造方法用来创 建RandomAccessFile 的对象，如表 10-11 所示。  

|                     构造方法                      |                             释义                             |
| :-----------------------------------------------: | :----------------------------------------------------------: |
| public RandomAccessFile(String name, String mode) | 指定随机文件流对象所对应的文件名，以 mode 表示对文件的访问模式 |
| public RandomAccessFile (File file, String mode)  | 以 file 指定随机文件流对象所对应的文件名，以 mode 表示访问模式 |

需要注意的是，mode 表示所创建的随机读写文件的操作状态，其取值包括：

- r：表示以只读方式打开文件。
- rw：表示以读写方式打开文件，使用该模式只用一个对象即可同时实现读写操作。

RandowAccessFile 类常用的方法及说明如下。

|           **方法**           |                         **功能描述**                         |
| :--------------------------: | :----------------------------------------------------------: |
|        long length()         |                         返回文件长度                         |
|     void seek(long pos)      |      移动文件位置指示器，pos 指定从文件开头的偏离字节数      |
|     int skipBytes(int n)     |           跳过 n 个字节，返回数为实际跳过的字节数            |
|          int read()          | 从文件中读取一个字节，字节的高 24 位为 0，若遇到文件结尾，返回-1 |
|    final byte readByte()     |                  从文件中读取带符号的字节值                  |
|    final char readChar()     |                从文件中读取一个 Unicode 字符                 |
| final void writeChar(inte c) |                    写入一个字符，两个字节                    |



### 内存映射文件







## 五、对象操作

#### 序列化

序列化就是将一个对象转换成**字节序列**，方便存储和传输。

- 序列化：ObjectOutputStream.**writeObject**()
- 反序列化：ObjectInputStream.**readObject**()

==不会对静态变量进行序列化==，因为序列化只是保存**对象的状态**，静态变量属于**类**的状态。

------

#### Serializable

序列化的类需要实现 **Serializable** 接口，它只是一个标准，**没有任何方法**需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {

    A a1 = new A(123, "abc");
    String objectFile = "file/a1";

    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();

    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
    A a2 = (A) objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}

// 实现Serializable接口的类
private static class A implements Serializable {
    private static int c = 0; 	// 静态变量不会被序列化
    private int x;
    private String y;

    A(int x, String y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "x = " + x + "  " + "y = " + y;
    }
}
```

------

#### transient

transient 关键字可以使一些属性**不会**被序列化。

ArrayList 中存储数据的数组 **elementData** 是用 **transient** 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过**重写**序列化和反序列化方法，使得可以只序列化数组中**有内容**的那部分数据。

```java
private transient Object[] elementData;
```













## 六、网络操作

Java 中的网络支持：

- InetAddress：用于表示网络上的硬件资源，即 IP 地址；
- URL：统一资源定位符；
- Sockets：使用 TCP 协议实现网络通信；
- Datagram：使用 UDP 协议实现网络通信。

#### InetAddress

没有公有的构造函数，只能通过**静态方法**来创建实例。

```java
InetAddress.getByName(String host);
InetAddress.getByAddress(byte[] address);
```

------

#### URL

可以直接从 URL 中读取字节流数据。

```java
public static void main(String[] args) throws IOException {

    URL url = new URL("http://www.baidu.com");

    /* 字节流 */
    InputStream is = url.openStream();

    /* 字符流 */
    InputStreamReader isr = new InputStreamReader(is, "utf-8");

    /* 提供缓存功能 */
    BufferedReader br = new BufferedReader(isr);

    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }

    br.close();
}
```

------

#### Sockets

- ServerSocket：服务器端类
- Socket：客户端类
- 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。

![1563439394302](assets/1563439394302.png)

------

#### Datagram

- DatagramSocket：通信类
- DatagramPacket：数据包类







## 七、NIO

新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了**高速的、面向块**的 I/O。

#### 流与块

I/O 与 NIO 最重要的区别是数据打包和传输的方式，==I/O 以流的方式处理数据，而 NIO 以块的方式处理数据==。

面向流的 I/O 一次处理**一个字节数据**：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。

面向块的 I/O 一次处理**一个数据块**，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。

I/O 包和 NIO 已经很好地集成了，java.io.\* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.\* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。

------

#### 通道与缓冲区

##### 1. 通道

通道 **Channel** 是对原 I/O 包中的**流的模拟**，可以通过它读取和写入数据。

通道与流的不同之处在于，**流**只能在**一个方向**上移动(一个流必须是 **InputStream** 或者 **OutputStream** 的子类)，而**通道是双向**的，可以用于读、写或者**同时**用于读写。

通道包括以下类型：

- FileChannel：从**文件**中读写数据；
- DatagramChannel：通过 **UDP** 读写网络中数据；
- SocketChannel：通过 **TCP** 读写网络中数据；
- ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。

##### 2. 缓冲区

发送给一个通道的所有数据都必须首先放到**缓冲区**中，同样地，从通道中读取的任何数据都要先**读到缓冲区**中。也就是说，**不会直接对通道进行读写数据，而是要先经过缓冲区**。

缓冲区实质上是一个**数组**，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

缓冲区包括以下类型：

- ByteBuffer
- CharBuffer
- ShortBuffer
- IntBuffer
- LongBuffer
- FloatBuffer
- DoubleBuffer

------

#### 缓冲区状态变量

- capacity：**最大容量**；
- position：当前**已经读写**的字节数；
- limit：**还可以读写**的字节数。

状态变量的改变过程举例：

① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。

![1563439428762](assets/1563439428762.png)

② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。

![1563439446664](assets/1563439446664.png)

③ 在将缓冲区的数据写到输出通道之前，需要先调用 **flip()** 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。

![1563439462315](assets/1563439462315.png)

④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。

![1563439481199](assets/1563439481199.png)

⑤ 最后需要调用 **clear()** 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。

![1563439494891](assets/1563439494891.png)

------

#### 文件 NIO 实例

以下展示了使用 **NIO 快速复制文件**的实例：

```java
public static void fastCopy(String src, String dist) throws IOException {

    /* 获得源文件的输入字节流 */
    FileInputStream fin = new FileInputStream(src);

    /* 获取输入字节流的文件通道 */
    FileChannel fcin = fin.getChannel();

    /* 获取目标文件的输出字节流 */
    FileOutputStream fout = new FileOutputStream(dist);

    /* 获取输出字节流的文件通道 */
    FileChannel fcout = fout.getChannel();

    /* 为缓冲区分配 1024 个字节 */
    ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

    while (true) {

        /* 从输入通道中读取数据到缓冲区中 */
        int r = fcin.read(buffer);

        /* read() 返回 -1 表示 EOF */
        if (r == -1) {
            break;
        }

        /* 切换读写 */
        buffer.flip();

        /* 把缓冲区的内容写入输出文件中 */
        fcout.write(buffer);

        /* 清空缓冲区 */
        buffer.clear();
    }
}
```

------

#### 选择器

NIO 常常被叫做**非阻塞 IO**，主要是因为 NIO 在**网络通信**中的非阻塞特性被广泛使用。

NIO 实现了 ==IO 多路复用中的 Reactor 模型==，**一个线程** Thread 使用一个**选择器** Selector 通过**轮询**的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。

通过配置监听的通道 Channel 为**非阻塞**，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。

因为创建和切换线程的开销很大，因此使用**一个线程来处理多个事件**而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。

应该注意的是，只有套接字 **Channel** 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。

![1563439535164](assets/1563439535164.png)

##### 1. 创建选择器

```java
Selector selector = Selector.open();
```

##### 2. 将通道注册到选择器上

```java
ServerSocketChannel ssChannel = ServerSocketChannel.open();
ssChannel.configureBlocking(false);
ssChannel.register(selector, SelectionKey.OP_ACCEPT);
```

**通道**必须配置为**非阻塞模式**，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。

在将通道注册到选择器上时，还需要指定要**注册的具体事件**，主要有以下几类：

- SelectionKey.OP_CONNECT
- SelectionKey.OP_ACCEPT
- SelectionKey.OP_READ
- SelectionKey.OP_WRITE

它们在 SelectionKey 的定义如下：

```java
public static final int OP_READ = 1 << 0;
public static final int OP_WRITE = 1 << 2;
public static final int OP_CONNECT = 1 << 3;
public static final int OP_ACCEPT = 1 << 4;
```

可以看出每个事件可以被当成一个**位域**，从而组成事件集整数。例如：

```java
int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
```

##### 3. 监听事件

```java
int num = selector.select();
```

使用 select() 来**监听**到达的事件，它会一直阻塞直到有至少一个事件到达。

##### 4. 获取到达的事件

```java
Set<SelectionKey> keys = selector.selectedKeys();
Iterator<SelectionKey> keyIterator = keys.iterator();
while (keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if (key.isAcceptable()) {
        // ...
    } else if (key.isReadable()) {
        // ...
    }
    keyIterator.remove();
}
```

##### 5. 事件循环

因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个**死循环**内。

```java
while (true) {
    int num = selector.select();
    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> keyIterator = keys.iterator();
    while (keyIterator.hasNext()) {
        SelectionKey key = keyIterator.next();
        if (key.isAcceptable()) {
            // ...
        } else if (key.isReadable()) {
            // ...
        }
        keyIterator.remove();
    }
}
```

------

#### 套接字 NIO 实例

NIO服务器

```java
public class NIOServer {

    public static void main(String[] args) throws IOException {
		// 选择器
        Selector selector = Selector.open();	

        ServerSocketChannel ssChannel = ServerSocketChannel.open();
        ssChannel.configureBlocking(false);
        // 注册
        ssChannel.register(selector, SelectionKey.OP_ACCEPT);
		// 服务Socket
        ServerSocket serverSocket = ssChannel.socket();
        InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
        serverSocket.bind(address);
		// 死循环监听
        while (true) {

            selector.select();
            Set<SelectionKey> keys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = keys.iterator();

            while (keyIterator.hasNext()) {

                SelectionKey key = keyIterator.next();

                if (key.isAcceptable()) {

                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();

                    // 服务器会为每个新连接创建一个 SocketChannel
                    SocketChannel sChannel = ssChannel1.accept();
                    sChannel.configureBlocking(false);

                    // 这个新连接主要用于从客户端读取数据
                    sChannel.register(selector, SelectionKey.OP_READ);

                } else if (key.isReadable()) {

                    SocketChannel sChannel = (SocketChannel) key.channel();
                    System.out.println(readDataFromSocketChannel(sChannel));
                    sChannel.close();
                }

                keyIterator.remove();
            }
        }
    }

    // 从socket通道中读取数据
    private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException {

        ByteBuffer buffer = ByteBuffer.allocate(1024);
        StringBuilder data = new StringBuilder();

        while (true) {

            buffer.clear();
            int n = sChannel.read(buffer);
            if (n == -1) {
                break;
            }
            buffer.flip();
            int limit = buffer.limit();
            char[] dst = new char[limit];
            for (int i = 0; i < limit; i++) {
                dst[i] = (char) buffer.get(i);
            }
            data.append(dst);
            buffer.clear();
        }
        return data.toString();
    }
}
```

NIO客户端

```java
public class NIOClient {

    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream out = socket.getOutputStream();
        String s = "hello world";
        out.write(s.getBytes());
        out.close();
    }
}
```

------

#### 内存映射文件

**内存映射文件 I/O** 是一种读和写**文件**数据的方法，它可以比常规的基于流或者基于通道的 I/O **快得多**。

向内存映射文件写入可能是**危险**的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。

下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。

```java
MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
```

------

#### 对比

NIO 与普通 I/O 的区别主要有以下两点：

- NIO 是**非阻塞**的；
- NIO 面向**块**，I/O 面向流。









## 参考资料

- Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.
- [IBM: NIO 入门](https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html)
- [Java NIO Tutorial](http://tutorials.jenkov.com/java-nio/index.html)
- [Java NIO 浅析](https://tech.meituan.com/nio.html)
- [IBM: 深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html)
- [IBM: 深入分析 Java 中的中文编码问题](https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html)
- [IBM: Java 序列化的高级认识](https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html)
- [NIO 与传统 IO 的区别](http://blog.csdn.net/shimiso/article/details/24990499)
- [Decorator Design Pattern](http://stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html#mode=document)
- [Socket Multicast](