[TOC]

### 虚拟机调优

不管是 YGC 还是 Full GC, GC 过程中都会对导致程序运行中中断, 正确的选择不同的 GC 策略,调整 JVM、GC 的参数，可以极大的减少由于 GC 工作，而导致的程序运行中断方面的问题，进而适当的提高 Java 程序的工作效率。但是调整 GC 是以个极为复杂的过程，由于各个程序具备不同的特点，如：web 和 GUI 程序就有很大区别（Web可以适当的停顿，但 GUI 停顿是客户无法接受的），而且由于跑在各个机器上的配置不同（主要 CPU 个数，内存不同），所以使用的 GC 种类也会不同(如何选择见 GC 种类及如何选择)。本文将注重介绍 JVM、G C的一些重要参数的设置来提高系统的性能。



#### 虚拟机参数

##### **堆内存分配：**

-Xms512m ：设置JVM初始分配的堆内存为512M，默认是物理内存的1/64。

默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。

##### **代空间分配：**

-XX:NewRatio=N 设置新生代和老年代的空间占用比率。可以通过这个比率算出新生代空间的大小。默认占堆的33%。

-XX:NewSize=N 设置新生代空间的初始大小。使用这个参数设置的新生代大小的优先级比NewRatio的高。

-XX:MaxNewSize=N 设置新生代空间的最大大小。

-XmnN：设置年轻代大小为N，将NewSize，MaxNewSize设置为同一个值。整个堆大小=年轻代大小 + 年老代大小 。所以增大年轻代后，将会减小年老代大小。

##### **非堆内存分配（方法区）：**

-XX:PermSize 设置非堆内存初始值，默认是物理内存的1/64；

-XX:MaxPermSize 设置最大非堆内存的大小，默认是物理内存的1/4。 

##### **栈内存分配：**

-Xss128k：设置栈的大小，栈的大小直接决定函数调用的可达深度。

JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为 256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。

行为参数：

|       参数及其默认值        |                           描述                            |
| :-------------------------: | :-------------------------------------------------------: |
|   -XX:-DisableExplicitGC    |          禁止调用System.gc()；但jvm的gc仍然有效           |
|       -XX:+MaxFDLimit       |                最大化文件描述符的数量限制                 |
|  -XX:+ScavengeBeforeFullGC  |                 新生代GC优先于Full GC执行                 |
|   -XX:+UseGCOverheadLimit   |         在抛出OOM之前限制jvm耗费在GC上的时间比例          |
| **-XX:-UseConcMarkSweepGC** |            对老生代采用并发标记交换算法进行GC             |
|   **-XX:-UseParallelGC**    |                启用并行GC，收集新生代空间                 |
|    -XX:-UseParallelOldGC    | 对Full GC启用并行，当-XX:-UseParallelGC启用时该项自动启用 |
|    **-XX:-UseSerialGC**     |                        启用串行GC                         |
|  -XX:+UseThreadPriorities   |                    启用本地线程优先级                     |

性能调优参数列表：

|        参数及其默认值         |                 描述                  |
| :---------------------------: | :-----------------------------------: |
|  -XX:LargePageSizeInBytes=4m  |      设置用于Java堆的大页面尺寸       |
|    -XX:MaxHeapFreeRatio=70    |    GC后java堆中空闲量占的最大比例     |
|    **-XX:MaxNewSize=size**    |     新生成对象能占用内存的最大值      |
|    **-XX:MaxPermSize=64m**    |     老生代对象能占用内存的最大值      |
|    -XX:MinHeapFreeRatio=40    |    GC后java堆中空闲量占的最小比例     |
|        -XX:NewRatio=2         | 新生代内存容量与老生代内存容量的比例  |
|    **-XX:NewSize=2.125m**     |   新生代对象生成时占用内存的默认值    |
| -XX:ReservedCodeCacheSize=32m |        保留代码占用的内存容量         |
|    -XX:ThreadStackSize=512    | 设置线程栈大小，若为0则使用系统默认值 |
|      -XX:+UseLargePages       |            使用大页面内存             |

我们在日常性能调优中基本上都会用到以上黑体的这几个属性；

调试参数列表：

|                  参数及其默认值                  |                             描述                             |
| :----------------------------------------------: | :----------------------------------------------------------: |
|                   -XX:-CITime                    |                   打印消耗在JIT编译的时间                    |
|       -XX:ErrorFile=./hs_err_pid\<pid>.log       |                 保存错误日志或者数据到文件中                 |
|            -XX:-ExtendedDTraceProbes             |                 开启solaris特有的dtrace探针                  |
|   **-XX:HeapDumpPath=./java_pid\<pid>.hprof**    |              **指定导出堆信息时的路径或文件名**              |
|       **-XX:-HeapDumpOnOutOfMemoryError**        |           **当首次遭遇OOM时导出此时堆中相关信息**            |
|                       -XX:                       |               出现致命ERROR之后运行自定义命令                |
| -XX:OnOutOfMemoryError="\<cmd args>;\<cmd args>" |                当首次遭遇OOM时执行自定义命令                 |
|             -XX:-PrintClassHistogram             | 遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同  |
|          **-XX:-PrintConcurrentLocks**           | **遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同** |
|            -XX:-PrintCommandLineFlags            |                  打印在命令行中出现过的标记                  |
|              -XX:-PrintCompilation               |                当一个方法被编译时打印相关信息                |
|                   -XX:-PrintGC                   |                     每次GC时打印相关信息                     |
|               -XX:-PrintGC Details               |                     每次GC时打印详细信息                     |
|              -XX:-PrintGCTimeStamps              |                      打印每次GC的时间戳                      |
|              -XX:-TraceClassLoading              |                       跟踪类的加载信息                       |
|          -XX:-TraceClassLoadingPreorder          |                跟踪被引用到的所有类的加载信息                |
|            -XX:-TraceClassResolution             |                          跟踪常量池                          |
|             -XX:-TraceClassUnloading             |                       跟踪类的卸载信息                       |
|           -XX:-TraceLoaderConstraints            |                  跟踪类加载器约束的相关信息                  |



#### 溢出异常

##### **Java 堆溢出**

 Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

下面代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。

```java
public class HeapOOM {

    static class OOMObject{}
    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<HeapOOM.OOMObject>();
        while(true) {
            list.add(new OOMObject());
        }
    }
}
```

 Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示 “**Java heap space**”。

 要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了**内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。**

如果是**内存泄漏**，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。

如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少的程序运行期的内存消耗。



##### **虚拟机栈和本地方法栈溢出**

由于在Hotspot虚拟机中中不区分虚拟机栈和本地方法栈，因此通过-Xoss修改参数是无效的，可以通过修改-Xss设定。

- 如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError异常。
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常。

这两种异常有一些重叠的部分：当栈空间无法继续分配时，到底是内存太小，还是已经使用的栈空间过大，其本质只是对同一件事情的两种不同描述。

可以通过一下方法验证：

- 在使用-Xss参数减少栈内存容量，结果抛出 StackOverflowError 异常，异常出现时输出的堆栈深度相应缩小。
- 定义了大量的本地变量，增大此方法栈中本地变量表的长度，结果抛出 StackOverflowError 异常时输出的堆栈深度相应缩小。

可以通过递归调用的方式进行测试：

```java
public void stackLeak() {
	stackLeak();
}
```



##### **方法区溢出**

动态代理可能在运行时产生大量的类导致方法区溢出，所以 Spring 等实用 CGLIB 可以配置较大的方法区。



##### **本机直接内存溢出**

DirectoryMemory 可以通过 -XX：MaxDirectMemorySize 指定，如果不指定则默认与 Java 堆大小一样。其明显特征是 Heap Dump 文件中不会看见明显的异常，如果 Dump 文件很小，程序中又直接或者间接使用了 NIO，可以检查一下是否是这方面原因。





#### 其他

##### **经验&&规则**

- 年轻代大小选择
    1. 响应时间优先的应用:尽可能设大,直到接近系统的最低响应时间限制(根据实际情况选择).在此种情况下,年轻代收集发生的频率也是最小的.同时,减少到达年老代的对象.
    2. 吞吐量优先的应用:尽可能的设置大,可能到达 Gbit 的程度.因为对响应时间没有要求,垃圾收集可以并行进行,一般适合 8CPU 以上的应用.
    3. 避免设置过小.当新生代设置过小时会导致:①YGC 次数更加频繁 ②可能导致 YGC 对象直接进入旧生代,如果此时旧生代满了,会触发 FGC.

- 年老代大小选择
    1. 响应时间优先的应用:年老代使用并发收集器,所以其大小需要小心设置,一般要考虑并发会话率和会话持续时间等一些参数.如果堆设置小了,可以会造成内存碎 片,高回收频率以及应用暂停而使用传统的标记清除方式;如果堆大了,则需要较长的收集时间.最优化的方案,一般需要参考以下数据获得: 并发垃圾收集信息、持久代并发收集次数、传统 GC 信息、花在年轻代和年老代回收上的时间比例。
    2. 吞吐量优先的应用:一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代.原因是,这样可以尽可能回收掉大部分短期对象,减少中期的对象,而年老代尽存放长期存活对象.
- 较小堆引起的碎片问题
    因为年老代的并发收集器使用标记,清除算法,所以不会对堆进行压缩.当收集器回收时,他会把相邻的空间进行合并,这样可以分配给较大的对象.但是,当堆空间较小时,运行一段时间以后,就会出现"碎片",如果并发收集器找不到足够的空间,那么并发收集器将会停止,然后使用传统的标记,清除方式进行回收.如果出现"碎片",可能需要进行如下配置:
    - -XX:+UseCMSCompactAtFullCollection: 使用并发收集器时,开启对年老代的压缩。
    - -XX:CMSFullGCsBeforeCompaction=0: 上面配置开启的情况下,这里设置多少次 Full GC 后,对年老代进行压缩
- 用 64 位操作系统，Linux 下 64 位的 jdk 比 32 位 jdk 要慢一些，但是吃得内存更多，吞吐量更大。
- XMX 和 XMS 设置一样大，MaxPermSize 和 MinPermSize 设置一样大，这样可以减轻伸缩堆大小带来的压力。
- 使用 CMS 的好处是用尽量少的新生代，经验值是 128M－256M， 然后老生代利用 CMS 并行收集， 这样能保证系统低延迟的吞吐效率。 实际上 CMS 的收集停顿时间非常的短，2G 的内存， 大约 20－80ms 的应用程序停顿时间。
- 系统停顿的时候可能是 GC 的问题也可能是程序的问题，多用 jmap 和 jstack 查看，或者 killall -3 java，然后查看 Java 控制台日志，能看出很多问题。(相关工具的使用方法将在后面的 blog 中介绍)
- 仔细了解自己的应用，如果用了缓存，那么年老代应该大一些，缓存的 HashMap 不应该无限制长，建议采用LRU 算法的 Map 做缓存，LRUMap 的最大长度也要根据实际情况设定。
- 采用并发回收时，年轻代小一点，年老代要大，因为年老大用的是并发回收，即使时间长点也不会影响其他程序继续运行，网站不会停顿。
- JVM 参数的设置(特别是 –Xmx –Xms –Xmn -XX:SurvivorRatio  -XX:MaxTenuringThreshold 等参数的设置没有一个固定的公式，需要根据 PV old 区实际数据 YGC 次数等多方面来衡量。为了避免 promotion faild 可能会导致 xmn 设置偏小，也意味着 YGC 的次数会增多，处理并发访问的能力下降等问题。每个参数的调整都需要经过详细的性能测试，才能找到特定应用的最佳配置。







**参考资料**

- https://blog.csdn.net/dasandeyu89/article/details/80919788

- 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.
- [Chapter 2. The Structure of the Java Virtual Machine](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4)
- [Jvm memory](https://www.slideshare.net/benewu/jvm-memory)
    [Getting Started with the G1 Garbage Collector](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)
- [JNI Part1: Java Native Interface Introduction and “Hello World” application](http://electrofriends.com/articles/jni/jni-part1-java-native-interface/)
- [Memory Architecture Of JVM(Runtime Data Areas)](https://hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/)
- [JVM Run-Time Data Areas](https://www.programcreek.com/2013/04/jvm-run-time-data-areas/)
- [Android on x86: Java Native Interface and the Android Native Development Kit](http://www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271)
- [深入理解 JVM(2)——GC 算法与内存分配策略](https://crowhawk.github.io/2017/08/10/jvm_2/)
- [深入理解 JVM(3)——7 种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)
- [JVM Internals](http://blog.jamesdbloom.com/JVMInternals.html)
- [深入探讨 Java 类加载器](https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html#code6)
- [Guide to WeakHashMap in Java](http://www.baeldung.com/java-weakhashmap)
- [Tomcat example source code file (ConcurrentCache.java)](https://alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml)

