[TOC]



## 一、并发基础

### 线程的基本概念

#### 1. 线程状态转换

![1563601922262](assets/1563601922262.png)

**新建（New）**

创建后尚未启动。

**可运行（Runnable）**

可能正在运行，也可能正在等待 CPU 时间片。

包含了操作系统线程状态中的 Running 和 Ready。

**阻塞（Blocked）**

等待获取一个排它锁，如果其线程释放了锁就会结束此状态。

**无限期等待（Waiting）**

等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

**限期等待（Timed Waiting）**

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。

调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。

睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | LockSupport.unpark(Thread)                      |
| LockSupport.parkUntil() 方法             | LockSupport.unpark(Thread)                      |

**终结（Terminated）**

可以是线程结束任务之后自己结束，或者产生了异常而结束。



#### 2. 使用与创建线程

有三种使用线程的方法：

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

##### 实现 Runnable 接口

需要实现 run() 方法。没有返回值。

通过 Thread 调用 start() 方法来启动线程。

```java
public class MyRunnable implements Runnable {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
```

------

##### 实现 Callable 接口

与 Runnable 相比，Callable **可以有返回值**，返回值通过 **FutureTask** 进行封装。

```java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
```

------

##### 继承 Thread 类

同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。

当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。

```java
public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
```

------

##### 实现方法对比

实现接口会更好一些，因为：

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。



#### 3. 线程基本属性与方法

##### 优先级

每个线程都具有各自的优先级，线程的优先级可以在程序中表明该线程的重要性，如果有很多线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这并不意味着低优先级的线程得不到运行，而只是它运行的几率比较小，比如垃圾回收线程的优先级就较低。

Thread类中包含的成员变量代表了线程的某些优先级，比如Thread.MIN_PRIORITY（常数1）、Thread.MAX_PRIORITY（常数2）、Thread.NORM_PRIORITY（常数5）。其中每个线程的优先级都在Thread.MIN_PRIORITY~Thread.MAX_PRIORITY之间，在默认情况下其优先级都是Thread.NORM_PRIORITY。每个新产生的线程都继承了父线程的优先级。
线程的优先级可以使用 setPriority() 方法进行调整，如果使用该方法设置的优先级不在1~10之内，将产生异常。

##### Daemon

守护线程是程序运行时在后台提供**服务**的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

使用 setDaemon() 方法将一个线程设置为守护线程。

```java
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);	// 设置为守护线程
}
```

##### sleep()

Thread.sleep(millisec) 方法会**休眠**当前正在执行的线程，millisec 单位为**毫秒**。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

##### yield()

对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```java
public void run() {
    Thread.yield();
}
```

#### 4. 共享内存及存在的问题

每个线程有自己的程序计数器，有自己的栈，但是线程之间可能存在共享内存，可以访问与操作相同的对象。因此可能存在问题。

##### 竞态条件

当多个线程访问与操作同一个对象时，最终执行的结果与执行时序有关，可能正确也可能不正确。

如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。

以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。

```java
public class ThreadUnsafeExample {

    private int cnt = 0;

    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
997
```

解决的方法：

- 使用 synchronized 关键字；
- 使用显示锁；
- 使用原子变量。



##### 内存可见性

当多个线程访问与操作同一个对象，当一个线程对一个共享变量修改时，另一个线程不一定马上就能看到，甚至永远看不到。除了内存，数据还会被缓存到CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存读取，而不一定从内存中去读取，当修改一个变量时，也可能是先写到缓存，之后再同步更新到内存中。这在多线程下就可能造成内存可见性问题。

解决方法：

- 使用 volatile 关键字（不能解决静态条件问题）；
- 实现 synchronized 关键字或显示锁进行同步。



### synchronized

Java 提供了两种锁机制来控制多个线程对共享资源的**互斥访问**，第一个是 JVM 实现的 **synchronized**，而另一个是 JDK 实现的 **ReentrantLock**(见后面)。

使用了**synchronized** 就变成了原子操作。

#### synchronized 用法

##### 1. 同步代码块与实例方法

synchronized 保护的是**对象**。

```java
// 同步代码块
public void func() {
    synchronized (this) {
        // ...
    }
}

// 同步实例方法
public synchronized void func () {
    // ...
}
```

它只作用于==同一个对象==，如果调用两个对象上的同步代码块，就不会进行同步。即保护的是同一个对象的方法调用。再具体来说，synchronized 实例方法保护的是当前实例对象，**即 this**。this 对象有一个**锁**和一个**等待队列**，锁只能被一个线程持有，其他线程需要锁时会尝试获取，没获取到就进入等待队列等待，并进入 BLOCKED 状态。

对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须**等待**。

```java
public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
```

```java
public static void main(String[] args) {
    // 作用于同一个e1对象 需要等待
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e1.func1());
}
```

```html
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

对于以下代码，两个线程调用了**不同对象**的同步代码块，两个对象**各自拥有**自己的锁和等待队列，因此这两个线程就**不需要同步**。从输出结果可以看出，两个线程交叉执行。

```java
public static void main(String[] args) {
    // 由于同步的是代码块 所以使用两个不同对象的锁不用同步
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e2.func1());
}
```

```html
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
```

##### 2. 同步一个静态方法

synchronized 保护的是**对象**。对于实例方法，保护的是当前实例对象 this，而对于静态方法，保护的是**类对象**。即 StaticCounter.class。每个对象都有一个锁与等待队列，类对象也不例外。

synchronized 静态方法和 synchronized 实例方法保护的是不同的对象，不同的两个线程可以一个执行 synchronized 静态方法，另一个执行 synchronized  实例方法。

```java
public class StaticCounter {
    private static int count = 0;
    public static synchronized void incr() {
        count ++;
    }
}
```

##### 3. 同步一个类

```java
public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
```

作用于**整个类**，也就是说两个线程调用同一个类的**不同对象**上的这种同步语句，也会进行同步。

```java
public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
```

```java
public static void main(String[] args) {
    // 由于是锁住整个类 所以两个不同对象也需要等待
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func2());
    executorService.execute(() -> e2.func2());
}
```

```html
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

#### synchronized 的特性

##### 可重入性

synchronized 是可重入的，即同一个执行线程，它获得了锁之后，可以直接调用其他需要同样锁的代码，无需等待。如在一个 synchronized 实例方法内可以直接调用其他 synchronized 实例方法。

可重入是通过记录锁的持有线程和持有数量来实现的。

##### 内存可见性

synchronized 可以实现原子操作，避免出现竞态条件。同时还可以解决内存可见性问题，在释放锁时，所有的写入都会写回内存，获得锁后，都会从内存读取最新数据。

如果只是为了保证内存可见性，使用 synchronized 成本有点高，可以使用轻量级的 volatile 关键字，但是不能解决竞态条件的问题。

```java
private volatile boolean switch = false;
```

##### 死锁

应该避免在持有一个锁的同时去申请另一个锁，如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。

可以使用显示锁 Lock 的方式来解决部分死锁问题，它支持尝试获取锁和带时间限制的获取锁方法，使用这些方法可以在获取不到锁的时候放弃已经持有的锁。

##### 同步容器

类 Collections 中有一些方法可以返回线程安全的**同步容器**（不是并发容器）。它是给所有容器方法都加上 **synchronized** 关键字实现的。

但是给所有的方法加 synchronized 关键词时所有的方法必须使用**相同的锁**（），不然可能造成伪同步的问题。

同步容器的单个操作是安全的，但是**迭代操作不是**。如果在遍历容器时发生了结构性变化，就会抛出异常。同步容器没有解决这个问题，要避免这个异常，需要在遍历时给整个容器对象加锁。

同步容器不好，可以使用并发容器。并发容器都是线程安全的，且没有使用 synchronized 关键字，且没有迭代问题，直接支持一些复合操作。



### 线程协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协作。基本场景有：

- 生产者、消费者模式
- 同时开始
- 等待结束
- 异步结果
- 集合点

#### join()

在线程中调用另一个线程的 join() 方法，会将当前线程**挂起**，而不是忙等待，直到目标线程结束。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```java
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```

```java
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
```

```
A
B
```

------

#### wait() notify() notifyAll()

调用 wait() 使得线程等待**某个条件满足**，线程在等待时会被挂起，当**其他线程**的运行使得这个条件满足时，其它线程会调用 **notify() 或者 notifyAll()** 来唤醒挂起的线程。

它们都属于 **Object** 的一部分，而不属于 Thread，**每个对象**都具有上述方法。

wait() notify() 方法只能用在同步方法或者同步控制块中使用，即在 **synchronized 代码块内**部使用，否则会在运行时抛出 IllegalMonitorStateException。

使用 wait() 挂起期间，线程会**释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

除了用于锁的等待队列，每个对象还有一个另一个等待队列，表示**条件队列**，该队列用于线程间的协作。

```java
public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println("before");
        // 唤醒
        notifyAll();
    }

    public synchronized void after() {
        try {
            // 等待
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after");
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```html
before
after
```

wait 的具体过程是：

1、把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变成 WAITING 或 TIMED_WAITING。

2、等待时间到或者被其他线程调用notify/notifyAll 从条件队列中移除，这时需要重新竞争对象锁。如果能获得锁，线程状态变成 RUNNABLE，并从 wait 调用中返回。否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有获得锁后才会从 wait 调用中返回。

一般的调用模式是：

```java
synchronized (obj) {
    while(条件不成立) {
        obj.wait();
        // ...
    }
    // ...
}
```



**wait() 和 sleep() 的区别** 

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会**释放锁**，sleep() 不会。

------

#### await() signal() signalAll()

java.util.concurrent 类库中提供了 **Condition 类**来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

使用 Lock 来获取一个 **Condition 对象**。

```java
public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```html
before
after
```





### 线程的中断

- stop 方法已经过时
- 

一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。

##### InterruptedException

通过调用一个线程的 **interrupt()** 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是**==不能==中断 I/O 阻塞和 synchronized 锁阻塞**。

对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。

```java
public class InterruptExample {

    private static class MyThread1 extends Thread {
        @Override
        public void run() {
            try {
                Thread.sleep(2000);
                System.out.println("Thread run");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread1 = new MyThread1();
    thread1.start();
    thread1.interrupt();
    System.out.println("Main run");
}
```

```html
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
```

------

##### interrupted()

如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。

但是调用 interrupt() 方法会设置线程的**中断标记**，此时调用 interrupted() 方法会返回 true。因此可以在**循环体**中使用 **interrupted()** 方法来判断线程**是否处于中断状态**，从而提前结束线程。

```java
public class InterruptExample {

    private static class MyThread2 extends Thread {
        @Override
        public void run() {
            // 判断中断标志来决定是否退出循环
            while (!interrupted()) {
                // ..
            }
            System.out.println("Thread end");
        }
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread2 = new MyThread2();
    thread2.start();
    thread2.interrupt();	// 设置中断标志位，此时循环中判断中断标志位进而退出
}
```

```html
Thread end
```





## 二、并发包的基石

### Java 内存模型

Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

#### 主内存与工作内存

处理器上的**寄存器**的读写的速度比**内存**快几个数量级，为了解决这种速度矛盾，在它们之间加入了**高速缓存**。

加入高速缓存带来了一个新的问题：**缓存一致性**。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。

![1563602088955](assets/1563602088955.png)

所有的变量都存储在**主内存**中，每个线程还有自己的**工作内存**，工作内存存储在**高速缓存或者寄存器**中，保存了该线程使用的变量的主内存副本拷贝。

**线程**只能直接操作**工作内存**中的变量，不同线程之间的变量**值传递**需要通过**主内存**来完成。

![1563602099409](assets/1563602099409.png)

------

#### 内存间交互操作

Java 内存模型定义了 8 个操作来完成**主内存和工作内存**的交互操作。

![1563602120989](assets/1563602120989.png)

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
- unclock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存，以便随后的load动作使用。
- load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎。
- assign（赋值）：作用于工作内存的变量，把执行引擎接收到的值赋给工作内存的变量。
- store（存储）：作用于工作内存的变量，把工作内存中一个变量的值传送给主内存中，以便随后的write操作使用。write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
- write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。

------

#### 内存模型三大特性

##### 1. 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有**原子性**，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 **load、store、read 和 write** 操作**可以不具备**原子性。

有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

为了方便讨论，将内存间的交互操作简化为 3 个：**load、assign、store**。

下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。**因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。**

![1563602133580](assets/1563602133580.png)

**AtomicInteger** 能保证多个线程修改的原子性。

![1563602145852](assets/1563602145852.png)

使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：

```java
public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```

除了使用原子类之外，也可以使用 **synchronized** 互斥锁来保证操作的**原子性**。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 **monitorenter 和 monitorexit**。

```java
public class AtomicSynchronizedExample {
    private int cnt = 0;
	// 方法加锁
    public synchronized void add() {
        cnt++;
    }

    public synchronized int get() {
        return cnt;
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicSynchronizedExample example = new AtomicSynchronizedExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```

##### 2. 可见性

可见性指当一个线程修改了共享变量的值，其它线程能够**立即得知**这个修改。Java 内存模型是通过在变量修改后**将新值同步回主内存**，在变量**读取前**从主内存**刷新变量值**来实现可见性的。

主要有三种实现可见性的方式：

- ==volatile==，轻量级。仅能保证可见性，不能解决线程不安全问题。
- **synchronized**，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
- **final**，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。

##### 3. 有序性

有序性是指：在**本线程**内观察，所有操作都是**有序**的。在一个线程观察另一个线程，所有操作都是**无序**的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

volatile 关键字通过添加**内存屏障**的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

------

#### 先行发生原则

上面提到了可以用 volatile 和 synchronized 来保证**有序性**。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。

1. **单一线程原则**

> Single Thread rule

在一个线程内，在程序前面的操作先行发生于后面的操作。

![1563602161558](assets/1563602161558.png)

2. **管程锁定规则**

> Monitor Lock Rule

一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。

![1563602169406](assets/1563602169406.png)

  3. **volatile 变量规则**

> Volatile Variable Rule

对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。

![1563602180301](assets/1563602180301.png)

4. **线程启动规则**

> Thread Start Rule

Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。

![1563602189903](assets/1563602189903.png)

5. **线程加入规则**

> Thread Join Rule

Thread 对象的结束先行发生于 join() 方法返回。

![1563602203061](assets/1563602203061.png)

6. **线程中断规则**

> Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

7. **对象终结规则**

> Finalizer Rule

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

8. **传递性**

> Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。





### 原子变量与CAS

原子变量最主要的一个特点就是所有的操作都是**原子**的，synchronized 关键字也可以做到对变量的原子操作。只是 synchronized 的成本相对较高，需要获取锁对象，释放锁对象，如果不能获取到锁，还需要阻塞在阻塞队列上进行等待。而如果单单只是为了解决对**变量的原子操作**，建议使用原子变量。

#### 原子变量的基本概念

​     原子变量保证了该变量的所有操作都是原子的，不会因为多线程的同时访问而导致脏数据的读取问题。我们先看一段 synchronized 关键字保证变量原子性的代码：

```java
public class Counter {
    private int count;

    public synchronized void addCount(){
        this.count++;
    }
}
```

简单的 count++ 操作，线程对象首先需要获取到 Counter 类实例的对象锁，然后完成自增操作，最后释放对象锁。整个过程中，无论是获取锁还是释放锁都是相当**消耗成本**的，一旦不能获取到锁，还需要阻塞当前线程等等。

对于这种情况，我们可以将 count 变量声明成**原子变量**，那么对于 count 的自增操作都可以以**原子的**方式进行，就不存在脏数据的读取了。Java给我们提供了以下几种原子类型：

- AtomicInteger 和 AtomicIntegerArray：基于Integer类型
- AtomicBoolean：基于Boolean类型
- AtomicLong 和 AtomicLongArray：基于Long类型
- AtomicReference 和 AtomicReferenceArray：基于引用类型

以下将主要介绍 AtomicInteger 和 AtomicReference 两种类型，AtomicBoolean  和AtomicLong 的使用和内部实现原理几乎和 AtomicInteger 一样。



#### AtomicInteger

##### AtomicInteger的基本使用

​     首先看它的两个构造函数：

```java
private volatile int value;

public AtomicInteger(int initialValue) {
    value = initialValue;
}
public AtomicInteger() {

}
```

可以看到，我们在通过构造函数构造 AtomicInteger 原子变量的时候，如果指定一个 int 的参数，那么该原子变量的值就会被赋值，否则就是默认的数值 0。

也有获取和设置这个 value 值的方法：

```java
// 非原子操作 用得少
public final int get()
public final void set(int newValue) 
```

当然，这两个方法**并不是原子**的，所以一般也**很少**使用，而以下的这些基于**原子操作的方法**则相对使用的频繁。之所以称为原子变量，是因为它包含一些以原子方式实现组合操作的方法。这些方法**都依赖**于下面讲的 ==CAS== 方法。

```java
// 基于原子操作，获取当前原子变量中的值并为其设置新值
public final int getAndSet(int newValue)
// 基于原子操作，比较当前的value是否等于expect，如果是设置为update并返回true，否则返回false
public final boolean compareAndSet(int expect, int update)
// 基于原子操作，获取当前的value值并自增一
public final int getAndIncrement()
// 基于原子操作，获取当前的value值并自减一
public final int getAndDecrement()
// 基于原子操作，获取当前的value值并为value加上delta
public final int getAndAdd(int delta)
// 还有一些反向的方法，比如：先自增在获取值的等等
```

下面我们实现一个计数器的例子，之前我们使用 synchronized 实现过，现在我们使用原子变量再次实现该问题。

```java
// 自定义一个线程类
public class MyThread extends Thread {
	// 定义一个原子变量
    public static AtomicInteger value = new AtomicInteger();

    @Override
    public void run(){
        try {
            Thread.sleep((long) ((Math.random())*100));
            // 原子自增
            value.incrementAndGet();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
// main函数中启动100条线程并让他们启动
public static void main(String[] args) throws InterruptedException {
    Thread[] threads = new Thread[100];
    for (int i=0;i<100;i++){
        threads[i] = new MyThread();
        threads[i].start();
    }

    for (int j=0;j<100;j++){
        threads[j].join();
    }

    System.out.println("value:"+MyThread.value);
}
```

多次运行会得到相同的结果：

```
value: 100
```



##### AtomicInteger的内部基本原理

​     AtomicInteger的实现原理有点像我们的**包装类**，内部主要操作的是 value 字段，这个字段保存就是原子变量的数值。value字段定义如下：

```java
private volatile int value;
```

首先 value 字段被 volatile 修饰，即**不存在内存可见性问题**。由于其内部实现原子操作的代码几乎类似，我们主要学习下 **incrementAndGet** 方法的实现。

在揭露该方法的实现原理之前，我们先看另一个方法：

```java
// ※ CAS方法
public final boolean compareAndSet(int expect, int update{
     return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

==**compareAndSet** 方法==又被称为 ==CAS==（**比较并设置**），该方法调用 unsave 的一个 compareAndSwapInt 方法，这个方法是native，我们看不到源码，但是我们需要知道该方法完成的一个目标：比较当前原子变量的值**是否等于 expect**，如果是则将其修改为 **update** 并返回 **true**，否则直接返回 false。即如果与期望值相等才更新，否则不更新。当然，这个操作本身就是原子的，较为底层的实现。

在jdk1.7之前，我们的incrementAndGet方法是这样实现的：

```java
public final int incrementAndGet() {
    for (;;) {	// 无限循环
        // 获取当前值
        int current = get();
        // 计算期望的next值
        int next = current + 1;
        // 进行比较
        if (compareAndSet(current, next))
            return next;
    }
}
```

方法体是一个死循环，current 获取到当前原子变量中的值，由于 value 被修饰 volatile，所以不存在内存可见性问题，数据一定是**最新**的。然后 current 加一后赋值给 next，调用 CAS 原子操作判断 value 是否被别的线程修改过，如果还是原来的值，那么将 next 的值赋值给 value 并返回 next，否则重新获取当前 value的值，再次进行判断，**直到操作完成**。

incrementAndGet方法的一个很核心的思想是，在加一之前先去看看 value 的值是多少，**真正加**的时候再去看一下，如果发现变了，不操作数据，否则为value加一。

但是在jdk1.8以后，做了一些**优化**，但是最后还是调用的 **compareAndSwapInt** 方法。但基本思想还是没变。



#### AtomicReference

​     对于一些**自定义类或者字符串**等这些**引用类型**，Java 并发包也提供了原子变量的接口支持。AtomicReference内部使用**泛型**来实现的。

```java
private volatile V value;

public AtomicReference(V initialValue) {
    value = initialValue;
}

public AtomicReference() {

}
```

有关其他的一些原子方法如下：

```java
// 获取并设置value的值为newvalue
public final V getAndSet(V newValue) {
    return (V)unsafe.getAndSetObject(this, valueOffset, newValue);
}
```

AtomicReference 中少了一些自增自减的操作，但是对于 value 的修改依然是原子的。

#### 使用FieldUpdater操作非原子变量的字段属性

FieldUpdater 允许我们**不必**将字段设置为原子变量，利用**反射**直接以**原子方式操作字段**。例如：

```java
// 定义一个计数器
public class Counter {
    private volatile  int count;

    public int getCount() {
        return count;
    }

    public void addCount(){
        AtomicIntegerFieldUpdater<Counter> updater  = AtomicIntegerFieldUpdater.newUpdater(Counter.class,"count");
        updater.getAndIncrement(this);
    }
}
```

然后我们创建一百个线程随机调用同一个Counter对象的addCount方法，无论运行多少次，结果都是一百。这种方式实现的原子操作，对于被操作的变量**不需要**被包装成原子变量，但是却可以直接以原子方式操作它的数值。

#### ABA问题

我们的原子变量都依赖一个核心的方法，那就是 **CAS**。这个方法最核心的思想就是，更改变量值之前先获取该变量当前最新的值，然后在实际更改的时候再次获取该变量的值，如果没有被修改，那么进行更改，否则循环上述操作直至更改操作完成。假如一个线程想要对变量 count 进行修改，实际操作之前获取 count 的值为A，此时来了一个线程将 count 值修改为 B，又来一个线程获取 count 的值为 B 并将 count 修改为 A，此时第一个线程全然不知道 count 的值已经被修改两次了，虽然值还是 A，但是实际上数据已经是脏的。

这就是典型的ABA问题，一个解决办法是，对 count 的每次操作都记录下当前的一个**时间戳**，这样当我们原子操作 count 之前，不仅查看 count 的最新数值，还记录下该 coun t的**时间戳**，在实际操作的时候，只有在 count 的数值和时间戳都没有被更改的情况之下才完成修改操作。

```java
public static void main(String[] args){
    int count = 0;
    int stamp = 1;
    AtomicStampedReference reference = new AtomicStampedReference(count,stamp);
    int next = count++;
    reference.compareAndSet(count, next, stamp, stamp);
}
```

AtomicStampedReference 的 CA S方法要求传入**四个参数**，该方法的内部会同时比较 count 和 stamp，只有这两个值都没有发生改变的前提下，CAS 才会修改 count 的值。

#### 原子变量与 synchronized 比较

从思维模式上看，原子变量代表一种**乐观的非阻塞式**思维，它假定更新冲突比较少，假定没有别人会和我同时操作某个变量，于是在实际修改变量的值的之前不会锁定该变量，但是修改变量的时候是使用CAS进行的，一旦发现冲突，继续尝试直到成功修改该变量。

而 synchronized 关键字则是一种**悲观的阻塞式**思维，它假定先更新很可能冲突，认为所有人都会和自己同时来操作某个变量，于是在将要操作该变量之前会加锁来锁定该变量，得不到锁的时候进入等待队列，因此会有线程切换等开销，进而继续操作该变量。







###  显示锁

#### Lock 接口

`synchronized` 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。这个时候 Lock 出现。

Lock 不是 Java 中的关键字而是 java.util.concurrent.locks 包中的一个接口。下面我们简单介绍一下Lock接口。

`Lock` 实现提供了比使用 `synchronized` 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 `Condition` 对象。

Lock 相对于 synchronized 关键字而言更加灵活，你可以自由得选择想要加锁的地方。当然更高的自由度也带来更多的责任。

我们通常会在 try...catch 模块中使用 lock 关键字，在 finally 模块中**释放锁**。下面是示范代码。

```java
Lock myLock = ...; 
myLock.lock();
try {
    // access the resource protected by this lock
} finally {
    myLock.unlock();
}
```

锁的锁定和释放如果在不同的模块时，需要谨慎编码，确保最后锁一定能够得到**释放**。

**Lock接口中的方法**

```java
// 获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态
void lock() 

// 如果当前线程未被中断，则获取锁。
void lockInterruptibly() 

// 返回绑定到此 Lock 实例的新 Condition 实例。
Condition newCondition() 

// 仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。
boolean tryLock() 

// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。
boolean	tryLock(long time, TimeUnit unit) 

// 释放锁。在等待条件前，锁必须由当前线程保持。调用 Condition.await() 将在等待前以原子方式释放锁，并在等待返回前重新获取锁。
void unlock() 
```

Lock接口有三个实现类分别是**ReentrantLock**,  ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock。后面两个是内部类。



#### ReentrantLock

##### 基本使用

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。

ReentrantLock 的 fair 参数是可以保证公平的，但是保证公平会影响性能，一般也不需要，所以默认不保证，synchronized 锁也是不保证公平的。

使用 **tryLock** 可以避免死锁。它会在持有一个锁 A 获取另一个锁 B 而获取不到 B 的时候，可以释放已持有的锁 A ，给其他线程获取锁 A 的机会，然后重试获取所有锁。

```java
public class LockExample {
	// 定义锁
    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();	// 加锁
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁
        }
    }
}
```

```java
public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> lockExample.func());
    executorService.execute(() -> lockExample.func());
}
```

```html
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

##### 实现原理

###### 公平锁和非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

ReentrantLock 的内部类 **Sync** 继承了AQS，分为公平锁 FairSync 和非公平锁 NonfairSync。

- 公平锁：线程获取锁的顺序和调用 lock 的顺序一样，FIFO；
- 非公平锁：线程获取锁的顺序和调用 lock 的顺序无关，全凭运气。

ReentrantLock 默认使用**非公平锁**是基于性能考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。

###### 公平锁

尝试获取锁，先来看公平锁的实现，lock 方法很简单的一句话调用 AQS的 acquire 方法。

```java
final void lock() { acquire(1);}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

```java
protected boolean tryAcquire(int arg) {    
        throw new UnsupportedOperationException();
}
```

AQS的 tryAcquire 未做具体实现，因为是否获取锁成功是由子类决定的，我们直接来看 ReentrantLock 的tryAcquire 的实现。

```java
protected final boolean tryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
       if (!hasQueuedPredecessors() &&
           compareAndSetState(0, acquires)) {
           setExclusiveOwnerThread(current);
           return true;
       }
   }
   else if (current == getExclusiveOwnerThread()) {
       int nextc = c + acquires;
       if (nextc < 0)
           throw new Error("Maximum lock count exceeded");
       setState(nextc);
       return true;
   }
   return false;
}
```

获取锁成功分为两种情况，第一个 if 判断 AQS 的 state 是否等于 0，表示锁没有人占有。接着，hasQueuedPredecessors 判断队列是否有排在前面的线程在等待锁，没有的话调用 compareAndSetState 使用 CAS 的方式修改 state，传入的 acquires 写死是1。最后线程获取锁成功，setExclusiveOwnerThread 将线程记录为独占锁的线程。

第二个 if 判断当前线程是否为独占锁的线程，因为ReentrantLock是**可重入**的，线程可以不停地 lock 来增加 state的值，对应地需要 unlock 来解锁，直到 state 为零。

如果最后获取锁失败，下一步需要将线程加入到等待队列。

###### 线程进入等待队列

AQS 内部有一条**双向队列**存放等待线程，节点是 Node 对象。每个 Node 维护了线程、前后 Node 的指针和等待状态等参数。

线程在加入队列之前，需要包装进 Node，调用方法是 addWaiter：

```java
private Node addWaiter(Node mode) {
   Node node = new Node(Thread.currentThread(), mode);
   // Try the fast path of enq; backup to full enq on failure
   Node pred = tail;
   if (pred != null) {
       node.prev = pred;
       if (compareAndSetTail(pred, node)) {
           pred.next = node;
           return node;
       }
   }
   enq(node);
   return node;
}
```

每个 Node 需要标记是独占的还是共享的，由传入的 mode 决定，ReentrantLock 自然是使用独占模式Node.EXCLUSIVE。

创建好 Node 后，如果队列不为空，使用 CAS 的方式将 Node 加入到队**列尾**。注意，这里只执行了一次修改操作，并且可能因为并发的原因失败。因此修改失败的情况和队列为空的情况，需要进入enq。

```java
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

enq是个死循环，保证 Node 一定能插入队列。注意到，当队列为空时，会先为头节点创建一个空的 Node，因为头节点代表获取了锁的线程，现在还没有，所以先空着。

###### 阻塞等待线程

线程加入队列后，下一步是调用 acquireQueued 阻塞线程。

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // 1
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 2
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

标记 1 是线程唤醒后尝试获取锁的过程。如果前一个节点正好是 head，表示自己排在第一位，可以马上调用tryAcquire 尝试。如果获取成功就简单了，直接修改自己为 head。这步是实现公平锁的**核心**，保证释放锁时，由下个排队线程获取锁。（看到线程解锁时，再看回这里）

标记 2 是线程获取锁失败的处理。这个时候，线程可能等着下一次获取，也可能不想要了，Node 变量 waitState描述了线程的等待状态，一共四种情况：

```java
static final int CANCELLED =  1;   	// 取消
static final int SIGNAL    = -1;    // 下个节点需要被唤醒
static final int CONDITION = -2;  	// 线程在等待条件触发
static final int PROPAGATE = -3; 	//（共享锁）状态需要向后传播
```

shouldParkAfterFailedAcquire 传入当前节点和前节点，根据前节点的状态，判断线程是否需要阻塞。

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
      return true;
  if (ws > 0) {
      do {
          node.prev = pred = pred.prev;
      } while (pred.waitStatus > 0);
      pred.next = node;
  } else {
      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
}
```

- 前节点状态是 SIGNAL 时，当前线程需要阻塞；
- 前节点状态是 CANCELLED 时，通过循环将当前节点之前所有取消状态的节点移出队列；
- 前节点状态是其他状态时，需要设置前节点为 SIGNAL。

如果线程需要阻塞，由 parkAndCheckInterrupt 方法进行操作。

```java
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
```

parkAndCheckInterrupt 使用了 LockSupport，和 CAS 一样，最终使用 UNSAFE 调用 Native 方法实现线程阻塞（LockSupport 的 park 和 unpark 方法作用类似于 wait 和 notify ）。最后返回线程唤醒后的中断状态，关于中断，后文会分析。

到这里总结一下获取锁的过程：==线程去竞争一个锁，可能成功也可能失败。成功就直接持有资源，不需要进入队列；失败的话进入队列阻塞，等待唤醒后再尝试竞争锁==。

###### 释放锁

通过上面详细的获取锁过程分析，释放锁过程大概可以猜到：头节点是获取锁的线程，先移出队列，再通知后面的节点获取锁。

```java
public void unlock() {
    sync.release(1);
}
```

ReentrantLock 的 unlock 方法很简单地调用了 AQS 的 release：

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

和 lock 的 tryAcquire 一样，unlock 的 tryRelease 同样由 ReentrantLock 实现：

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

因为锁是可以重入的，所以每次 lock 会让 state 加 1，对应地每次 unlock 要让 state 减 1，直到为 0 时将独占线程变量设置为空，返回标记是否彻底释放锁。

最后，调用 unparkSuccessor 将头节点的下个节点唤醒：

```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

寻找下个待唤醒的线程是从队列尾向前查询的，找到线程后调用 LockSupport 的 unpark 方法唤醒线程。被唤醒的线程重新执行 acquireQueued 里的循环，就是上文关于 acquireQueued 标记 1 部分，线程重新尝试获取锁。

###### 中断锁

```java
static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```

在 acquire 里还有最后一句代码调用了 selfInterrupt，功能很简单，对当前线程产生一个中断请求。

为什么要这样操作呢？因为 LockSupport.park 阻塞线程后，有两种可能被唤醒。

1、第一种情况，前节点是头节点，释放锁后，会调用 LockSupport.unpark 唤醒当前线程。整个过程没有涉及到中断，最终 acquireQueued 返回 false 时，不需要调用 selfInterrupt。

2、第二种情况，LockSupport.park 支持响应中断请求，能够被其他线程通过 interrupt() 唤醒。但这种唤醒并没有用，因为线程前面可能还有等待线程，在 acquireQueued 的循环里，线程会再次被阻塞。parkAndCheckInterrupt 返回的是 Thread.interrupted()，不仅返回中断状态，还会清除中断状态，保证阻塞线程忽略中断。最终 acquireQueued 返回 true 时，真正的中断状态已经被清除，需要调用 selfInterrupt 维持中断状态。

因此普通的 lock 方法并不能被其他线程中断，ReentrantLock 是可以支持中断，需要使用 lockInterruptibly。

两者的逻辑基本一样，不同之处是 parkAndCheckInterrupt 返回 true 时，lockInterruptibly 直接throw new InterruptedException()。

###### 非公平锁

分析完公平锁的实现，还剩下非公平锁，主要区别是**获取锁的过程**不同。

```java
final void lock() {
    if (compareAndSetState(0, 1)) //如果一开始未上锁，直接抢占锁
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

在 NonfairSync 的 lock 方法里，第一步直接尝试将 state 修改为 1，很明显，这是抢先获取锁的过程。如果修改state 失败，则和公平锁一样，调用 acquire。

```java
final boolean nonfairTryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
      if (compareAndSetState(0, acquires)) {
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
      int nextc = c + acquires;
      if (nextc < 0) // overflow
          throw new Error("Maximum lock count exceeded");
      setState(nextc);
      return true;
  }
  return false;
}
```

nonfairTryAcquire 和 tryAcquire 乍一看几乎一样，差异只是缺少调用 hasQueuedPredecessors。这点体验出公平锁和非公平锁的不同，公平锁会关注队列里排队的情况，老老实实按照 FIFO 的次序；非公平锁只要有机会就抢占，才不管排队的事。



#### synchronized 与 ReentrantLock 比较

**使用选择**

除非需要使用 ReentrantLock 的高级功能，否则**优先使用 synchronized**。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会**确保锁的释放**。

1. **锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

2. **性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。能用 synchronized 尽量用。

3. **等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock **可中断**，而 synchronized 不行。

4. **公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

5. **锁绑定多个条件**

一个 ReentrantLock 可以同时绑定**多个** Condition 对象。























## 三、并发容器

### CopyOnWriteArrayList

#### 概述

- 实现了 List 接口，与其他 List 实现类用法类似。
- 是线程安全的，可以被多个线程并发访问。
- 它的迭代器不支持修改操作，但也不会抛出 ConcurrentModificationException。迭代时不需要像同步容器那边对整个列表对象加锁。
- 它以原子方式支持一些复合操作。

#### 适用场景

CopyOnWriteArrayList 在写操作的**同时**允许读操作，大大提高了读操作的性能，因此很适合**读多写少**的应用场景，不适合数组很大且需要频繁修改的场景，它是以优化读为目标的。

但是 CopyOnWriteArrayList 有其缺陷：

- 内存占用：在写操作时需要复制一个**新的数组**，使得内存占用为原来的**两倍**左右；
- 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还**未同步**到读数组中。

所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。

#### 原理分析

重要的成员属性。

```java
/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

// 存放元素 volatile保证内存可见性
private transient volatile Object[] array;
```

可以看到，CopyOnWriteArrayList 使用了 ReentrantLock 来支持并发操作，array 就是实际存放数据的数组对象。ReentrantLock 是一种支持重入的独占锁，任意时刻只允许一个线程获得锁，所以可以安全的并发去写数组



**读写分离**

**写操作**在一个**复制的数组**上进行，**读操作**还是在**原始数组**中进行，读写分离，互不影响。

**写**操作需要加**锁**，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组**指向**新的复制数组。读不需要锁，可以并行，读写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;	// 加锁
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();		// 释放锁
    }
}

// 修改内部数组引用
final void setArray(Object[] a) {
    array = a;
}
```

```java
@SuppressWarnings("unchecked")	
private E get(Object[] a, int index) {	// 直接读 可以并行
    return (E) a[index];
}
```

每次修改操作，都会创建一个数组，复制原数组的内容到新数组，在新数组上进行修改，然后以原子方式设置内部的数组引用，这就是写时复制。换句话说，数组内容是**只读**的，写操作都是通过新建数组，然后**原子性**的修改数组引用来实现的。

#### CopyOnWriteArraySet

- 实现了 Set 接口，不包含重复元素。
- 内部通过 CopyOnWriteArrayList 实现，性能较低，不适用于元素个数很多的结合。如果元素较多可以考虑 ConcurrentHashMap 或 ConcurrentSkipListSet 这两个类。





### ※ ConcurrentHashMap

#### 概述

**特点**

- 并发安全，支持高并发，读操作完全并行，写操作一定程度并行。
- 直接支持一些原子复合操作
- 与同步容器相比，迭代不需要加锁
- 若一致性

**为何使用**

并发更新情况下，HashMap 可能出现死循环，多出现在多个线程同时扩容哈希表的时候，占满 CPU。Collections.synchronizedMap 可以生成一个同步容器可以避免死循环，但是同步容器有几个问题：

1、每个方法都需要同步，并发度较低。

2、对于迭代和复合操作，需要调用方加锁。

ConcurrentHashMap 则没有上述的问题。同样实现了 Map 接口，也是基于哈希表实现。



#### 1. 存储结构

```java
static final class HashEntry<K,V> {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry<K,V> next;
}
```

ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了==分段锁（Segment）==，每个分段锁维护着**几个桶**（HashEntry），多个线程可以同时访问**不同分段锁**上的桶，从而使其并发度更高（并发度就是 **Segment 的个数**）。将数据分为多个段，每个段有一个独立的锁，每个段相当于一个独立的哈希表。

采用分段技术，可以大大提高并发度，多个段之间可以并行读写。默认端是 16 个。实现的效果是对于读操作可以并行，对于写操作需要获取锁，不能并行。

Segment 继承自 **ReentrantLock**。具有显示锁的一些机制。

```java
static final class Segment<K,V> extends ReentrantLock implements Serializable {

    private static final long serialVersionUID = 2249069246763182397L;

    static final int MAX_SCAN_RETRIES =
        Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

    transient volatile HashEntry<K,V>[] table;

    transient int count;

    transient int modCount;

    transient int threshold;

    final float loadFactor;
}
```

```java
final Segment<K,V>[] segments;
```

默认的并发级别为 16，也就是说默认创建 **16 个** Segment。

```java
static final int DEFAULT_CONCURRENCY_LEVEL = 16;
```

![1563604891272](assets/1563604891272.png)

#### 2. size 操作

每个 Segment 维护了一个 count 变量来统计该 Segment 中的**键值对个数**。

```java
/**
 * The number of elements. Accessed only either within locks
 * or among other volatile reads that maintain visibility.
 */
transient int count;
```

在执行 size 操作时，需要遍历所有 Segment 然后把 count **累计**起来。

ConcurrentHashMap 在执行 size 操作时**先尝试不加锁**，如果连续两次不加锁操作得到的**结果一致**，那么可以认为这个结果是正确的。

**尝试次数**使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。

如果尝试的次数**超过 3 次**，就需要对**每个 Segment 加锁**。

```java
/**
 * Number of unsynchronized retries in size and containsValue
 * methods before resorting to locking. This is used to avoid
 * unbounded retries if tables undergo continuous modification
 * which would make it impossible to obtain an accurate result.
 */
static final int RETRIES_BEFORE_LOCK = 2;

public int size() {
    // Try a few times to get accurate count. On failure due to
    // continuous async changes in table, resort to locking.
    final Segment<K,V>[] segments = this.segments;
    int size;
    boolean overflow; // true if size overflows 32 bits
    long sum;         // sum of modCounts
    long last = 0L;   // previous sum
    int retries = -1; // first iteration isn't retry
    try {
        for (;;) {
            // 超过尝试次数，则对每个 Segment 加锁
            if (retries++ == RETRIES_BEFORE_LOCK) {
                for (int j = 0; j < segments.length; ++j)
                    ensureSegment(j).lock(); // force creation
            }
            sum = 0L;
            size = 0;
            overflow = false;
            for (int j = 0; j < segments.length; ++j) {
                Segment<K,V> seg = segmentAt(segments, j);
                if (seg != null) {
                    sum += seg.modCount;
                    int c = seg.count;
                    if (c < 0 || (size += c) < 0)
                        overflow = true;
                }
            }
            // 连续两次得到的结果一致，则认为这个结果是正确的
            if (sum == last)
                break;
            last = sum;
        }
    } finally {
        if (retries > RETRIES_BEFORE_LOCK) {
            for (int j = 0; j < segments.length; ++j)
                segmentAt(segments, j).unlock();
        }
    }
    return overflow ? Integer.MAX_VALUE : size;
}
```

#### 3. JDK 1.8 的改动

JDK 1.7 使用**分段锁机制**来实现并发更新操作，核心类为 **Segment**，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。

JDK 1.8 使用了 **==CAS 操作==**来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。

并且 JDK 1.8 的实现也在链表过长时会转换为**红黑树**。



#### 弱一致性

ConcurrentHaspMap 迭代器创建之后，就会按照哈希表结构遍历读取每个元素，但在遍历过程中，内部元素可能会因为其他线程的写入修改发生变化，如果变化发生在已遍历的部分，迭代器就不会反映出来，而如果变化部分发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。

------

#### ConcurrentHaspMap面试题

**Q：针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）？**

**JDK 1.7** 中，采用**分段锁**的机制，实现并发的更新操作，底层采用**数组+链表**的存储结构，包括两个核心静态内部类 **Segment 和 HashEntry**。
 ①、**Segment** 继承 **ReentrantLock（重入锁）** 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；
 ②、HashEntry 用来封装映射表的键-值对；
 ③、每个桶是由若干个 HashEntry 对象链接起来的链表。

![1567085163626](assets/1567085163626.png)

**JDK 1.8** 中，采用Node + CAS + Synchronized来保证并发安全。**取消类 Segment**，直接用 **table 数组**存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，**链表转换为红黑树**，提升性能。底层变更为**数组 + 链表 + 红黑树**。

![1567085202643](assets/1567085202643.png)

**Q：ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？**

A：①、**粒度降低了**；
 ②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized **优化空间更大**，更加自然。
 ③、在大量的数据操作下，对于 JVM 的内存压力，基于 API  的 **ReentrantLock 会开销更多的内存**。

**Q：ConcurrentHashMap 简单介绍？**

A：
 ①、重要的常量：
 private transient volatile int **sizeCtl**;
 当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；
 当为 0 时，表示 table 还没有初始化；
 当为其他正数时，表示初始化或者下一次进行扩容的大小。

②、数据结构：
 **Node 是存储结构的基本单元**，继承 HashMap 中的 Entry，用于**存储数据**；
 **TreeNode 继承 Node**，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于**红黑树中存储数据**；
 **TreeBin 是封装 TreeNode 的容器**，提供转换红黑树的**一些条件和锁的控制**。

③、**存储对象**时（**put()** 方法）：
 1.如果没有初始化，就调用 initTable() 方法来进行**初始化**；
 2.如果没有 hash 冲突就直接 **CAS 无锁插入**；
 3.如果需要扩容，就先进行**扩容**；
 4.如果存在 hash 冲突，就**加锁**来保证线程安全，两种情况：一种是链表形式就直接遍历到**尾端插入**，一种是红黑树就按照红黑树结构插入；
 5.如果该链表的数量大于阀值 8，就要先**转换成红黑树**的结构，break 再一次进入循环
 6.如果添加成功就调用 **addCount() 方法统计 size**，并且**检查是否需要扩容**。

④、**扩容方法 transfer()**：默认容量为 **16**，扩容时，容量变为原来的**两倍**。
 helpTransfer()：调用**多个工作线程**一起帮助进行扩容，这样的效率就会更高。

⑤、**获取对象**时（**get()**方法）：
 1.**计算 hash 值**，定位到该 table 索引位置，如果是首结点符合就返回；
 2.如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；
 3.以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。

**Q：ConcurrentHashMap 的并发度是什么？**

A：程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）





### ConcurrentSkipListMap

#### 概述

- ConcurrentSkipListMap 是基于 SkipList 实现的，SkipList 称为跳表。



特点

- 没有使用锁，所有操作都是无阻塞的，所有操作都可以并行，包括写，多线程可以同时写。
- 与 ConcurrentHashMap 类似，迭代器不会抛出 ConcurrentModificationException，是弱一致性的，迭代可能反映最新修改也可能不反映。
- 实现了 ConcurrentMap 接口，支持一些原子复合操作。
- 与 TreeMap 一样可以排序，默认安装键的自然排序，也可以按照自定义比较器进行排序。



#### 原理分析

跳表是基于链表的，在链表的基础上增加了多层索引结构。

![1567572194703](assets/1567572194703.png)

最下面一层是最基本的单向链表，这是一个有序的链表。但是链表不能进行直接定位，所以不能进行二分查找。所以为了快速查找，使用了多层索引，高层的索引节点一定同时是底层的索引节点。每个索引节点有两个指针，一个向右指向统同层的索引节点，另一个向下指向下一层的索引节点或者基本链表节点。

基于上述结构就可以进行二分查找了。复杂度是O(logN)。



### 并发队列

都继承自 Queue。

#### ConcurrentLinkedQueue

##### 定义

**ConcurrentLinkedQueue** : 是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常 ConcurrentLinkedQueue 性能好于 BlockingQueue。 
它是一个基于链接节点的**无界线程安全队列**，该队列的元素遵循**先进先出**的原则。 **头是最先加入的，尾是最近加入的，该队列不允许null元素。**

ConcurrentLinkedQueue重要方法:

> **add 和offer()** ：都是加入元素的方法(在ConcurrentLinkedQueue中这俩个方法没有任何区别) 
> **poll() 和peek()** ：都是取头元素节点，区别在于前者会删除元素，后者不会。

**代码示例**

```java
ConcurrentLinkedQueue q = new ConcurrentLinkedQueue();
q.offer("张三");
q.offer("李四");
q.offer("王五");
q.offer("赵六");
q.offer("大圣");
// 从头获取元素,删除该元素
System.out.println(q.poll());
// 从头获取元素,不刪除该元素
System.out.println(q.peek());
// 获取总长度
System.out.println(q.size());
```



#### BlockingQueue

**定义：** 
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是： 
1、在队列为空时，获取元素的线程会等待队列变为非空。 
2、当队列满时，存储元素的线程会等待队列可用。 
阻塞队列是**线程安全**的。 

![1567574279225](assets/1567574279225.png)**用途：** 
阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

| operation | Throws Exception | Special Value | Blocks |          Times Out          |
| :-------: | :--------------: | :-----------: | :----: | :-------------------------: |
|  Insert   |      add(o)      |   offer(o)    | put(o) | offer(o, timeout, timeunit) |
|  Remove   |    remove(o)     |    poll()     | take() |   poll(timeout, timeunit)   |
|  Examine  |    element()     |    peek()     |        |                             |

四种不同行为的含义如下：

- 1.抛异常
    如果尝试操作是不可能的，一个异常将会抛出。
- 2.特殊值
    如果尝试操作是不可能的，一个特殊值将返回（通常是true/false）
- 3.阻塞
    如果尝试操作是不可能的，方法将会阻塞住，直到可以执行。
- 4.超时
    如果尝试操作是不可能的，方法将会阻塞住，直到可以执行，但是阻塞不会超过给定的时间。并且返回一个特定的值来表示操作是否成功（一般是true/false）。

java.util.concurrent.BlockingQueue 接口有以下**阻塞队列**的实现：

- **FIFO 队列** ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）
- **优先级队列** ：PriorityBlockingQueue

提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将**阻塞**，**直到**队列中有内容；如果队列为满 put() 将**阻塞**，直到队列有空闲位置。



##### 1、ArrayBlockingQueue

**重要方法：** 

```java
// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出IllegalStateException
add(E e) 
// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false
offer(E e)
// 将指定的元素插入此队列的尾部，如果该队列已满，则在到达指定的等待时间之前等待可用的空间
offer(E e, long timeout, TimeUnit unit)
```

**定义：**

ArrayBlockingQueue是一个**有边界**的阻塞队列，它的内部实现是一个数组。 有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。 
ArrayBlockingQueue是以**先进先出**的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。

下面是一个初始化和使用ArrayBlockingQueue的例子：

```java
// 初始化3个队列
ArrayBlockingQueue array = new ArrayBlockingQueue(3);
array.add("张三");
array.add("李四");
array.add("大圣");
// 添加阻塞队列
boolean a=array.offer("王五",1, TimeUnit.SECONDS);
System.out.println(a);
// 运行结果：false
```



##### 2、LinkedBlockingQueue

**定义：**

LinkedBlockingQueue 阻塞队列大小的配置是可选的， 如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。 说是无边界，其实是采用了默认大小为Integer.MAX_VALUE的容量 。它的内部实现是一个链表。 和 ArrayBlockingQueue 一样，LinkedBlockingQueue 也是以**先进先出**的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。

下面是一个初始化和使LinkedBlockingQueue的例子：

```java
// 初始化
LinkedBlockingQueue lbq = new LinkedBlockingQueue(3);
lbq.add("张三");
lbq.add("李四");
lbq.add("李四");
System.out.println(lbq.size());
// 运行结果：3
```



##### 3、PriorityBlockingQueue

**定义：**

PriorityBlockingQueue 是一个**没有边界**的队列，它的排序规则和 java.util.PriorityQueue 一样。需要注意，PriorityBlockingQueue 中**允许插入null**对象。 
所有插入 PriorityBlockingQueue 的对象必须实现  java.lang.Comparable 接口，队列**优先级**的排序规则就是按照我们对这个接口的实现来定义的。 
另外，我们可以从 PriorityBlockingQueue 获得一个迭代器 Iterator，但这个迭代器并不保证按照优先级顺序进行迭代。

PriorityBlockingQueue 实现了BlockingQueue 接口，在队列为空时，take 方法会阻塞等待。



##### 4、SynchronousQueue

**定义：**

SynchronousQueue 队列内部**仅允许容纳一个元素**。当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。



#### 使用 BlockingQueue 模拟生产者与消费者

生产者：

```java
public class ProducerThread implements Runnable {
    private BlockingQueue queue;
    private volatile boolean flag = true;
    private static AtomicInteger count = new AtomicInteger();
 
    public ProducerThread(BlockingQueue queue) {
        this.queue = queue;
    }
 
    @Override
    public void run() {
        try {
            System.out.println("生产线程启动...");
            while (flag) {
                System.out.println("正在生产数据....");
                String data = count.incrementAndGet()+"";
                // 将数据存入队列中
                boolean offer = queue.offer(data, 2, TimeUnit.SECONDS);
                if (offer) {
                    System.out.println("生产者,存入" + data + "到队列中,成功.");
                } else {
                    System.out.println("生产者,存入" + data + "到队列中,失败.");
                }
                Thread.sleep(1000);
            }
        } catch (Exception e) {
 
        } finally {
            System.out.println("生产者退出线程");
        }
 
    }
    public void stopThread() {
        this.flag = false;
    }
}
```

消费者：

```java
class ConsumerThread implements Runnable {
    private BlockingQueue<String> queue;
    private volatile boolean flag = true;
 
    public ConsumerThread(BlockingQueue<String> queue) {
        this.queue = queue;
 
    }
 
    @Override
    public void run() {
        System.out.println("消费线程启动...");
        try {
            while (flag) {
                System.out.println("消费者,正在从队列中获取数据..");
                String data = queue.poll(2, TimeUnit.SECONDS);
                if (data != null) {
                    System.out.println("消费者,拿到队列中的数据data:" + data);
                    Thread.sleep(1000);
                } else {
                    System.out.println("消费者,超过2秒未获取到数据..");
                    flag = false;
                }
 
 
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("消费者退出线程...");
        }
    }
}
```

运行：

```java
public class ProducerAndConsumer {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> queue = new LinkedBlockingQueue<String>(10);
        ProducerThread producerThread1 = new ProducerThread(queue);
        ProducerThread producerThread2 = new ProducerThread(queue);
        ConsumerThread consumerThread1 = new ConsumerThread(queue);
        Thread t1 = new Thread(producerThread1);
        Thread t2 = new Thread(producerThread2);
        Thread c1 = new Thread(consumerThread1);
        t1.start();
        t2.start();
        c1.start();
        // 执行2s后，生产者不再生产
        Thread.sleep(2* 1000);
        producerThread1.stopThread();
        producerThread2.stopThread();
    }
}
```











## 四、异步执行任务

### Executors 框架

Executor 管理**多个异步任务**的执行，而无需程序员显式地管理线程的**生命周期**。这里的异步是指多个任务的执行互不干扰，**不需要进行同步**操作。

 Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。

Executor接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务，任务即一个实现了 Runnable 接口的类。

ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如 ExecutorService 提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 **Future** 的方法。 

 Executors 提供了一系列工厂方法用于**创建线程池**，返回的线程池都实现了 ExecutorService 接口。   

```java
public static ExecutorService newFixedThreadPool(int nThreads);
// 
public static ExecutorService newCachedThreadPool();
// 
public static ExecutorService newSingleThreadExecutor();
// 创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize);
```

 这四种方法都是用的 Executors 中的 ThreadFactory 建立的线程。

#### 创建线程池

##### newFixedThreadPool

创建固定数目线程的线程池，使用固定数目 nThreads 个线程，使用**无界队列 LinkedBlockingQueue**，线程创建后不会超时终止，由于是无界队列，如果排队任务过多，可能消耗过多**内存**。

`newFixedThreadPool`方法簇用于创建固定线程数的`ThreadPoolExecutor`线程池。包括两个构造方法：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory);
}
```

各构造参数总结：

1. 核心线程数与最大线程数`nThreads`：构建的`ThreadPoolExecutor`核心线程数与最大线程数相等且均为`nThreads`，这说明当前线程池不会存在非核心线程，即不会存在线程的回收（`allowCoreThreadTimeOut`默认为`false`），随着任务的提交，线程数增加到`nThreads`个后就不会变化；
2. 存活时间为0：线程存在非核心线程，该时间没有特殊效果；
3. 等待队列`LinkedBlockingQueue`：该等待队列为`LinkedBlockingQueue`类型，没有长度限制；
4. `ThreadFactory`参数：默认为DefaultThreadFactory，也可通过构造函数设置。

##### newCachedThreadPool

使用的队列是 **SynchronousQueue** 创建一个可缓存的线程池，调用 execute 将重用以前构造的线程（如果线程空闲可用），如果现有线程没有可用的，则创建一个**新线程**并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。其 corePoolSize 是 0，maximumPoolSize 是 Integer.MAX_VALUE，keepAliveTime 是60秒。因此可以创建的线程数量是没有限制的。

`newCachedThreadPool`方法簇用于创建可缓存任务的`ThreadPoolExecutor`线程池。包括两个重构方法：

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>(),
                                    threadFactory);
}
```

结合上文分析的`ThreadPoolExecutor`各构造参数，可总结如下：

1. 核心线程数为0：没有核心线程，即在没有任务运行时所有线程均会被回收；
2. 最大线程数为`Integer.MAX_VALUE`，即线程池中最大可存在的线程为`Integer.MAX_VALUE`，由于此值在通常情况下远远大于系统可新建的线程数，可简单理解为此线程池不限制最大可建的线程数，此处可出现逻辑风险，在提交任务时可能由于超过系统处理能力造成无法再新建线程时会出现OOM异常，提示无法创建新的线程；
3. 存活时间60秒：线程数量超过核心线程后，空闲60秒的线程将会被回收，根据第一条可知核心线程数为0，则本条表示所有线程空闲超过60秒均会被回收；
4. 等待队列`SynchronousQueue`：构建`CachedThreadPool`时，使用的等待队列为`SynchronousQueue`类型，此类型的等待队列较为特殊，可认为这是一个容量为0的阻塞队列，在调用其`offer`方法时，如当前有消费者正在等待获取元素，则返回`true`，否则返回`false`。使用此等待队列可做到快速提交任务到空闲线程，没有空闲线程时触发新建线程；
5. `ThreadFactory`参数：默认为`DefaultThreadFactory`，也可通过构造函数设置。



##### newSingleThreadExecutor

只使用一个线程，使用无界队列 LinkedBlockingQueue，线程创建后不会超时终止，该线程顺序执行所有任务，适用于需要确保所有任务被顺序执行的场景。

`newSingleThreadExecutor`方法簇用于创建只包含一个线程的线程池。包括两个构造方法：

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

结合上文分析的`ThreadPoolExecutor`各构造参数，可总结如下：

1. 核心线程数与最大线程数1:当前线程池中有且仅有一个核心线程；
2. 存活时间为0：当前线程池不存在非核心线程，不会存在线程的超时回收；
3. 等待队列`LinkedBlockingQueue`：该等待队列为`LinkedBlockingQueue`类型，没有长度限制；
4. `ThreadFactory`参数：默认为DefaultThreadFactory，也可通过构造函数设置。



##### **比较**

当系统负载不太高时，单个任务执行的时间也短的话，newCachedThreadPool 效率可能更高，因为任务不需要排队，直接交给一个空闲线程进行处理。

系统负载很高时，newFixedThreadPool 可以通过队列对新任务排队，保证有足够的资源处理实际的任务，而newSingleThreadExecutor 则会为每个任务创建一个线程，导致创建过多的线程竞争 CPU 和内存资源，这时候使用newFixedThreadPool 较为合理。

系统负载极高时，newFixedThreadPool 和 newCachedThreadPool 都不是很好的选择，newFixedThreadPool 的问题是任务**队列过长**，newCachedThreadPool 的问题是创建**线程过多**。这时候应该根据情况自定义 ThreadPoolExecutor，传递合适的参数。

`Executors`工具类创建常见线程池的方法，现对三种线程池区别进行比较。

|     线程池类型     |                  CachedThreadPool                  |             FixedThreadPool              |                     SingleThreadExecutor                     |
| :----------------: | :------------------------------------------------: | :--------------------------------------: | :----------------------------------------------------------: |
|     核心线程数     |                         0                          |          `nThreads`（用户设定）          |                              1                               |
|     最大线程数     |                 Integer.MAX_VALUE                  |          `nThreads`（用户设定）          |                              1                               |
| 非核心线程存活时间 |                        60s                         |               无非核心线程               |                         无非核心线程                         |
|  等待队列最大长度  |                         1                          |                  无限制                  |                            无限制                            |
|        特点        | 提交任务优先复用空闲线程，没有空闲线程则创建新线程 | 固定线程数，等待运行的任务均放入等待队列 | 有且仅有一个线程在运行，等待运行任务放入等待队列，可保证任务运行顺序与提交顺序一直 |
|      内存溢出      |     大量提交任务后，可能出现无法创建线程的OOM      |  大量提交任务后，可能出现内存不足的OOM   |            大量提交任务后，可能出现内存不足的OOM             |



##### 三种类型的线程池与GC关系

**原理说明**

一般情况下 JVM 中的 GC 根据可达性分析确认一个对象是否可被回收(eligible for GC)，而在运行的线程被视为 ‘GCRoot’。因此被在运行的线程引用的对象是不会被 GC 回收的。在`ThreadPoolExecutor`类中具有非静态内部类`Worker`，用于表示当前线程池中的线程，并且根据[Java语言规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.1.3)`An instance i of a direct inner class C of a class or interface O is associated with an instance of O, known as the immediately enclosing instance of i. The immediately enclosing instance of an object, if any, is determined when the object is created (§15.9.2).`可知非静态内部类对象具有外部包装类对象的引用（此处也可通过查看字节码来验证），因此`Worker`类的对象即作为线程对象（‘GCRoot’）有持有外部类`ThreadPoolExecutor `对象的引用，则在其运行结束之前，外部内不会被 GC 回收。 
根据以上分析，再次观察以上三个线程池：

1、CachedThreadPool：没有核心线程，且线程具有超时时间，可见在其引用消失后，等待任务运行结束且所有线程空闲回收后，GC 开始回收此线程池对象；

2、FixedThreadPool：核心线程数及最大线程数均为`nThreads`，并且在默认`allowCoreThreadTimeOut`为`false`的情况下，其引用消失后，核心线程即使空闲也不会被回收，故 GC 不会回收该线程池；

3、SingleThreadExecutor：默认与`FixedThreadPool`情况一致，但由于其语义为单线程线程池，JDK 开发人员为其提供了`FinalizableDelegatedExecutorService`包装类，在创建`FixedThreadPool`对象时实际返回的是`FinalizableDelegatedExecutorService`对象，该对象持有`FixedThreadPool`对象的引用，但`FixedThreadPool`对象并不引用`FinalizableDelegatedExecutorService`对象，这使得在`FinalizableDelegatedExecutorService`对象的外部引用消失后，GC将会对其进行回收，触发`finalize`函数，而该函数仅仅简单的调用`shutdown`函数关闭线程，是的所有当前的任务执行完成后，回收线程池中线程，则GC可回收线程池对象。

因此可得出结论，`CachedThreadPool`及`SingleThreadExecutor`的对象在不显式调用`shutdown`函数（或`shutdownNow`函数），且其对象引用消失的情况下，**可以被GC回收**；`FixedThreadPool`对象在不显式调用`shutdown`函数（或`shutdownNow`函数），且其对象引用消失的情况下**不会被GC回收，会出现内存泄露**。

**实验验证**

以上结论可使用实验验证：

```java
public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        // ExecutorService executorService = Executors.newFixedThreadPool(1);
        // ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.execute(() -> System.out.println(Thread.currentThread().getName()));
        // 线程引用置空
        executorService = null;
        Runtime.getRuntime().addShutdownHook(new Thread(() -> System.out.println("Shutdown.")));
        // 等待线程超时，主要对CachedThreadPool有效
        Thread.sleep(100000);
        // 手动触发GC
        System.gc();
}
```

使用以上代码，分别创建三种不同的线程池，可发现最终`FixedThreadPool`不会打印出‘Shutdown.’，JVM没有退出。另外两种线程池均能退出JVM。
因此无论使用什么线程池线程池使用完毕后均**调用`shutdown`**以保证其最终会被GC回收是一个较为安全的编程习惯。



#### Executor 执行任务

在Java 5之后，任务分两类：一类是实现了 Runnable 接口的类，一类是实现了 Callable 接口的类。两者都可以被ExecutorService 执行，但是 Runnable 任务没有返回值，而 Callable 任务有返回值。

##### 执行 Runnable 任务

通过 Executors 的以上四个静态工厂方法获得 **ExecutorService** 实例，而后调用该实例的 execute（Runnable command）方法即可。一旦 Runnable 任务传递到 execute() 方法，该方法便会自动在一个线程上执行。下面是是Executor执行Runnable任务的示例代码：

```java
import java.util.concurrent.ExecutorService; 
import java.util.concurrent.Executors; 
 
public class TestCachedThreadPool{ 
	public static void main(String[] args){ 
        ExecutorService executorService = Executors.newCachedThreadPool(); 
//      ExecutorService executorService = Executors.newFixedThreadPool(5);
//		ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 5; i++){ 
			executorService.execute(new TestRunnable()); 
			System.out.println("************* a" + i + " *************"); 
		} 
        executorService.shutdown(); 
	} 
} 
 
class TestRunnable implements Runnable{ 
	public void run(){ 
		System.out.println(Thread.currentThread().getName() + "线程被调用了。"); 
    } 
}
```

execute 会首先在线程池中选择一个已有空闲线程来执行任务，如果线程池中没有空闲线程，它便会创建一个新的线程来执行任务。

##### 执行 Callable 任务

Callable 的 call() 方法只能通过 ExecutorService 的 submit (Callable\<T> task) 方法来执行，并且返回一个\<T>Future\<T>，是表示任务等待完成的 Future。

Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常而 Callable 又**返回结果**，而且当获取返回结果时可能会**抛出异常**。Callable 中的 call() 方法类似 Runnable 的 run() 方法，区别同样是有返回值，后者没有。
当将一个 Callable 的对象传递给 ExecutorService 的 **submit** 方法，则该 call 方法自动在一个线程上执行，并且会返回执行**结果 Future** 对象。同样，将 Runnable 的对象传递给 ExecutorService 的 submit 方法，则该 run 方法自动在一个线程上执行，并且会返回执行结果 Future 对象，但是在该 Future 对象上调用 get 方法，将返回null。

```java
import java.util.ArrayList; 
import java.util.List; 
import java.util.concurrent.*; 
 
public class CallableDemo{ 
	public static void main(String[] args){ 
		ExecutorService executorService = Executors.newCachedThreadPool(); 
		List<Future<String>> resultList = new ArrayList<Future<String>>(); 
 
		// 创建10个任务并执行 
		for (int i = 0; i < 10; i++){ 
			// 使用ExecutorService执行Callable类型的任务，并将结果保存在future变量中 
			Future<String> future = executorService.submit(new TaskWithResult(i)); 
			// 将任务执行结果存储到List中 
			resultList.add(future); 
		} 
 
		// 遍历任务的结果 
		for (Future<String> fs : resultList){ 
				try{ 
                    // Future返回如果没有完成，则一直循环等待，直到Future返回完成
					while(!fs.isDone);
                    // 打印各个线程（任务）执行的结果
					System.out.println(fs.get());      
				}catch(InterruptedException e){ 
					e.printStackTrace(); 
				}catch(ExecutionException e){ 
					e.printStackTrace(); 
				}finally{ 
					// 启动一次顺序关闭，执行以前提交的任务，但不接受新任务
					executorService.shutdown(); 
				} 
		} 
	} 
} 
 
class TaskWithResult implements Callable<String>{ 
	private int id; 
 
	public TaskWithResult(int id){ 
		this.id = id; 
	} 
 
	/** 
	 * 任务的具体过程，一旦任务传给ExecutorService的submit方法，
	 * 则该方法自动在一个线程上执行
	 */ 
	public String call() throws Exception {
		System.out.println("call()方法被自动调用！！！" + Thread.currentThread().getName()); 
		// 该返回结果将被Future的get方法得到
		return "call()方法被自动调用，任务返回的结果是：" + id + " " + Thread.currentThread().getName(); 
	} 
}
```

submit() 也是首先选择空闲线程来执行任务，如果没有才会创建新的线程来执行任务。另外，需要注意：如果Future 的返回尚未完成，则get() 方法会**阻塞等待**，直到 Future 完成返回，可以通过调用 isDone() 方法判断Future 是否完成了返回。



##### Executor 的中断任务

调用 Executor 的 shutdown() 方法会等待线程都**执行完毕之后**再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> {
        try {
            Thread.sleep(2000);
            System.out.println("Thread run");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    });
    // 立马结束
    executorService.shutdownNow();
    System.out.println("Main run");
}
```

```html
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

如果只想中断 Executor 中的一个线程，可以通过使用 **submit()** 方法来提交一个线程，它会返回一个 **Future<?> 对象**，通过调用该对象的 cancel(true) 方法就可以中断线程。

```java
Future<?> future = executorService.submit(() -> {
    // ...
});
// 通过Future对象中断线程
future.cancel(true);  
```



### 线程池详解

**线程池的作用**
线程池作用就是限制系统中执行线程的数量。 
根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。



#### ThreadPoolExecutor

java.uitl.concurrent.ThreadPoolExecutor 类是线程池中**最核心**的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。

我们先来看一下 ThreadPoolExecutor 类中其他的一些比较**重要成员变量**：

```java
// 任务缓存队列，用来存放等待执行的任务
private final BlockingQueue<Runnable> workQueue;  	
// 线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁
private final ReentrantLock mainLock = new ReentrantLock();  
// 用来存放工作集                                                 
private final HashSet<Worker> workers = new HashSet<Worker>();  
// 线程存活时间  
private volatile long  keepAliveTime;      
// 是否允许为核心线程设置存活时间
private volatile boolean allowCoreThreadTimeOut;  
// 核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int   corePoolSize;     
// 线程池最大能容忍的线程数
private volatile int   maximumPoolSize;   
// 线程池中当前的线程数 
private volatile int   poolSize;       
// 任务拒绝策略 
private volatile RejectedExecutionHandler handler; 
// 线程工厂，用来创建线程 
private volatile ThreadFactory threadFactory;   
// 用来记录线程池中曾经出现过的最大线程数 
private int largestPoolSize;   
// 用来记录已经执行完毕的任务个数 
private long completedTaskCount;   
```

每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。

corePoolSize在很多地方被翻译成**核心池大小**，其实我的理解这个就是线程池的大小。举个简单的例子：

假如有一个工厂，工厂里面有 10个 工人，每个工人同时只能做一件任务。因此只要当 10 个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当 10 个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招 4 个临时工人进来；然后就将任务也分配给这 4 个临时工人做；如果说着 14 个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。当这 14 个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的 10 个工人，毕竟请额外的工人是要花钱的。

这个例子中的 corePoolSiz e就是10，而 maximumPoolSize 就是10 + 4 = 14。也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。

largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。

在ThreadPoolExecutor类中提供了四个**构造方法**：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    // ...
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    // ...
}
```

从上面的代码可以得知，ThreadPoolExecutor 继承了 AbstractExecutorService 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的**第四个**构造器进行的初始化工作。

下面解释下一下构造器中各个参数的含义：

- **corePoolSize**：**核心池**的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads() 或者 prestartCoreThread() 方法，从这两个方法的名字就可以看出，是**预创建**线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize 后，就会把到达的任务放到**缓存队列**当中；
- **maximumPoolSize**：线程池**最大**线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
- **keepAliveTime**：表示线程**没有任务执行时最多保持多久时间会终止**。默认情况下，只有当线程池中的线程数**大于 corePoolSize** 时，keepAliveTime 才会起作用，直到线程池中的线程数不大于 corePoolSize，即当线程池中的线程数大于 corePoolSize 时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过 corePoolSize。但是如果调用了 allowCoreThreadTimeOut(boolean) 方法，在线程池中的线程数不大于 corePoolSize 时，keepAliveTime 参数也会起作用，直到线程池中的线程数为0；
- **unit**：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：

```java
TimeUnit.DAYS;              // 天
TimeUnit.HOURS;             // 小时
TimeUnit.MINUTES;           // 分钟
TimeUnit.SECONDS;           // 秒
TimeUnit.MILLISECONDS;      // 毫秒
TimeUnit.MICROSECONDS;      // 微妙
TimeUnit.NANOSECONDS;       // 纳秒
```

- **workQueue**：一个**阻塞队列**，用来存储**等待执行的任务**，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：

```java
ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;
```

ArrayBlockingQueue 和 PriorityBlockingQueue 使用较少，一般使用 LinkedBlockingQueue 和 SynchronousQueue。线程池的排队策略与 BlockingQueue 有关。

- **threadFactory**：线程工厂，主要用来**创建线程**；
- **handler**：表示当**拒绝**处理任务时的策略，有以下四种取值:

```java
ThreadPoolExecutor.AbortPolicy;	// 丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy;	// 也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy;	// 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy;	// 由调用线程处理该任务 
```

从上面给出的 ThreadPoolExecutor 类的代码可以知道，ThreadPoolExecutor 继承了 AbstractExecutorService，AbstractExecutorService 是一个抽象类，它实现了 ExecutorService 接口。而ExecutorService 接口又是继承了 Executor接口。

```java
public interface Executor {
    void execute(Runnable command);
}
```

Executor 是一个顶层接口，在它里面只声明了一个方法 execute(Runnable)，返回值为 void，参数为 Runnable 类型，从字面意思可以理解，就是用来执行传进去的任务的；

然后 ExecutorService 接口继承了 Executor 接口，并声明了一些方法：submit、invokeAll、invokeAny 以及shutDown 等；

抽象类 AbstractExecutorService 实现了 ExecutorService 接口，基本实现了 ExecutorService 中声明的所有方法；

然后 ThreadPoolExecutor 继承了类 AbstractExecutorService。

在ThreadPoolExecutor类中有几个非常重要的方法：

```java
execute();
submit();
shutdown();
shutdownNow();
```

execute() 方法实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池**提交一个任务**，交由线程池去执行。

submit() 方法是在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池**提交任务**的，但是它和 execute() 方法不同，**它能够返回任务执行的结果**，去看 submit() 方法的实现，会发现它实际上还是调用的 execute() 方法，只不过它利用了 **Future** 来获取任务执行结果。

shutdown() 和 shutdownNow() 是用来**关闭**线程池的。

还有很多其他的方法：

比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，可以自行查阅API。



#### 线程池实现原理

![1567596929323](assets/1567596929323.png)

以下基于 Java6。

##### 线程池状态

在 ThreadPoolExecutor 中定义了一个 volatile 变量，另外定义了几个 static final 变量表示线程池的各个状态。

```java
volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
```

runState 表示当前线程池的状态，它是一个 volatile 变量用来保证线程之间的**内存可见性**；

下面的几个static final变量表示 runState 可能的几个取值。

当创建线程池后，初始时，线程池处于 **RUNNING** 状态；

如果调用了 shutdown() 方法，则线程池处于 **SHUTDOWN** 状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；

如果调用了 shutdownNow() 方法，则线程池处于 **STOP** 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；

当线程池处于 SHUTDOWN 或 STOP 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 TERMINATED 状态。

##### 任务的执行

看一下任务从提交到最终执行完毕经历了哪些过程。

在 ThreadPoolExecutor 类中，**最核心**的任务提交方法是 **execute**() 方法，虽然通过 **submit**()  也可以提交任务，但是实际上 submit()  方法里面最终调用的还是 execute() 方法，所以我们只需要研究 execute() 方法的实现原理即可：

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize >= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING && workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}
```

上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：

首先，判断提交的任务 command 是否为 null，若是 null，则抛出空指针异常；

接着是这句，这句要好好理解一下：

```java
`if` `(poolSize >= corePoolSize || !addIfUnderCorePoolSize(command))`
```

 　　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的 if 语句块了。

　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行

```java
`addIfUnderCorePoolSize(command)`
```

　　如果执行完 addIfUnderCorePoolSize 这个方法返回 false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。

　　如果执行完 addIfUnderCorePoolSize 这个方法返回 false，然后接着判断：

```java
`if` `(runState == RUNNING && workQueue.offer(command))`
```

 　　如果当前线程池处于 RUNNING 状态，则将任务放入任务缓存队列；如果当前线程池不处于 RUNNING 状态或者任务放入缓存队列失败，则执行：

```java
`addIfUnderMaximumPoolSize(command)`
```

　　如果执行 addIfUnderMaximumPoolSize 方法失败，则执行 reject() 方法进行任务拒绝处理。

　　回到前面：

```java
`if` `(runState == RUNNING && workQueue.offer(command))`
```

 　　这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：

```java
`if` `(runState != RUNNING || poolSize == ``0``)`
```

 　　这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用 shutdown 或者shutdownNow 方法关闭了线程池的一种应急措施。如果是这样就执行：

```java
`ensureQueuedTaskHandled(command)`
```

 进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。

接着看2个关键方法的实现：addIfUnderCorePoolSize 和 addIfUnderMaximumPoolSize：

```java
private boolean addIfUnderCorePoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize < corePoolSize && runState == RUNNING)
            t = addThread(firstTask);        // 创建线程去执行firstTask任务   
        } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
```

这个是 addIfUnderCorePoolSize 方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在 execute() 方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行 addIfUnderCorePoolSize 方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在 execute 方法判断的时候 poolSize 小于 corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致 poolSize 不小于 corePoolSize 了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为 RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown 或者 shutdownNow 方法。然后就是执行

```java
t = addThread(firstTask);
```

这个方法也非常关键，传进去的参数为提交的任务，返回值为 Thread 类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize >= corePoolSize 或者 runState 不等于 RUNNING），否则调用 t.start() 方法启动线程。

我们来看一下addThread方法的实现：

```java
private Thread addThread(Runnable firstTask) {
    Worker w = new Worker(firstTask);
    Thread t = threadFactory.newThread(w);  // 创建一个线程，执行任务   
    if (t != null) {
        w.thread = t;            // 将创建的线程的引用赋值为w的成员变量       
        workers.add(w);
        int nt = ++poolSize;     // 当前线程数加1       
        if (nt > largestPoolSize)
            largestPoolSize = nt;
    }
    return t;
}
```

在 addThread 方法中，首先用提交的任务创建了一个 Worker 对象，然后调用线程工厂 threadFactory 创建了一个新的线程 t，然后将线程 t 的引用赋值给了 Worker 对象的成员变量 thread，接着通过 workers.add(w) 将Worker 对象添加到工作集当中。

下面我们看一下Worker类的实现：

```java
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    boolean isActive() {
        return runLock.isLocked();
    }
    void interruptIfIdle() {
        final ReentrantLock runLock = this.runLock;
        if (runLock.tryLock()) {
            try {
        if (thread != Thread.currentThread())
        thread.interrupt();
            } finally {
                runLock.unlock();
            }
        }
    }
    void interruptNow() {
        thread.interrupt();
    }
 
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
            if (runState < STOP &&
                Thread.interrupted() &&
                runState >= STOP)
            boolean ran = false;
            // beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据
            beforeExecute(thread, task);   
            // 自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           
            try {
                task.run();
                ran = true;
                afterExecute(task, null);
                ++completedTasks;
            } catch (RuntimeException ex) {
                if (!ran)
                    afterExecute(task, ex);
                throw ex;
            }
        } finally {
            runLock.unlock();
        }
    }
 
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);   // 当任务队列中没有任务时，进行清理工作       
        }
    }
}
```

它实际上实现了 Runnable 接口，因此上面的 Thread t = threadFactory.newThread(w); 效果跟下面这句的效果基本一样：

```java
Thread t = new Thread(w);
```

相当于传进去了一个 Runnable 任务，在线程 t 中执行这个 Runnable。

既然 Worker 实现了 Runnable 接口，那么自然最核心的方法便是 run() 方法了：

```java
public void run() {
    try {
        Runnable task = firstTask;
        firstTask = null;
        while (task != null || (task = getTask()) != null) {
            runTask(task);
            task = null;
        }
    } finally {
        workerDone(this);
    }
}
```

从 run 方法的实现可以看出，它首先执行的是通过构造器传进来的任务 firstTask，在调用 runTask() 执行完firstTask 之后，在 while 循环里面不断通过 getTask() 去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask 是 ThreadPoolExecutor 类中的方法，并不是 Worker 类中的方法，下面是 getTask 方法的实现：

```java
Runnable getTask() {
    for (;;) {
        try {
            int state = runState;
            if (state > SHUTDOWN)
                return null;
            Runnable r;
            if (state == SHUTDOWN)  // Help drain queue
                r = workQueue.poll();
            // 如果线程数大于核心池大小或者允许为核心池线程设置空闲时间
            else if (poolSize > corePoolSize || allowCoreThreadTimeOut) 
                // 则通过poll取任务，若等待一定的时间取不到任务，则返回null
                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
            else
                r = workQueue.take();
            if (r != null)
                return r;
            // 如果没取到任务，即r为null，则判断当前的worker是否可以退出
            if (workerCanExit()) {    
                if (runState >= SHUTDOWN) // Wake up others
                    interruptIdleWorkers();   // 中断处于空闲状态的worker
                return null;
            }
            // Else retry
        } catch (InterruptedException ie) {
            // On interruption, re-check runState
        }
    }
}
```

在 getTask 中，先判断当前线程池状态，如果 runState 大于 SHUTDOWN（即为 STOP 或者 TERMINATED），则直接返回 null。

如果 runState 为 SHUTDOWN 或者 RUNNING，则从任务缓存队列取任务。

如果当前线程池的线程数大于核心池大小 corePoolSize 或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit) 来取任务，这个方法会等待一定的时间，如果取不到任务就返回 null。

然后判断取到的任务 r 是否为 null，为 null 则通过调用 workerCanExit() 方法来判断当前 worker 是否可以退出，我们看一下 workerCanExit() 的实现：

```java
private boolean workerCanExit() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    boolean canExit;
    // 如果runState大于等于STOP，或者任务缓存队列为空了
    // 或者允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1
    try {
        canExit = runState >= STOP ||
            workQueue.isEmpty() ||
            (allowCoreThreadTimeOut &&
             poolSize > Math.max(1, corePoolSize));
    } finally {
        mainLock.unlock();
    }
    return canExit;
}
```

也就是说如果线程池处于 STOP 状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于 1  时，允许 worker 退出。如果允许 worker 退出，则调用 interruptIdleWorkers() 中断处于空闲状态的worker，我们看一下 interruptIdleWorkers() 的实现：

```java
void interruptIdleWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)  // 实际上调用的是worker的interruptIfIdle()方法
            w.interruptIfIdle();
    } finally {
        mainLock.unlock();
    }
}
```

从实现可以看出，它实际上调用的是 worker 的 interruptIfIdle() 方法，在 worker 的 interruptIfIdle() 方法中：

```java
void interruptIfIdle() {
    final ReentrantLock runLock = this.runLock;
    // 这里是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的
    if (runLock.tryLock()) {    
        // 如果成功获取了锁，说明当前worker处于空闲状态
        try {
    if (thread != Thread.currentThread())  
    thread.interrupt();
        } finally {
            runLock.unlock();
        }
    }
}
```

这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。

 　　我们再看 addIfUnderMaximumPoolSize 方法的实现，这个方法的实现思想和 addIfUnderCorePoolSize 方法的实现思想非常相似，唯一的区别在于 addIfUnderMaximumPoolSize 方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：

```java
private boolean addIfUnderMaximumPoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize < maximumPoolSize && runState == RUNNING)
            t = addThread(firstTask);
    } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
```

看到没有，其实它和 addIfUnderCorePoolSize 方法的实现基本一模一样，只是 if 语句判断条件中的 poolSize < maximumPoolSize 不同而已。

　　到这里，对任务提交给线程池之后到被执行的整个过程应该有了一个基本的了解，下面总结一下：

　　1）首先，要清楚 corePoolSize 和 maximumPoolSize 的含义；

　　2）其次，要知道 Worker 是用来起到什么作用的；

　　3）要知道任务提交给线程池之后的**处理策略**，这里总结一下主要有4点：

- 如果当前线程池中的线程数目小于 corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；
- 如果当前线程池中的线程数目 >= corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；
- 如果当前线程池中的线程数目达到 maximumPoolSize，则会采取任务拒绝策略进行处理；
- 如果线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止，直至线程池中的线程数目不大于 corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过 keepAliveTime，线程也会被终止。



##### 线程池中的线程初始化

默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。

在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到，即预先创建线程：

- prestartCoreThread()：初始化一个核心线程；
- prestartAllCoreThreads()：初始化所有核心线程

```java
public boolean prestartCoreThread() {
    return addIfUnderCorePoolSize(null); // 注意传进去的参数是null
}
 
public int prestartAllCoreThreads() {
    int n = 0;
    while (addIfUnderCorePoolSize(null))// 注意传进去的参数是null
        ++n;
    return n;
}
```

注意上面传进去的参数是 null，根据前面的分析可知如果传进去的参数为 null，则最后执行线程会阻塞在 getTask方法中的

```java
r = workQueue.take();
```

即等待任务队列中有任务。



##### 任务缓存队列及排队策略

在前面我们多次提到了任务缓存队列，即 **workQueue**，它用来存放等待执行的任务。

workQueue的类型为 BlockingQueue\<Runnable>，通常可以取下面三种类型：

- ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；
- LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
- synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。



##### 任务拒绝策略

当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：

```java
ThreadPoolExecutor.AbortPolicy; 	// 丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy;	// 也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy;	// 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy;	// 由调用线程处理该任务
```



##### **线程池的关闭**

ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：

- shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
- shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务



##### 线程池容量的动态调整

　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，

- setCorePoolSize：设置核心池大小
- setMaximumPoolSize：设置线程池最大能创建的线程数目大小

　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。



##### 使用示例

```java
public class Test {
     public static void main(String[] args) {   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(5));
          
         for(int i=0;i<15;i++){
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println("线程池中线程数目："+executor.getPoolSize()+"，队列中等待执行的任务数目："+
             executor.getQueue().size()+"，已执行玩别的任务数目："+executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
 
 
class MyTask implements Runnable {
    private int taskNum;
     
    public MyTask(int num) {
        this.taskNum = num;
    }
     
    @Override
    public void run() {
        System.out.println("正在执行task "+taskNum);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("task "+taskNum+"执行完毕");
    }
}
```

```html
正在执行task 0
线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 1
线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 2
线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 3
线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 4
线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 10
线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 11
线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 12
线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 13
线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 14
task 3执行完毕
task 0执行完毕
task 2执行完毕
task 1执行完毕
正在执行task 8
正在执行task 7
正在执行task 6
正在执行task 5
task 4执行完毕
task 10执行完毕
task 11执行完毕
task 13执行完毕
task 12执行完毕
正在执行task 9
task 14执行完毕
task 8执行完毕
task 5执行完毕
task 7执行完毕
task 6执行完毕
task 9执行完毕
```

从执行结果可以看出，当线程池中线程的数目大于 5 时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将 for 循环中改成执行20个任务，就会抛出任务拒绝异常了。

不过在java doc中，并不提倡我们直接使用 ThreadPoolExecutor，而是使用 Executors 类中提供的几个静态方法来创建线程池。



#### 线程池补充

##### 线程池死锁

任务之间有依赖可能造成线程池死锁。可以使用 newCachedThreadPool 创建线程池，让线程数不受限制。也可以使用 SynchronousQueue 来避免线程池死锁。





### 定时任务

任务调度是指基于 **给定时间点**，**给定时间间隔** 或者 **给定执行次数** 自动执行任务。

#### Thread 实现

例如如下的代码，可以每隔 1000 毫秒做一次打印操作。

```java
public class Job_Schedule_Test1 {
    public static void main(String[] args) {
        new JobThread().start();
    }
}

class JobThread extends Thread {
    public void run() {
        while (true) {
            System.out.println("Test: " + Calendar.getInstance().getTime());

            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            }
        }
    }
}
```

输出如下

```java
Test: Wed Feb 22 14:33:57 CST 2017
Test: Wed Feb 22 14:33:58 CST 2017
Test: Wed Feb 22 14:33:59 CST 2017
Test: Wed Feb 22 14:34:00 CST 2017
Test: Wed Feb 22 14:34:01 CST 2017
```



#### Timer 实现

- 自定义一个任务，继承于 `TimerTask`，重写 `run` 方法
- 利用 `java.util.Timer` 实现任务调度

```java
public class Job_Schedule_Test2 {
    public static void main(String[] args) {
        Timer timer = new Timer();
        long delay = 2000;
        long interval = 1000;

        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次
        timer.schedule(new JobTask1(), delay, interval);
        timer.schedule(new JobTask2(), delay, interval);
    }
}
// 任务1
class JobTask1 extends TimerTask {
    public void run() {
        System.out.println("Test: " + Calendar.getInstance().getTime());
    }
}
// 任务2
class JobTask2 extends TimerTask {
    public void run() {
        try{
            Thread.sleep(1000);
            throw new Exception();
        } catch (Exception e){
        }
    }
}
```

- Timer 的设计核心是一个 TaskList 和一个 TaskThread。
- `Timer` 将接收到的任务丢到自己的 `TaskList` 中，`TaskList` 按照 `Task` 的最初执行时间进行排序。`TimerThread` 在创建 `Timer` 时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，`TimerThread` 被唤醒并执行该任务。之后 `TimerThread` 更新最近一个要执行的任务，继续休眠。

- `Timer` 的优点在于简单易用，但由于所有任务都是由**同一个线程**来调度，**因此所有任务都是串行执行的**，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。
    例如我们指定每隔 1000 毫秒执行一次任务，但是可能某个任务执行花了 5000 毫秒，因此导致后续的任务并不能按时启动执行。
- Timer 内部主要由任务队列和 Timer 线程两部分组成。任务队列是一个基于堆实现的优先级队列，按照下次执行的时间排优先级。Timer 线程则负责执行所有的定时任务，需要强调的是，一个 Timer 对象只有一个 Timer 线程，所以如果一个任务是无限循环的话其他任务可能就执行不了。同时，一个任务内部抛出异常将导致 Timer 线程退出，导致所有的定时任务都被取消。如果希望各个定时任务不互相干扰，一定要注意在任务内部捕获异常。



#### ScheduledExecutorService 实现

鉴于 `Timer` 的上述缺陷，Java 5 推出了基于线程池设计的 `ScheduledExecutorService`。
其设计思想是，每一个被调度的任务都会 **由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。**
需要注意的是，只有当任务的执行时间到来时，`ScheduledExecutorService` 才会真正启动一个线程，其余时间 `ScheduledExecutorService` 都是在轮询任务的状态。

```java
java.util.concurrent.ScheduleExecutorService extends ExecutorService extends Executor
```

其中 scheduleAtFixedRate 和 scheduleWithFixedDelay 在实现定时程序时比较方便。

```java
// command：执行线程
// initialDelay：初始化延时
// period：两次开始执行最小间隔时间
// unit：计时单位
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
```

```java
// command：执行线程
// initialDelay：初始化延时
// period：前一次执行结束到下一次执行开始的间隔时间（间隔执行延迟时间）
// unit：计时单位
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
```

返回类型都是 ScheduledFuture，是一个接口，扩展了 Future 和 Delayed，没有定义额外的方法。

ScheduledExecutorService 的主要实现类是 ScheduledThreadPoolExecutor，它是线程池 ThreadPoolExecutor 的子类，是基于线程池实现的。

它的任务队列是一个**无界**的优先级队列。

```java
public class Job_Schedule_Test3 {
    public static void main(String[] args) {
        ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
        long delay = 2;
        long interval = 1;

        // 从现在开始 2 秒钟之后启动，每隔 1 秒钟执行一次
        service.scheduleAtFixedRate(new JobTask1(), delay, interval, TimeUnit.SECONDS);
        service.scheduleAtFixedRate(new JobTask2(), delay, interval, TimeUnit.SECONDS);
    }
}

class JobTask1 implements Runnable {
    public void run() {
        System.out.println("Test: " + Calendar.getInstance().getTime());
    }
}

class JobTask2 implements Runnable {
    public void run() {
        while(true) {
            // 无限循环
        }
    }
}
```

- 有多个线程执行任务，所以一个任务内的无限循环不会影响其他的任务。
- 一个任务抛出异常也不会影响其他任务，但是应该尽量把异常捕获。
- 用 ScheduledExecutor 和 Calendar 可以实现复杂任务调度



#### Quartz 实现

Quartz是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。Quartz 允许开发人员根据时间间隔来调度作业。它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。简单地创建一个 org.quarz.Job 接口的 Java 类，Job 接口包含唯一的方法：

```java
public void execute(JobExecutionContext context) throws JobExecutionException;
```

**Job**

具体需要处理的业务逻辑。

**JobDetail**

详细的任务描述，包括名称，关联的`Job`，`Job`运行时所需要的参数等。

**Trigger**

任务调度器，描述什么时候执行`Job`，多久执行一次。

- SimpleTrigger 设置重复次数，重复执行间隔时长
- CronTrigger 设置Cron表达式

**Scheduler**

调度容器，`Job`与`Trigger`都需要在容器中注册，被容器统一管理。

```java
public class QuartzJob implements org.quartz.Job {
    public QuartzJob() {
    }

    public void execute(JobExecutionContext arg0) throws JobExecutionException {
        System.out.println("Test: " + Calendar.getInstance().getTime());
    }
}
```

```java
import org.quartz.*;
import org.quartz.impl.StdSchedulerFactory;
import static org.quartz.JobBuilder.*;
import static org.quartz.TriggerBuilder.*;
import static org.quartz.SimpleScheduleBuilder.*;

public class Job_Schedule_Test4 {
    public static void main(String[] args) throws SchedulerException {
        // Grab the Scheduler instance from the Factory
        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();

        // define the job and tie it to our MyJob class
        JobDetail job = newJob(QuartzJob.class)
                .withIdentity("job1", "group1")
                .build();

        // Trigger the job to run now, and then repeat every 40 seconds
        Trigger trigger = newTrigger()
                .withIdentity("trigger1", "group1")
                .startNow()
                .withSchedule(simpleSchedule()
                        .withIntervalInSeconds(1)
                        .repeatForever())
                .build();

        // Tell quartz to schedule the job using our trigger
        scheduler.scheduleJob(job, trigger);

        // and start it off
        scheduler.start();
    }
}
```







## 五、同步与协作工具类

java.util.concurrent（J.U.C）大大提高了并发性能，**AQS** 被认为是 J.U.C 的核心。AQS是AbstractQueuedSynchronizer 的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架。AQS 是一个用来构建锁和同步工具的框架，包括常用的ReentrantLock、CountDownLatch、Semaphore等。



### ReentrantReadWriteLock

synchronized 和显式锁 ReentrantLock，对于同一受保护对象的访问，无论是读还是写，都要求获得==同样的锁==。一些场景中是不需要的，多个线程的读操作完全可以并行，在读多写少的场景中，让读操作并行可以明显提高性能。所以使用读写锁 ReentrantReadWriteLock 可以让读操作并行，又不影响一致性。ReentrantReadWriteLock 是**可重入**的。

JCU包中读写锁接口 (ReadWriteLock) 的重要实现类 ReentrantReadWriteLock。主要实现**读共享，写互斥**功能，对比单纯的互斥锁在共享资源使用场景为**频繁读取及少量修改**的情况下可以较好的提高性能。

只有 “读-读” 操作是可以并行的，“读-写” 和 “写-写” 都不可以。只有一个线程可以进行写操作，在获取写锁时，只有没有任何线程持有任何锁才可以获取到，在持有写锁时，其他任何线程都获取不到任何锁。在没有其他线程持有写锁的情况下，多个线程可以获取和持有读锁。

ReadWriteLock 接口只定义了两个方法：

```java
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     * @return the lock used for reading
     */
    Lock readLock();

    /**
     * Returns the lock used for writing.
     * @return the lock used for writing
     */
    Lock writeLock();
}
```

通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是Lock接口的实现，可以如同使用 Lock 接口一样使用（其实也有一些特性是不支持的）。

使用示例

```java
class RWDictionary {
    private final Map<String, Data> m = new TreeMap<String, Data>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public Data get(String key) {
        r.lock();
        try { return m.get(key); }
        finally { r.unlock(); }
    }
    public String[] allKeys() {
        r.lock();
        try { return m.keySet().toArray(); }
        finally { r.unlock(); }
    }
    public Data put(String key, Data value) {
        w.lock();
        try { return m.put(key, value); }
        finally { w.unlock(); }
    }
    public void clear() {
        w.lock();
        try { m.clear(); }
        finally { w.unlock(); }
    }
}
```

与普通重入锁使用的主要区别在于需要**使用==不同==的锁对象引用读写锁**，并且在读写时分别调用对应的锁。

内部使用**同一个整数**变量表示锁的状态，16 位给读锁用，16 位给写锁用，使用一个变量便于进行 CAS 操作，锁的等待队列其实也只有一个。



### CountDownLatch

可理解为一个倒计时**门栓**，一开始是关闭的，所有希望通过该门的线程都需要**等待**，然后开始倒计时，倒计时变为 0  之后，门栓打开，等待的所有线程都可以通过，它是**一次性**的，打开之后不能再关上。

用来控制==一个线程**等待**多个线程==。

维护了一个**计数器 cnt**，每次调用 countDown() 方法会让计数器的值**减 1**，减到 0 的时候，那些因为调用 **await()** 方法而在等待的线程就会被**唤醒**。

![1563602021597](assets/1563602021597.png)

```java
public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.println("end");
        executorService.shutdown();
    }
}
```

```html
run..run..run..run..run..run..run..run..run..run..end
```

------

### CyclicBarrier

用来控制==多个线程互相等待==，只有当多个线程都到达时，这些线程才会继续执行。与上述的 CountDownLatch 类似，不过它是**循环**的，可以用作**重复**的同步。

相当于一个栅栏，特别适合用于**并行迭代计算**，每个线程负责一部分计算任务，然后在栅栏处等待其他线程完成，等待所有线程到齐后，交换数据和计算结果，进行下一次迭代。

和 CountdownLatch 相似，都是通过维护**计数器**来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以**循环使用**，所以它才叫做循环屏障。

CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```

![1563602037486](assets/1563602037486.png)

```java
public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("before..");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print("after..");
            });
        }
        executorService.shutdown();
    }
}
```

```html
before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..
```



**对比 CountDownLatch 与 CyclicBarrier**

|                        CountDownLatch                        |                        CyclicBarrier                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                          减计数方式                          |                          加计数方式                          |
|                 计算为0时释放所有等待的线程                  |               计数达到指定值时释放所有等待线程               |
|                     计数为0时，无法重置                      |             计数达到指定值时，计数置为0重新开始              |
| 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 |
|                         不可重复利用                         |                          可重复利用                          |

------

### Semaphore

Semaphore 类似于操作系统中的**信号量**，可以控制对**互斥资源的访问线程数**。

计数信号量用来控制**同时访问**某个特定资源的操作数量，或者同时执行某个指定操作的数量。信号量还可以用来实现某种资源池，或者对**容器施加边界**。**Semaphore**管理着一组**许可（permit）**,许可的初始数量可以通过构造函数设定，操作时首先要**获取到许可**，才能进行操作，操作完成后需要**释放**许可。如果没有获取许可，则**阻塞**到有许可被释放。如果初始化了一个许可为 1 的**Semaphore**，那么就相当于一个**不可重入**的互斥锁（**Mutex**）。

以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```java
public class SemaphoreExample {

    public static void main(String[] args) {
        // 访问线程数
        final int clientCount = 3;
        // 总请求数
        final int totalRequestCount = 10;
        // 构造信号量
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    // 获取信号量
                    semaphore.acquire();
                    // 显示还可以用的信号量个数
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放信号量
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

```html
2 1 2 2 2 2 2 1 2 2
```

------

### FutureTask

在介绍 Callable 时我们知道它可以有返回值，**返回值**通过 **Future\<V>** 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 **Runnable** 和 **Future\<V>** 接口，这使得 **FutureTask 既可以当做一个任务执行，也可以有返回值。**

```java
public interface RunnableFuture<V> extends Runnable, Future<V>
```

```java
public class FutureTask<V> implements RunnableFuture<V>
```

FutureTask 可用于异步**获取执行结果或取消执行任务**的场景。当一个计算任务需要执行**很长时间**，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。

```java
public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 封装任务
        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Callable<Integer>() 			{
            @Override
            public Integer call() throws Exception {
                int result = 0;
                for (int i = 0; i < 100; i++) {
                    Thread.sleep(10);
                    result += i;
                }
                return result;
            }
        });
		// 线程传入futureTask
        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread otherThread = new Thread(() -> {
            System.out.println("other task is running...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        otherThread.start();
        // 获取futureTask的执行结果
        System.out.println(futureTask.get());
    }
}
```

```html
other task is running...
4950
```

------

### ForkJoin

主要用于**并行计算**中，和 **MapReduce** 原理类似，都是把大的计算任务**拆分**成多个小任务并行计算。

```java
public class ForkJoinExample extends RecursiveTask<Integer> {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first <= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i <= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
```

ForkJoin 使用 **ForkJoinPool** 来启动，它是一个特殊的线程池，线程数量取决于 **CPU 核数**。

```java
public class ForkJoinPool extends AbstractExecutorService
```

ForkJoinPool 实现了**工作窃取算法**来提高 CPU 的利用率。每个线程都维护了一个**双端队列**，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中**窃取一个任务**来执行。窃取的任务必须是**最晚的**任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出futureTask的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中**只有一个任务**时还是会发生竞争。

![1563602068967](assets/1563602068967.png)





### ThreadLocal

#### 概述

- 线程本地变量，每个线程都有同一个变量的独有拷贝，如多个线程同时操作的是同一个 ThreadLocal 对象，但每个线程都有自己独立的值，变动不会影响其他的线程。
- ThreadLocal 对象一般都定义为 static，便于引用。
- ThreadLocal 用一种存储变量与线程绑定的方式，在每个线程中用自己的 ThreadLocalMap 安全隔离变量，为解决多线程程序的并发问题提供了一种新的思路，如为每个线程创建一个独立的数据库连接。因为是线程绑定的，所以在很多场景也被用来实现线程参数传递，如 Spring 的 RequestContextHolder。也因为每个线程拥有自己唯一的 ThreadLocalMap ，所以 ThreadLocalMap 是天然线程安全的。
- 每个线程都有一个 Map，对于每个 ThreadLocal 对象，调用其 get/set 实际上就是以 ThreadLocal 对象为键读写当前线程的 Map。



#### 使用场景

**日期处理**

ThreadLocal 是实现线程安全的一种方案，如对于 DateFormat/SimpleDateFormat 是非线程安全的，实现安全的一种方式是使用锁，另一种方式是每次都创建一个新的对象，更好的方式是使用 ThreadLocal，每个线程使用自己的 DateFormat，就不存在线程安全问题了。

```java
public class ThreadLocalDateFormat {
    // 定义ThreadLocal变量
    static ThreadLocal<DateFormat> sdf = new ThreadLocal<>() {
        protected DateFormat initValue() {
            return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        }
    };
    
    public static String dateToString(Date date) {
        return sdf.get().format(date);
    }

    public static Date dateToString2(String str) throws ParseException {
        return sdf.get().parse(str);
    }
    
}
```



**随机数**

Random 类是线程安全的，但是多线程使用会存在竞争问题，性能会下降，所以提供了 ThreadLocalRandom 类，它是 Random 的子类，利用了 ThreadLocal，它没有 public 的构造方法，通过静态方法 current 获取对象。如：

```java
public static void main(String[] args) {
    ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();
    System.out.println(threadLocalRandom.nextInt(100));
}
```

**上下文信息**

被广泛用在 Spring 等框架中。可以存储上下文信息，避免在不同代码之间来回传递，简化代码。



#### 原理分析

##### ThreadLocal 存储结构

首先我们来聊一聊 ThreadLocal 在多线程运行时，各线程是如何存储变量的，假如我们现在定义两个 ThreadLocal 实例如下：

```java
static ThreadLocal<User> threadLocal_1 = new ThreadLocal<>();
static ThreadLocal<Client> threadLocal_2 = new ThreadLocal<>();
```

我们分别在三个线程中使用 ThreadLocal，伪代码如下：

```java
// thread-1中
threadLocal_1.set(user_1);
threadLocal_2.set(client_1);

// thread-2中
threadLocal_1.set(user_2);
threadLocal_2.set(client_2);

// thread-3中
threadLocal_2.set(client_3);
```

这三个线程都在运行中，那此时各线程中的存数数据应该如下图所示。

![1567734769869](assets/1567734769869.png)

每个线程持有自己的 ThreadLocalMap，ThreadLocalMap 初始容量为16（即图中的16个槽位），在调用ThreadLocal 的 set 方法时，将以 ThreadLocal 为 Key 存储在 本线程的 ThreadLocalMap 里面，ThreadLocalMap 的 Value 为Object 类型，实际类型由 ThreadLocal 定义。



##### ThreadLocal public方法

1. **ThreadLocal 之 set() 方法**

```java
public void set(T value) {
    Thread t = Thread.currentThread();  // 获取当前线程
    ThreadLocalMap map = getMap(t); 	// 拿到当前线程的 ThreadLocalMap
    if (map != null) 	// 判断 ThreadLocalMap 是否存在
        map.set(this, value); 	// 调用 ThreadLocalMap 的 set 方法
    else
        createMap(t, value); 	// 创建 ThreadLocalMap
}
```

第一次调用时需要 creatMap，创建方式比较简单不详解。这里重要的还是 ThreadLocalMap 的 set 方法。

2. **ThreadLocal 之 get() 方法**

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        // 调用ThreadLocalMap的getEntry 方法
        ThreadLocalMap.Entry e = map.getEntry(this); 
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    // 如果还没有设置，可以用子类实现 initialValue ，自定义初始值
    return setInitialValue(); 
}
```

3. **ThreadLocal 之 remove() 方法**

```java
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        // 调用ThreadLocalMap的remove方法
        m.remove(this); 
}
```

这里罗列了 ThreadLocal 的几个 public 方法，其实所有工作最终都落到了 ThreadLocalMap 的头上，ThreadLocal 仅仅是从当前线程取到 ThreadLocalMap 而已，具体执行，请看下面对 ThreadLocalMap 的分析。

##### ThreadLocalMap

###### ThreadLocalMap 简介

ThreadLocalMap 是ThreadLocal 内部的一个Map实现，然而它并没有实现任何集合的接口规范，因为它仅供内部使用，数据结构采用 数组 + 开方地址法，Entry 继承 WeakReference，是基于 ThreadLocal 这种特殊场景实现的 Map，它的实现方式很值得研究。

ThreadLocalMap 类结构及其成员 Entry 定义如下：

```java
static class ThreadLocalMap {
    // Entry类继承了WeakReference<ThreadLocal<?>>，即每个Entry对象都有一个ThreadLocal的弱引用
    //（作为key），这是为了防止内存泄露。一旦线程结束，key变为一个不可达的对象，这个Entry就可以被GC了
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;
        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
    // ThreadLocalMap 的初始容量，必须为2的倍数
    private static final int INITIAL_CAPACITY = 16;

    // resized时候需要的table
    private Entry[] table;

    // table中的entry个数
    private int size = 0;

    // 扩容数值
    private int threshold; // Default to 0
}    
```

Entry 继承 WeakReference，以 ThreadLocal 为 key，类似 WeakHashMap，对内存敏感。虽然继承 WeakReference，但只能实现对 Reference 的 key 的回收，而对 value 的回收需要手动解决。value 何时被回收？ 如果没有理解 value 的回收时间，那可能留下内存溢出的隐患。

其常用的构造函数如下：

```java
 ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }
```

构造函数的第一个参数就是本 ThreadLocal 实例(this)，第二个参数就是要保存的线程本地变量。构造函数首先创建一个长度为 16 的 Entry 数组，然后计算出 firstKey 对应的哈希值，然后存储到 table 中，并设置 size 和threshold。

注意一个细节，计算 hash 的时候里面采用了 **hashCode & (size - 1)** 的算法，这相当于取模运算 hashCode % size 的一个更高效的实现（和 HashMap 中的思路相同）。正是因为这种算法，我们要求 size 必须是 **2 的指数**，因为这可以使得 hash 发生冲突的次数减小。

###### ThreadLocalMap#set

ThreadLocal 中 put 函数最终调用了 ThreadLocalMap 中的 set 函数，跟进去看一看：

```java
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
         e != null;
         // 冲突了
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold) {
        rehash();
    }
}
```

在上述代码中如果 Entry 在存放过程中冲突了，调用 nextIndex 来处理，如下所示。是否还记得 hashmap 中对待冲突的处理？这里好像是另一种套路：只要 i 的数值小于 len，就加 1 取值，官方术语称为：线性探测法。

```java
 private static int nextIndex(int i, int len) {
            return ((i + 1 < len) ? i + 1 : 0);
 }
```

以上步骤 ok 了之后，再次关注一下源码中的 cleanSomeSlots，该函数主要的作用就是清理无用的 entry，具体细节就不扣了：

```java
private boolean cleanSomeSlots(int i, int n) {
    boolean removed = false;
    Entry[] tab = table;
    int len = tab.length;
    do {
        i = nextIndex(i, len);
        Entry e = tab[i];
        if (e != null && e.get() == null) {
            n = len;
            removed = true;
            i = expungeStaleEntry(i);
        }
    } while ( (n >>>= 1) != 0);
    return removed;
}
```

###### ThreadLocal#get

看完了 set 函数，肯定是要关注 Get 的，源码如下所示：

```java
 public T get() {
        // 获取Thread对象t
        Thread t = Thread.currentThread();
        // 获取t中的map
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
```

如果 map 为 null，就返回 setInitialValue() 这个方法，跟进这个方法看一下：

```java
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
```

最后返回的是 value，而 value 来自`initialValue()`,进入这个源码中查看：

```java
protected T initialValue() {
    return null;
}
```

原来如此，如果不设置 ThreadLocal 的数值，默认就是 null，来自于此。





## 六、并发总结

### 线程安全总结

多个线程不管以何种方式访问某个类，并且在主调代码中**不需要进行同步**，都能表现正确的行为。

线程安全有以下几种实现方式：

#### 不可变

不可变（**Immutable**）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为**不可变**，来满足线程安全。

不可变的类型：

- final 关键字修饰的**基本数据**类型
- **String**
- **枚举**类型
- Number 部分子类，如 Long 和 Double 等**数值包装**类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的**原子类** AtomicInteger 和 AtomicLong 则是**可变**的。

对于集合类型，可以使用 Collections.**unmodifiableXXX()** 方法来获取一个不可变的集合。

```java
public class ImmutableExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        // 获取不可变集合
        Map<String, Integer> unmodifiableMap = Collections.unmodifiableMap(map);
        unmodifiableMap.put("a", 1);
    }
}
```

```html
Exception in thread "main" java.lang.UnsupportedOperationException
    at java.util.Collections$UnmodifiableMap.put(Collections.java:1457)
    at ImmutableExample.main(ImmutableExample.java:9)
```

Collections.unmodifiableXXX() 先对原始的集合进行**拷贝**，需要对集合进行修改的方法都**直接**抛出异常。

```java
// 不可变集合修改内容的源码
public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
```

------

#### 互斥同步

synchronized 和 ReentrantLock。也称为阻塞同步。是一种悲观的并发策略。

------

#### 非阻塞同步★

互斥同步最主要的问题就是线程**阻塞和唤醒**所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种**悲观**的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，**它都要进行加锁**（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

##### 1. CAS

随着**硬件**指令集的发展，我们可以使用**基于冲突检测的乐观并发策略**：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取**补偿**措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为**非阻塞同步**。

乐观锁需要操作和冲突检测这两个步骤具备**原子性**，这里就不能再使用互斥同步来保证了，只能靠**硬件**来完成。**硬件支持的原子性**操作最典型的是：==比较并交换（Compare-and-Swap，CAS）==。CAS 指令需要有 **3 个操作数**，分别是**内存地址 V、旧的预期值 A 和新值 B**。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。

##### 2. AtomicInteger 原子类

J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 **Unsafe 类**的 CAS 操作。

以下代码使用了 AtomicInteger 执行了自增的操作。

```java
private AtomicInteger cnt = new AtomicInteger();

public void add() {
    cnt.incrementAndGet();
}
```

以下代码是 incrementAndGet() 的源码，它调用了 **Unsafe** 的 getAndAddInt() 。

```java
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}
```

以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。

可以看到 getAndAddInt() 在一个**循环**中进行，发生冲突的做法是**不断的进行重试**。

```java
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    // 如果发生冲突则在循环中不断重试
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

##### 3. ABA问题

如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会**误认为它从来没有被改变过**。

J.U.C 包提供了一个**带有标记**的原子引用类 **AtomicStampedReference** 来解决这个问题，它可以通过控制变量值的**版本**来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。

------

#### 无同步方案

要保证线程安全，并不是一定就要进行同步。如果一个方法本来就**不涉及共享数据**，那它自然就无须任何同步措施去保证正确性。

##### 1. 栈封闭

多个线程访问同一个**方法的局部变量**时，不会出现线程安全问题，因为局部变量存储在**虚拟机栈**中，属于**线程私有**的。

```java
public class StackClosedExample {
    public void add100() {
        // 方法内部局部变量
        int cnt = 0;
        for (int i = 0; i < 100; i++) {
            cnt++;
        }
        System.out.println(cnt);
    }
}
```

```java
public static void main(String[] args) {
    StackClosedExample example = new StackClosedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.add100());
    executorService.execute(() -> example.add100());
    executorService.shutdown();
}
```

```html
100
100
```

##### 2. 线程本地存储（Thread Local Storage）

如果一段代码中所需要的数据必须与其他代码共享，那就看看这些**共享数据的代码**是否能保证在**同一个线程中执行**。如果能保证，我们就可以把共享数据的**可见范围限制**在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用**线程本地存储**来解决线程安全问题。

可以使用 java.lang.**ThreadLocal** 类来实现线程本地存储功能。

对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。互不影响。

```java
public class ThreadLocalExample {
    public static void main(String[] args) {
        ThreadLocal threadLocal = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal.set(1);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(threadLocal.get());
            threadLocal.remove();
        });
        Thread thread2 = new Thread(() -> {
            threadLocal.set(2);
            threadLocal.remove();
        });
        thread1.start();
        thread2.start();
    }
}
```

```html
1
```

为了理解 ThreadLocal，先看以下代码：

```java
public class ThreadLocalExample1 {
    public static void main(String[] args) {
        ThreadLocal threadLocal1 = new ThreadLocal();
        ThreadLocal threadLocal2 = new ThreadLocal();
        Thread thread1 = new Thread(() -> {
            threadLocal1.set(1);
            threadLocal2.set(1);
        });
        Thread thread2 = new Thread(() -> {
            threadLocal1.set(2);
            threadLocal2.set(2);
        });
        thread1.start();
        thread2.start();
    }
}
```

它所对应的底层结构图为：T1 T2为两个线程。

![1563602247293](assets/1563602247293.png)

每个 Thread 都有一个 **ThreadLocal.ThreadLocalMap 对象**。

```java
/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;
```

当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 **ThreadLocalMap 对象**，然后将 ThreadLocal->value 键值对插入到该 Map 中。

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

get() 方法类似。

```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为**根本不存在多线程竞争**。

在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal **有内存泄漏的情况**，应该尽可能在每次使用 ThreadLocal 后**手动调用 remove()**，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。

##### 3. 可重入代码（Reentrant Code）

这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻**中断它**，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。







## 七、其他

### 锁优化

这里的锁优化主要是指 JVM 对 **synchronized** 的优化。

#### 自旋锁

互斥同步进入阻塞状态的开销都很大，应该**尽量避免**。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时**执行忙循环（自旋）**一段时间，如果在这段时间内能获得锁，就可以**避免**进入阻塞状态。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作**占用 CPU** 时间，它只适用于共享数据的**锁定状态很短**的场景。如果太长就太多的忙循环了。

在 JDK 1.6 中引入了**自适应的自旋锁**。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。

------

#### 锁消除

锁消除是指对于被检测出**不可能存在竞争**的共享数据的**锁进行消除**。

锁消除主要是通过**逃逸分析**来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成**私有数据**对待，也就可以将它们的锁进行消除。

对于一些看起来没有加锁的代码，其实**隐式的加了很多锁**。例如下面的字符串拼接代码就隐式加了锁：

```java
public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 **之前**，会转化为 StringBuffer 对象的连续 append() 操作：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

每个 append() 方法中都有一个**同步块**。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此**可以进行消除**。

------

#### 锁粗化

如果一系列的连续操作都对**同一个对象**反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到**整个操作序列**的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。

------

#### 轻量级锁

JDK 1.6 引入了**偏向锁和轻量级锁**，从而让锁拥有了四个状态：**无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）**。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

![1563602275691](assets/1563602275691.png)

下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

![1563602285907](assets/1563602285907.png)

轻量级锁是相对于传统的重量级锁而言，它**使用 CAS 操作**来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以**先采用 CAS 操作**进行同步，如果 CAS 失败了**再改用互斥量**进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

![1563602294897](assets/1563602294897.png)

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入**同步块**继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要**膨胀为重量级锁**。

------

#### 偏向锁

偏向锁的思想是偏向于让**第一个**获取锁对象的线程，这个线程在**之后获取该锁**就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

当锁对象第一次被线程获得的时候，进入**偏向状态**，标记为 **1 01**。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就**不需要再进行任何同步**操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时**撤销偏向**（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

![1563602307402](assets/1563602307402.png)





###  多线程开发良好的实践

- 给线程起个有意义的**名字**，这样可以方便找 Bug。
- 缩小**同步范围**，从而减少锁争用。例如对于 synchronized，应该**尽量使用同步块**而不是同步方法。
- 多用**同步工具**少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。
- 使用 BlockingQueue 实现**生产者消费者**问题。
- 多用**并发容器**少用同步容器，例如应该使用 ConcurrentHashMap 而不是 Hashtable。同步容器开销太大。
- 使用**本地变量和不可变类**来保证线程安全。
- 使用**线程池**而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。







### 参考资料

- BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.
- 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.
- [Threads and Locks](https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html)
- [线程通信](http://ifeve.com/thread-signaling/#missed_signal)
- [Java 线程面试题 Top 50](http://www.importnew.com/12773.html)
- [BlockingQueue](http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html)
- [thread state java](https://stackoverflow.com/questions/11265289/thread-state-java)
- [Java - Understanding Happens-before relationship](https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html)
- [6장 Thread Synchronization](https://www.slideshare.net/novathinker/6-thread-synchronization)
- [How is Java's ThreadLocal implemented under the hood?](https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015)
- [Concurrent](https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&showPrintDialog=1)
- [JAVA FORK JOIN EXAMPLE](http://www.javacreed.com/java-fork-join-example/ "Java Fork Join Example")
- [聊聊并发（八）——Fork/Join 框架介绍](http://ifeve.com/talk-concurrency-forkjoin/)



