[TOC]



## 一、反射

#### 反射概述

能够分析类能力的程序称为**反射**。可以在运行时分析类的能力，运行时查看对象。
每个类都有一个  **Class**  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

类加载相当于 **Class 对象**的加载，类在**第一次使用**时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 **Class 对象**。

反射可以提供**运行时**的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。



**1.反射的优点：** 

- **可扩展性**  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境**  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具**  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

**2.反射的缺点：** 

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销**  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制**  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露**  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

------

#### Class类

##### 概述

- 所有对象都有一个被称为运行时的**类型标识**，这个信息跟踪着每个对象所属的类。保存这些信息的类称为**Class类**。
- Object 类中的 **getClass()** 方法会返回一个 Class 类型的实例。
- 获取 Class 类对象的几种方法。

```java
// 方法1
Employee e;
Class cl = e.getClass();    // 通过对象继承的Object类的getClass()方法获取

// 方法2
String className = "java.util.Random";  // 类名或接口名的字符串 全限定名
Class cl = Class.forName(className);    // 使用静态方法Class.forName()可能会抛出异常

// 方法3
Class cl1 = Random.class;   // If you improt java.util.*;
Class cl2 = int.class;
Class cl3 = Double[].class;
// 如果T是任意的Java类型，则T.class将代表匹配的类对象。
```

- Class类实际是一个**泛型类**。如Employee.class的类型是Class\<Employee>。
- 虚拟机为每个类型管理一个Class对象。可以用 == 运算符实现两个类对象比较的操作。

```java
if(e.getClass() == Employee.class){...}
```

- newInstance() 方法可以**动态创建一个类的实例对象**。会调用**默认**构造方法，没有就会报错。

```java
String s = "java.util.Random";
Object m = Class.forName(s).newInstance();  // 根据类名字符串获取对应的对象
```

##### 相关API

```java
// java.lang.Class类
static Class forName(String className);     // 根据传入的类名字符串返回对应Class类对象
Object newInstance();       // 返回这个类的一个新的实例，调用无参构造方法。有参构造器使用下面的API

// java.lang.reflect.Constructor类
Object newInstance(Object[] args);      // 构造一个这个构造器所属类的新实例，使用提供的参数
```

------

#### 利用反射分析类

- java.lang.reflect有三个类 Field (描述类的**域**)、Method (描述类的**方法**)和 Constructor (描述类的**构造器**)。利用这三个类可以分析一个类的结构。
- Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
    - **Field** ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的**字段**（属性）；
    - **Method** ：可以使用 invoke() 方法调用与 Method 对象关联的**方法**；
    - **Constructor** ：可以用 Constructor 表示构造方法。

|     类      |       用途       |
| :---------: | :--------------: |
|    Field    |    描述类的域    |
|   Method    |   描述类的方法   |
| Constructor | 描述类的构造方法 |



##### 相关API

```java
/**
* java.lang.Class类
*/
Field[] getFileds();        // 获取该类或其超类的public域
Field[] getDeclaredField(); // 获取全部域
Method[] getMethods();      // 获取该类或其超类的public方法
Method[] getDeclaredMethods();      // 获取全部方法
Constructor[] getConstructors();    // 获取该类或其超类的public构造器
Constructor[] getDeclaredConstructors();    // 获取全部构造器
```

上述三组方法返回的是三种类型的数组。可以对其进行分析得到类的信息。

```java
/**
* java.lang.reflect.Field           
* java.lang.reflect.Method          
* java.lang.reflect.Constructor
*/
// 下面的API是上述三个类都有的方法
Class getDeclaringClass();  // 返回一个用于描述类中定义的构造器、方法或域的Class对象
int gerModifires();         // 返回域、方法或构造器的修饰符的整型数值。Modifier类可以分析这个值从而判断出private、public等修饰符
String getName();           // 返回对应的字符串名称
// 下面的API是Method和Constructor类有的方法
Class[] getExceptionTypes();// 返回异常类型
Class[] getParameterTypes();// 返回参数类型
// 仅在Method类中有
Class getReturnType();      // 返回描述返回类型的Class对象
```

------

##### 在运行时通过反射分析对象

可以使用 Field 类来对对象的**域值**进行获取与设置。

```java
/**
* java.lang.reflect.Field类
*/
Object get(Object obj);     // 返回obj对象中用Field对象表示的域值
void set(Object obj, Object newValue);  // 用一个新的值设置Obj对象中Field对象表示的域
```

```java
public class Employee{
    private double salary;        // Employee类的域
    private String name;
}

Employee harry = new Employee(44231.0, "Harry");    // 构造Employee类的对象harry
Class cl = harry.getClass();                        // 获取对应的Class类
Field[] fields = cl.getDeclaredFields();            // 通过Class类获取声明的所有方法
// 因为Employee类的域为private，因此受限于访问控制。此处设置为允许访问
AccessibleObject.setAccessible(fields, ture);       // 允许全部的private域被访问
Field fd = cl.getDeclaredField("name");             // 根据域的名称仅获取一个Field类
fd.setAccessible(true);                             // 仅设置name域被访问
// 以下是设置和获取对象阈值的方法！！！
Object v = fd.get(harry);                           // 通过域和对象共同获取对象的域值
fd.set(harry, "Harry Porter");                      // 通过域和对象对域值进行设置
```

------

#### 使用反射编写泛型数组代码

以下是利用反射进行**数组容量拓展**的方法。

```java
/**
 * 此方法可以复制原有的对象数组并实现扩容
 * @param a 是准备扩容的数组
 * @return 返回一个容量更大且包含a的数组
 */
public static Object goodCopyOf(Object a, int newLength) {
    Class cl = a.getClass();      // 获取a的Class对象
    if (!cl.isArray()) return null;   
    Class componentType = cl.getComponentType();  // 获取类型
    int length = Array.getLength(a);              // 获取原本数组的长度
    // 根据类型和新长度产生新的空白数组
    Object newArray = Array.newInstance(componentType, newLength);    
    // 把原本的数组a拷贝到新的容量大的数组中
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); 
    return newArray;
}
```

------

#### 调用任意方法

- Method类有一个 **invoke() 方法**，允许调用包装在当前 **Method对象** 中的方法。即调用Method对象指向的方法。
- invoke 方法的签名。第一个是隐式参数，其余的是显示参数。静态方法第一个参数为null。
- 如果返回类型是基本类型，invoke方法会返回其包装器类型。
- invoke方法的返回类型和参数都是Object类型的，这就意味着需要进行多次类型转换。

```java
// 调用这个对象所描述的方法，传递给定参数，并返回方法的返回值。对于静态方法把null作为隐式参数传递
Object invoke(Object implictParameter, Object... explicitParameters);  
```

```java
// 例子
Employee harry = new Employee(44231.0, "Harry");    // 构造Employee类的对象harry
Class cl = harry.getClass();                        // 获取对应的Class类
Method m1 = cl.getMethod("getName");                // 通过方法名获取Method对象
String s = (String)m1.invoke(harry);                // 调用方法并类型转换结果

Method m2 = Employee.class.getMethod("getSalary", double.class);  // 获取另一个方法
// 如果返回类型是基本类型，invoke方法会返回其包装器类型
double salary = (Double)m2.invoke(harry);           // 注意salary是基本类型 返回的是包装器类
```











## 二、注解

### 注解概述

#### 什么是注解

它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于**包、类型、构造方法、方法、成员变量、参数及本地变量**的声明语句中。

Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。

---

#### 注解用途

1、生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等；
2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处;
3、在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。

---

#### 注解原理

注解本质是一个继承了**Annotation** 的特殊接口，其具体实现类是 Java 运行时生成的**动态代理类**。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 **$Proxy1**。通过代理对象调用自定义注解（接口）的方法，会最终调用 AnnotationInvocationHandler 的 **invoke** 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是 Java 常量池。

---

#### 元注解

java.lang.annotation 提供了四种元注解，专门**注解其他的注解**（在自定义注解的时候，需要使用到元注解）

|   元注解    |            用途             |
| :---------: | :-------------------------: |
| @Retention  |     什么时候使用该注解      |
|   @Target   |      注解用于什么地方       |
| @Documented | 注解是否将包含在 JavaDoc 中 |
| @Inherited  |   是否允许子类继承该注解    |

**@Retention**

定义该注解的生命周期。可用的参数为有：

-  RetentionPolicy.SOURCE : 在**编译阶段**丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。
- RetentionPolicy.CLASS : 在**类加载**的时候丢弃。在字节码文件的处理中有用。注解**默认**使用这种方式。
- RetentionPolicy.RUNTIME : 始终**不会丢弃**，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们**自定义**的注解**通常**使用这种方式。

**@Target**

表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的 ElementType 参数包括：

- ElementType.CONSTRUCTOR: 用于描述构造器
- ElementType.FIELD: 成员变量、对象、属性（包括enum实例）
- ElementType.LOCAL_VARIABLE: 用于描述局部变量
- ElementType.METHOD: 用于描述方法
- ElementType.PACKAGE: 用于描述包
- ElementType.PARAMETER: 用于描述参数
- ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明

**@Documented** 

一个简单的 Annotations 标记注解，表示是否将注解信息添加在 JavaDoc 文档中。

**@Inherited** 

定义该注释和子类的关系，是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。

----

#### 常见标准注解

**@Override**
      java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。
**@Deprecated**
     Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。
**@SuppressWarnings**
     SuppressWarning 不是一个标记类型注解。它有一个类型为**String[]** 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对@SuppressWarings 有效，同时编译器忽略掉无法识别的警告名。

```java
@SuppressWarnings("unchecked")
```



### 自定义注解

#### 自定义注解概述

自定义注解类编写的一些规则:

- Annotation 型定义为 @interface, 所有的 Annotation 会自动继承 java.lang.Annotation这一接口,并且不能再去继承别的类或是接口。
- 参数成员只能用public 或默认(default) 这两个访问权修饰。
- 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean 八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组。
- 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法。
- 注解也可以没有定义成员,，不过这样注解就没啥用了。PS:自定义注解需要使用到元注解



#### 自定义注解实例

**FruitName.java**

```java
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * 自定义水果名称注解
 */
@Target(FIELD)
@Retention(RUNTIME)
@Documented
public @interface FruitName {
    // String类型
    String value() default "";
}
```

**FruitColor.java**

```java
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * 自定义水果颜色注解
 */
@Target(FIELD)
@Retention(RUNTIME)
@Documented
public @interface FruitColor {
    /**
     * 颜色枚举
     */
    public enum Color{ BLUE,RED,GREEN};
    
    /**
     * 颜色属性
     */
    Color fruitColor() default Color.GREEN;
}
```

**FruitProvider.java**

```java
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

/**
 * 自定义水果供应者注解
 */
@Target(FIELD)
@Retention(RUNTIME)
@Documented
public @interface FruitProvider {
    /**
     * 供应商编号
     */
    public int id() default -1;
    
    /**
     * 供应商名称
     */
    public String name() default "";
    
    /**
     * 供应商地址
     */
    public String address() default "";
}
```

**FruitInfoUtil.java**

通过反射实现内容获取

```java
import java.lang.reflect.Field;

/**
 * 注解处理器
 */
public class FruitInfoUtil {
    public static void getFruitInfo(Class<?> clazz){
        
        String strFruitName = " 水果名称：";
        String strFruitColor = " 水果颜色：";
        String strFruitProvicer = "供应商信息：";
        // 字段
        Field[] fields = clazz.getDeclaredFields();
        
        for(Field field : fields){
            // 水果名称
            if(field.isAnnotationPresent(FruitName.class)){
                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);
                strFruitName = strFruitName+fruitName.value();
                System.out.println(strFruitName);
            }
            // 水果颜色
            else if(field.isAnnotationPresent(FruitColor.class)){
                FruitColor fruitColor = (FruitColor) field.getAnnotation(FruitColor.class);
                strFruitColor = strFruitColor + fruitColor.fruitColor().toString();
                System.out.println(strFruitColor);
            }
            // 水果供应商
            else if(field.isAnnotationPresent(FruitProvider.class)){
                FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);
                strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称：" + fruitProvider.name() + " 供应商地址：" + fruitProvider.address();
                System.out.println(strFruitProvicer);
            }
        }
    }
}
```

**Apple.java**

定义一个水果类

```java
import test.FruitColor.Color;

/**
 * 注解使用
 */
public class Apple {
    
    @FruitName("Apple")
    private String appleName;
    
    @FruitColor(fruitColor = Color.RED)
    private String appleColor;
    
    @FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路89号红富士大厦")
    private String appleProvider;
    
    public void setAppleColor(String appleColor) {
        this.appleColor = appleColor;
    }
    public String getAppleColor() {
        return appleColor;
    }
    
    public void setAppleName(String appleName) {
        this.appleName = appleName;
    }
    public String getAppleName() {
        return appleName;
    }
    
    public void setAppleProvider(String appleProvider) {
        this.appleProvider = appleProvider;
    }
    public String getAppleProvider() {
        return appleProvider;
    }
    
    public void displayName(){
        System.out.println("水果的名字是：苹果");
    }
}
```

**FruitRun.java**

测试类

```java
/**
 * 输出结果
 */
public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);
    }
}
```

输出：

```html
 水果名称：Apple
 水果颜色：RED
 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦
```











### 参考资料

- [注解概述及实用](https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html)







## 三、动态代理

动态代理在 Java 中有着广泛的应用，比如 Spring AOP、Hibernate 数据查询、测试框架的后端 mock、RPC 远程调用、Java 注解对象获取、日志、用户鉴权、全局性异常处理、性能监控，甚至事务处理等。

两种常见的动态代理方式：JDK 原生动态代理和 CGLIB 动态代理。



### 代理模式

本文将介绍的Java动态代理与设计模式中的代理模式有关，什么是代理模式呢？

**代理模式**：给某一个对象提供一个代理，并由**代理对象**来控制对真实对象的访问。代理模式是一种结构型设计模式。

代理模式角色分为 3 种：

**Subject（抽象主题角色）**：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；

**RealSubject（真实主题角色**）：真正实现业务逻辑的类；

**Proxy（代理主题角色）**：用来代理和封装真实主题；

代理模式的结构比较简单，其核心是代理类，为了让客户端能够**一致性地对待**真实对象和代理对象，在代理模式中引入了抽象层

![1567738313503](assets/1567738313503.png)

代理模式**按照职责**（使用场景）来分类，至少可以分为以下几类：1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理等等。

如果**根据字节码的创建时机**来分类，可以分为**静态代理和动态代理**：

- 所谓**静态**也就是在**程序运行前**就已经存在代理类的**字节码文件**，代理类和真实主题角色的关系在运行前就确定了。
- 而动态代理的源码是在程序运行期间由 **JVM** 根据**反射**等机制**动态的生成**，所以在运行前并不存在代理类的字节码文件。



### 静态代理

#### 静态代理实例

编写一个接口 UserService ，以及该接口的一个实现类 UserServiceImpl。

```java
public interface UserService {
    public void select();   
    public void update();
}

public class UserServiceImpl implements UserService {  
    public void select() {  
        System.out.println("查询 selectById");
    }
    public void update() {
        System.out.println("更新 update");
    }
}
```

我们将通过静态代理对 UserServiceImpl 进行功能增强，在调用 `select` 和 `update` 之前记录一些**日志**。写一个代理类 **UserServiceProxy**，代理类需要实现 **UserService**.

```java
public class UserServiceProxy implements UserService {
    // 被代理的对象
    private UserService target; 

    public UserServiceProxy(UserService target) {
        this.target = target;
    }
    public void select() {
        before();
        // 这里才实际调用真实主题角色的方法
        target.select();    
        after();
    }
    public void update() {
        before();
        // 这里才实际调用真实主题角色的方法
        target.update();    
        after();
    }

    // 在执行方法之前执行
    private void before() {     
        System.out.println(String.format("log start time [%s] ", new Date()));
    }
    // 在执行方法之后执行
    private void after() {      
        System.out.println(String.format("log end time [%s] ", new Date()));
    }
}

```

客户端测试

```java
public class Client1 {
    public static void main(String[] args) {
        UserService userServiceImpl = new UserServiceImpl();
        UserService proxy = new UserServiceProxy(userServiceImpl);

        proxy.select();
        proxy.update();
    }
}
```

输出

```java
log start time [Thu Dec 20 14:13:25 CST 2018] 
查询 selectById
log end time [Thu Dec 20 14:13:25 CST 2018] 
log start time [Thu Dec 20 14:13:25 CST 2018] 
更新 update
log end time [Thu Dec 20 14:13:25 CST 2018] 
```

通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码，这是静态代理的一个优点。



#### 静态代理的缺点

虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微**复杂**一些的时候，静态代理的缺点也会暴露出来。

1、 当需要代理**多个类**的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：

- 只维护**一个代理类**，由这个代理类实现**多个接口**，但是这样就导致**代理类过于庞大**
- 新建**多个代理类**，每个目标对象对应**一个代理类**，但是这样会**产生过多的代理类**

2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，**不易维护**。



#### 如何改进？

当然是让**代理类动态的生成**，也就是动态代理。

**为什么类可以动态的生成？**

这就涉及到 Java 虚拟机的**类加载机制**了，推荐翻看《深入理解Java虚拟机》7.3节 类加载的过程。

Java 虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下 3 件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据访问入口

由于虚拟机规范对这 3 点要求并不具体，所以实际的实现是非常灵活的，关于第1点，**获取类的二进制字节流**（**class字节码**）就有很多途径：

- 从 ZIP 包获取，这是 JAR、EAR、WAR 等格式的基础
- 从网络中获取，典型的应用是 Applet
- **运行时计算生成**，这种场景使用最多的是动态代理技术，在 java.lang.reflect.**Proxy** 类中，就是用了 ProxyGenerator.**generateProxyClass** 来为特定接口生成形式为 `*$Proxy` 的代理类的二进制字节流
- 由其它文件生成，典型应用是 JSP，即由 JSP 文件生成对应的 Class 类
- 从数据库中获取等等

所以，动态代理就是想办法，根据接口或目标对象，**计算出代理类的字节码，然后再加载到JVM中使用**。但是如何计算？如何生成？情况也许比想象的复杂得多，我们需要借助现有的方案。

#### 常见的字节码操作类库

> 这里有一些介绍:

- Apache BCEL (Byte Code Engineering Library)：是 Java classworking 广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。
- ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。
- CGLIB(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。
- Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。
- ...

**实现动态代理的思考方向**

为了让生成的代理类与目标对象（真实主题角色）保持一致性，从现在开始将介绍以下两种最常见的方式：

1. 通过**实现接口**的方式 -> **JDK** 动态代理
2. 通过**继承类**的方式 -> **CGLIB **动态代理

注：使用 ASM 对使用者要求比较高，使用 Javassist 会比较麻烦



### 动态代理

JDK 动态代理主要涉及两个类：`java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler`。

#### 使用案例

编写一个调用逻辑处理器 LogHandler 类，提供**日志增强**功能，并实现 InvocationHandler 接口；在 LogHandler 中维护一个**目标对象**，这个**对象是被代理的对象**（真实主题角色）；在 `invoke` 方法中编写方法调用的逻辑处理。

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Date;

public class LogHandler implements InvocationHandler {
    // 被代理的对象，实际的方法执行者
    Object target;  

    public LogHandler(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 调用invoke方法之前执行
        before();
        // 反射调用 target 的 method 方法
        Object result = method.invoke(target, args); 
        // 调用invoke方法之后执行
        after();
        // 返回方法的执行结果
        return result;  
    }
    
    // 调用invoke方法之前执行
    private void before() {
        System.out.println(String.format("log start time [%s] ", new Date()));
    }
    
    // 调用invoke方法之后执行
    private void after() {
        System.out.println(String.format("log end time [%s] ", new Date()));
    }
}
```

编写客户端，获取**动态生成的代理类的对象**须借助 **Proxy** 类的 **newProxyInstance** 方法，具体步骤可见代码和注释

```java
import proxy.UserService;
import proxy.UserServiceImpl;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class Client2 {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException {
        // 设置变量可以保存动态代理类，默认名称以 $Proxy0 格式命名
        // System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
        // 1. 创建被代理的对象，UserService接口的实现类
        UserServiceImpl userServiceImpl = new UserServiceImpl();
        // 2. 获取对应的 ClassLoader
        ClassLoader classLoader = userServiceImpl.getClass().getClassLoader();
        // 3. 获取所有接口的Class，这里的UserServiceImpl只实现了一个接口UserService
        Class[] interfaces = userServiceImpl.getClass().getInterfaces();
        // 4. 创建一个将传给代理类的调用请求处理器，处理所有的代理对象上的方法调用
        //     这里创建的是一个自定义的日志处理器，须传入实际的执行对象 userServiceImpl
        InvocationHandler logHandler = new LogHandler(userServiceImpl);
        /*
		   5.根据上面提供的信息，创建代理对象 在这个过程中，
               a.JDK会通过根据传入的参数信息动态地在内存中创建和.class 文件等同的字节码
               b.然后根据相应的字节码转换成对应的class，
               c.然后调用newInstance()创建代理实例
		 */
        UserService proxy = (UserService) Proxy.newProxyInstance(classLoader, interfaces, logHandler);
        // 调用代理的方法
        proxy.select();
        proxy.update();
        
        // 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy
        // ProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy");
    }
}
```

运行结果

```java
log start time [Thu Dec 20 16:55:19 CST 2018] 
查询 selectById
log end time [Thu Dec 20 16:55:19 CST 2018] 
log start time [Thu Dec 20 16:55:19 CST 2018] 
更新 update
log end time [Thu Dec 20 16:55:19 CST 2018] 
```

#### 关键类

InvocationHandler 和 Proxy 的主要方法介绍如下：

**java.lang.reflect.InvocationHandler**

`Object invoke(Object proxy, Method method, Object[] args)` 定义了**代理对象调用方法时希望执行的动作**，用于集中处理在动态代理类对象上的方法调用。

**java.lang.reflect.Proxy**

```java
// 用于获取指定代理对象所关联的调用处理器
static InvocationHandler getInvocationHandler(Object proxy);  
// 返回指定接口的代理类
static Class<?> getProxyClass(ClassLoader loader, Class<?>... interfaces); 
// 构造实现指定接口的代理类的一个新实例，所有方法会调用给定处理器对象的 invoke 方法
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h); 
// 返回 cl 是否为一个代理类
static boolean isProxyClass(Class<?> cl); 
```



#### 代理类的调用过程

**生成的代理类**到底长什么样子呢？借助下面的工具类，把代理类保存下来再探个究竟
 （通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类）

```java
import sun.misc.ProxyGenerator;
import java.io.FileOutputStream;
import java.io.IOException;

public class ProxyUtils {
    /**
     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下
     * params: clazz 需要生成动态代理类的类
     * proxyName: 为动态生成的代理类的名称
     */
    public static void generateClassFile(Class clazz, String proxyName) {
        // 根据类信息和提供的代理类名称，生成字节码
        byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());
        String paths = clazz.getResource(".").getPath();
        System.out.println(paths);
        FileOutputStream out = null;
        try {
            // 保留到硬盘中
            out = new FileOutputStream(paths + proxyName + ".class");
            out.write(classFile);
            out.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

然后在 Client2 测试类的 main 的最后面加入一行代码

```java
// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy
ProxyUtils.generateClassFile(userServiceImpl.getClass(), "UserServiceProxy");
```

IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件。

![1567739490127](assets/1567739490127.png)

UserServiceProxy 的代码如下所示：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;
import proxy.UserService;

public final class UserServiceProxy extends Proxy implements UserService {
    private static Method m1;
    private static Method m2;
    private static Method m4;
    private static Method m0;
    private static Method m3;

    public UserServiceProxy(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        // 省略...
    }

    public final String toString() throws  {
        // 省略...
    }

    public final void select() throws  {
        try {
            super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        // 省略...
    }

    public final void update() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m4 = Class.forName("proxy.UserService").getMethod("select");
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m3 = Class.forName("proxy.UserService").getMethod("update");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

从 UserServiceProxy 的代码中我们可以发现：

- UserServiceProxy **继承**了 Proxy 类，并且实现了被代理的所有接口，以及equals、hashCode、toString等方法
- 由于 UserServiceProxy 继承了 Proxy 类，所以每个代理类都会关联一个 InvocationHandler 方法调用处理器
- 类和所有方法都被 `public final` 修饰，所以代理类只可被使用，不可以再被继承
- 每个方法都有一个 **Method** 对象来描述，Method 对象在static静态代码块中创建，以 `m + 数字` 的格式命名
- 调用方法的时候通过 `super.h.invoke(this, m1, (Object[])null);` 调用，其中的 `super.h.invoke` 实际上是在创建代理的时候传递给 `Proxy.newProxyInstance` 的 LogHandler 对象，它继承 InvocationHandler 类，负责实际的调用处理逻辑

而 LogHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过**反射**让被代理的对象 target 执行方法

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    before();
    // 调用 target 的 method 方法
    Object result = method.invoke(target, args);       
    after();
    return result;  // 返回方法的执行结果
}
```

JDK动态代理执行方法调用的过程简图如下：



![JDK动态代理执行方法调用过程](https://user-gold-cdn.xitu.io/2018/12/21/167cff3ba6d23d8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



代理类的调用过程相信大家都明了了，而关于Proxy的源码解析，还请大家另外查阅其他文章或者直接看源码



#### CGLIB动态代理

maven 引入 CGLIB 包，然后编写一个 UserDao 类，它没有接口，只有两个方法，select() 和 update()

```java
public class UserDao {
    public void select() {
        System.out.println("UserDao 查询 selectById");
    }
    public void update() {
        System.out.println("UserDao 更新 update");
    }
}
```

编写一个 LogInterceptor ，继承了 MethodInterceptor，用于方法的拦截回调

```java
import java.lang.reflect.Method;
import java.util.Date;

public class LogInterceptor implements MethodInterceptor {
    /**
     * @param object 表示要进行增强的对象
     * @param method 表示拦截的方法
     * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int-->Integer、long-Long、double-->Double
     * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用
     * @return 执行结果
     * @throws Throwable
     */
    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        // 注意这里是调用 invokeSuper 而不是 invoke，否则死循环，methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法
        Object result = methodProxy.invokeSuper(object, objects);   
        after();
        return result;
    }
    private void before() {
        System.out.println(String.format("log start time [%s] ", new Date()));
    }
    private void after() {
        System.out.println(String.format("log end time [%s] ", new Date()));
    }
}
```

测试

```java
import net.sf.cglib.proxy.Enhancer;

public class CglibTest {
    public static void main(String[] args) {
        DaoProxy daoProxy = new DaoProxy(); 
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Dao.class);  // 设置超类，cglib是通过继承来实现的
        enhancer.setCallback(daoProxy);

        Dao dao = (Dao)enhancer.create();   // 创建代理类
        dao.update();
        dao.select();
    }
}
```

运行结果

```java
log start time [Fri Dec 21 00:06:40 CST 2018] 
UserDao 查询 selectById
log end time [Fri Dec 21 00:06:40 CST 2018] 
log start time [Fri Dec 21 00:06:40 CST 2018] 
UserDao 更新 update
log end time [Fri Dec 21 00:06:40 CST 2018] 
```

还可以进一步多个 MethodInterceptor 进行过滤筛选

```java
public class LogInterceptor2 implements MethodInterceptor {
    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        Object result = methodProxy.invokeSuper(object, objects);
        after();
        return result;
    }
    private void before() {
        System.out.println(String.format("log2 start time [%s] ", new Date()));
    }
    private void after() {
        System.out.println(String.format("log2 end time [%s] ", new Date()));
    }
}

// 回调过滤器: 在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。
public class DaoFilter implements CallbackFilter {
    @Override
    public int accept(Method method) {
        if ("select".equals(method.getName())) {
            return 0;   // Callback 列表第1个拦截器
        }
        return 1;   	// Callback 列表第2个拦截器，return 2 则为第3个，以此类推
    }
}
```

再次测试

```java
public class CglibTest2 {
    public static void main(String[] args) {
        LogInterceptor logInterceptor = new LogInterceptor();
        LogInterceptor2 logInterceptor2 = new LogInterceptor2();
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserDao.class);   // 设置超类，cglib是通过继承来实现的
        enhancer.setCallbacks(new Callback[]{logInterceptor, logInterceptor2, NoOp.INSTANCE});   // 设置多个拦截器，NoOp.INSTANCE是一个空拦截器，不做任何处理
        enhancer.setCallbackFilter(new DaoFilter());

        UserDao proxy = (UserDao) enhancer.create();   // 创建代理类
        proxy.select();
        proxy.update();
    }
}
```

运行结果

```java
log start time [Fri Dec 21 00:22:39 CST 2018] 
UserDao 查询 selectById
log end time [Fri Dec 21 00:22:39 CST 2018] 
log2 start time [Fri Dec 21 00:22:39 CST 2018] 
UserDao 更新 update
log2 end time [Fri Dec 21 00:22:39 CST 2018] 
```

CGLIB 创建动态代理类的模式是：

1. 查找目标类上的所有非 final 的 public 类型的方法定义；
2. 将这些方法的定义转换成字节码；
3. 将组成的字节码转换成相应的代理的 class 对象；
4. 实现 MethodInterceptor 接口，用来处理对代理类上所有方法的请求



### JDK动态代理与CGLIB动态代理对比

JDK动态代理：基于 Java 反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。

cglib 动态代理：基于 ASM 机制实现，通过生成业务类的子类作为代理类。

JDK Proxy 的优势：

- 最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。
- 平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。
- 代码实现简单。

基于类似 cglib 框架的优势：

- 无需实现接口，达到代理类无侵入
- 只操作我们关心的类，而不必为其他相关类增加工作量。
- 高性能



### 代理面试题

**Q：描述动态代理的几种实现方式？分别说出相应的优缺点**

A：代理可以分为 "静态代理" 和 "动态代理"，动态代理又分为 "JDK动态代理" 和 "CGLIB动态代理" 实现。

**静态代理**：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object

- **优点**：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。
- **缺点**：不同的接口要有不同的代理类实现，会很冗余

**JDK 动态代理**：

- 为了解决静态代理中，生成大量的代理类造成的冗余；
- JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，
- jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象
- jdk动态代理之所以**只能代理接口**是因为**代理类本身已经extends了Proxy，而java是不允许多重继承的**，但是允许实现多个接口
- **优点**：解决了静态代理中冗余的代理实现类问题。
- **缺点**：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。

**CGLIB 代理**：

- 由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；
- CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
- 实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
- 但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。
- 同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。
- **优点**：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。
- **缺点**：技术实现相对难理解些。







## 四、类加载机制

详见虚拟机相关章节。







## 五、函数式编程

### Lambda表达式

#### 基础

- Lambda表达式是一个**可传递的代码块**，可以在以后执行一次或多次。将一个代码块传递到某个对象 （一个定时器，或者一个sort 方法。) 这个代码块会在将来某个时间调用。

------

#### 语法

- 如果一个 lambda 表达式只在某些分支返回一个值， 而在另外一些分支不返回值，
    这是不合法的。 例如，（int x)-> { if (x >= 0) return 1; } 就不合法。
- lambda 表达式形式：参数， 箭头（->) 以及一个表达式。
- Lambda 表达式可以具有零个，一个或多个参数。
- 可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。
- 参数用小括号括起来，用逗号分隔。例如 `(a, b)` 或 `(int a, int b)` 或 `(String a, int b, float c)`。
- 空括号用于表示一组空的参数。例如 `() -> 42`。
- 当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 `a -> return a * a`。
- Lambda 表达式的正文可以包含零条，一条或多条语句。
- 如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。
- 如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。



```java
// 实现一个长度比较器类
class LengthComparator implements Comparator<String> {
    public int compare(String first, String second){    // 实现接口方法
        return first.lenth - second.length();
    }
}

// 使用接口
String[] names = {"Bob", "Jack", "Alice"};
Arrays.sor(names, new LengthComparator());
```

义务代码仅一句

```java
first.lenth - second.length();
```

上述改为Lambda表达式

```java
// 仅一句代码
(String first, String second) 
    -> first.lenth - second.length()        // 此处无需指定返回类型，返回类型总是由上下文推断而出
    
// 代码块
(String first, String second) -> {
    // 需要return值时必须每个分支都要return值
    if (first.lengthO < second.lengthO) return -1;
    else if (first.lengthO > second.lengthO) return 1;
    else return 0;
} 
```

其他Lambda表达式

```java
// lambda 表达式没有参数， 仍然要提供空括号，就像无参数方法一样
() -> { for (int i = 100; i >= 0;i++) System.out.println(i); } 
```

------

#### 函数式接口

- 对于==只有一个抽象方法==的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达式。这种接口称为函数式接口(functional interface)。Lambda 表达式可以赋值给函数式接口。
- Arrays.sort 方法。它的第二个参数需要一个 Comparator 实例，Comparator 就是只有一个方法的接口， 所以可以提供一个lambda表达式如下。在底层， Arrays.sort方法会接收实现了Comparator\<String> 的某个类的对象。在这个对象上调用 compare 方法会执行这个 lambda 表达式的体。可以看出 lambda 表达式可以**转换**为接口。但对 lambda 表达式所能做的也只是能转换为**函数式接口**。

```java
Arrays.sort (words, (first , second) -> first.length() - second.length()) ;
```

- 如果设计的接口只有一个抽象方法，可以用@FunctionalInterface 注解来标记这个接口。javadoc 页里会指出这是一个函数式接口。

------

#### 方法引用

例子

```java
Timer t = new Timer(1000, event -> System.out.println(event));  // Lambda表达式
Timer t = new Timer(1000, System.out::println);     // 方法引用 两者等价
```

**System.out::println**是一个方法引用，与上述的Lambda表达式等价。

要用 :: 操作符分隔方法名与对象或类名。主要有 3 种情况：

- **object::instanceMethod**
- **Class::staticMethod**
- **Class::instanceMethod**

前 2 种情况中， 方法引用等价于提供方法参数的 lambda 表达式。对于第 3 种情况， 第 1 个参数会成为方法的目标。例如，String::compareToIgnoreCase 等同于 (x, y)-> x.compareToIgnoreCase(y)。

可以在方法引用中使用 this 参数。 例如， this::equals 等同于 x -> this.equals(x)。 使用
super 也是合法的。下面的方法表达式 super::instanceMethod使用 this作为目标，会调用给定方法的超类版本。

**从 Lambda 表达式到双冒号操作符**

要创建一个比较器，以下语法就足够了

```
Comparator c = (Person p1, Person p2) -> p1.getAge().compareTo(p2.getAge());
```

然后，使用类型推断：

```
Comparator c = (p1, p2) -> p1.getAge().compareTo(p2.getAge());
```

但是，我们可以使上面的代码更具表现力和可读性吗？我们来看一下：

```
Comparator c = Comparator.comparing(Person::getAge);
```

使用 `::` 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。

**使用方式**

双冒号（`::`）操作符是 Java 中的**方法引用**。 当们使用一个方法的引用时，目标引用放在 `::` 之前，目标引用提供的方法名称放在 `::` 之后，即 `目标引用::方法`。比如：

```java
Person::getAge;
```

在 `Person` 类中定义的方法 `getAge` 的方法引用。

然后我们可以使用 `Function` 对象进行操作：

```java
// 获取 getAge 方法的 Function 对象
Function<Person, Integer> getAge = Person::getAge;
// 传参数调用 getAge 方法
Integer age = getAge.apply(p);
```

我们引用 `getAge`，然后将其应用于正确的参数。

目标引用的参数类型是 `Function<T,R>`，`T` 表示传入类型，`R` 表示返回类型。比如，表达式 `person -> person.getAge();`，传入参数是 `person`，返回值是 `person.getAge()`，那么方法引用 `Person::getAge` 就对应着 `Function<Person,Integer>` 类型。

------

#### 构造器引用

- 构造器引用与方法引用很类似，只不过**方法名为 new**。例如， Person::new 是 Person 构造
    器的一个引用。调用哪个构造器取决于上下文。
- Java 有一个限制，无法构造泛型类型 T 的数组。数组构造器引用对于克服这个限制很有用。

------

#### 变量作用域

- lambda 表达式可以==捕获==外围作用域中变量的值。
- 在 lambda 表达式中， 只能引用==值不会改变==的变量。lambda表达式中捕获的变量必须实际上是最终变量 ( effectivelyfinal)。实际上的最终变量是指， 这个变量初始化之后就不会再为它赋新值。
- 在 Java 中， lambda 表达式就是**闭包**。

------

#### 处理Lambda表达式

Lambda表达式使用场景:

- 在一个单独的线程中运行代码；
- 多次运行代码；
- 在算法的适当位置运行代码 （例如， 排序中的比较操作；)
- 发生某种情况时执行代码 （如， 点击了一个按钮， 数据到达， 等等；)
- 只在必要时才运行代码。



#### Lambda 表达式例子

**线程初始化**

线程可以初始化如下：

```java
// Old way
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello world");
    }
}).start();

// New way
new Thread(
    () -> System.out.println("Hello world")
).start();
```

**事件处理**

事件处理可以用 Java 8 使用 Lambda 表达式来完成。以下代码显示了将 `ActionListener` 添加到 UI 组件的新旧方式：

```java
// Old way
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Hello world");
    }
});

// New way
button.addActionListener( (e) -> {
        System.out.println("Hello world");
});
```

**遍例输出（方法引用）**

输出给定数组的所有元素的简单代码。请注意，还有一种使用 Lambda 表达式的方式。

```java
// old way
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
for (Integer n : list) {
    System.out.println(n);
}

// 使用 -> 的 Lambda 表达式
list.forEach(n -> System.out.println(n));

// 使用 :: 的 Lambda 表达式
list.forEach(System.out::println);
```

**逻辑操作**

输出通过逻辑判断的数据。

```java
package com.wuxianjiezh.demo.lambda;

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class Main {

    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);

        System.out.print("输出所有数字：");
        evaluate(list, (n) -> true);

        System.out.print("不输出：");
        evaluate(list, (n) -> false);

        System.out.print("输出偶数：");
        evaluate(list, (n) -> n % 2 == 0);

        System.out.print("输出奇数：");
        evaluate(list, (n) -> n % 2 == 1);

        System.out.print("输出大于 5 的数字：");
        evaluate(list, (n) -> n > 5);
    }

    public static void evaluate(List<Integer> list, Predicate<Integer> predicate) {
        for (Integer n : list) {
            if (predicate.test(n)) {
                System.out.print(n + " ");
            }
        }
        System.out.println();
    }
}
```

运行结果：

```java
输出所有数字：1 2 3 4 5 6 7 
不输出：
输出偶数：2 4 6 
输出奇数：1 3 5 7 
输出大于 5 的数字：6 7 
```

**Stream API 示例**

`java.util.stream.Stream`接口 和 Lambda 表达式一样，都是 Java 8 新引入的。所有 `Stream` 的操作必须以 Lambda 表达式为参数。`Stream` 接口中带有大量有用的方法，比如 `map()` 的作用就是将 input Stream 的每个元素，映射成output Stream 的另外一个元素。

下面的例子，我们将 Lambda 表达式 `x -> x*x` 传递给 `map()` 方法，将其应用于流的所有元素。之后，我们使用 `forEach`打印列表的所有元素。

```java
// old way
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);
for(Integer n : list) {
    int x = n * n;
    System.out.println(x);
}

// new way
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);
list.stream().map((x) -> x*x).forEach(System.out::println);
```

下面的示例中，我们给定一个列表，然后求列表中每个元素的平方和。这个例子中，我们使用了 `reduce()` 方法，这个方法的主要作用是把 Stream 元素组合起来。

```java
// old way
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);
int sum = 0;
for(Integer n : list) {
    int x = n * n;
    sum = sum + x;
}
System.out.println(sum);

// new way
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7);
int sum = list.stream().map(x -> x*x).reduce((x,y) -> x + y).get();
System.out.println(sum);
```



#### 其他

##### Lambda 表达式和匿名类之间的区别

- `this` 关键字。对于匿名类 `this` 关键字解析为匿名类，而对于 Lambda 表达式，`this` 关键字解析为包含写入 Lambda 的类。
- 编译方式。Java 编译器编译 Lambda 表达式时，会将其转换为类的私有方法，再进行动态绑定。























