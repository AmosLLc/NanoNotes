[TOC]

### 类的继承

#### 概述

- new 的过程中，父类的构造方法先于子类执行。



#### 多态、静态绑定、动态绑定

- 一个**对象变量**能够指示**多种实际类型**的现象称为多态(比如父类变量能够引用自身类的变量和其子类的变量)。比如一个Employee对象变量能够引用一个Employee类的变量，也可以引用一个Employee类子类的变量。子类赋给父类变量，范围缩小，是容忍的。
- 对于 private、static 和 final 方法或者构造器，编译器可以准确知道要调用哪个方法，将这种调用方式成为**静态绑定**。

```java
UnderGraduateSutdent extends Students{...}

UnderGraduateSutdent ug = new UnderGraduateSutdent();
Student s = ug;		// s声明为 Student类型，也即其静态类型，此处其动态类型为UnderGraduateSutdent
s.display();
```

UnderGraduateSutdent 继承于父类 Student 类。

变量的**静态类型**是出现在**声明**中的类型。变量 s 的静态类型是 Student。 静态类型是在**编译**时确定的。

**动态类型**是指运行时某一时刻变量**指向对象**的类型。动态类型随着运行进程改变。s = ug 是的变量 s 的为 UnderGraduateSutdent 。

Java使用==动态类型==而不是使用它的名字来**确定调用哪个方法**。变量决定使用哪个方法名，而对象决定使用方法的哪个定义。

**动态绑定**实现的机制就是根据对象的**实际类型**查找要执行的方法，子类型中找不到的时候再查找父类。



#### 强制类型转换

- 子类引用赋给父类变量，编译器允许。父类引用赋给子类变量，需要强制转换。如：

```java
Child extends Father extends GrandFather{
    Father father = new Child();	// 向上转型 ojbk
    Child child = (Child)father;	// 强制转换
}
```

- 只有在**继承层次内**的才能进行强制转换。
- 在将超类转换为子类之前，应该使用 **instanceof** 进行检查
- 尽量少用类型强制转换。转换失败会抛出异常。

```java
// 标准步骤：先进行instanceof检查再强制转换！
if(staff[0] instanceof Manager){
    boss = (Manager)staff[0];
}
```

一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的**动态类型**（即引用的对象类型）是不是这个子类或者这个子类的子类。如：

```java
GrandFather grandFather = new Child();	// grandFather动态类型为Child
Father father;
Child child = new Child();   // child静态类型与动态类型均为Child
father = (Father)grandFather;	// 强制类型转换
```

因为此时 grandFather 的动态类型为child，所以能成功。



#### 访问控制

- 谨慎使用 protected 属性。
- 以下为访问控制符及其可见性。

|  修饰符   | 类内部 | 同一个包中 | 子类 | 其他类 |
| :-------: | :----: | :--------: | :--: | :----: |
|  private  |   √    |            |      |        |
|   默认    |   √    |     √      |      |        |
| protected |   √    |     √      |  √   |        |
|  public   |   √    |     √      |  √   |   √    |

可以对类或类中的成员（字段以及方法）加上访问修饰符。

- 类可见表示其它类可以用这个类创建实例对象。
- 成员可见表示其它类可以用这个类的实例对象访问到该成员；

protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。

设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或**封装**。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别**不允许低于父类的访问级别**。这是为了确保可以使用父类实例的地方都可以使用**子类实例**，也就是确保满足里氏替换原则。

==字段决不能是公有的==，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

```java
public class AccessExample {
    public String id;
}
```

可以使用公有的 getter 和 setter  方法来替换公有字段，这样的话就可以控制对字段的修改行为。

```java
public class AccessExample {
    // 字段为private
    private int id;
    
    // getter setter为public
    public String getId() {
        return id + "";
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

但是也有例外，如果是**包级私有的类或者私有的嵌套类**，那么直接暴露成员不会有特别大的影响。

```java
public class AccessWithInnerClassExample {
    
    // 内部类就还好
    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问 不用Getter Setter
    }
}
```



#### 重写与重载

**1. 重写（Override）** 

存在于**继承体系**中，指子类实现了一个与父类在**方法签名上完全相同**的一个方法。

为了满足里式替换原则，重写有以下三个限制：

- 子类方法的**访问权限**必须大于等于父类方法；
- 子类方法的**返回类型**必须是父类方法返回类型或为其**子类型**。
- 子类方法抛出的**异常类型**必须是父类抛出异常类型或为其**子类型**。

使用 **@Override 注解**，可以让编译器帮忙检查是否满足上面的三个限制条件。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。
- 子类的==返回类型==为 ArrayList<Integer>，是父类返回类型 List<Integer> 的==子类==。
- 子类抛出的==异常类型==为 Exception，是父类抛出异常 Throwable 的==子类==。
- 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。

```java
// 父类
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}
// 子类
class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

在调用一个方法时，先从**本类**中查找看是否有对应的方法，如果没有查找到再到**父类**中查看，看是否有继承来的方法。否则就要对**参数进行转型**，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)

```java
/*
 * D extends C extends B extneds A
 */
class A {
    public void show(A obj) {
        System.out.println("A.show(A)");
    }

    public void show(C obj) {
        System.out.println("A.show(C)");
    }
}

class B extends A {
    @Override
    public void show(A obj) {
        System.out.println("B.show(A)");
    }
}

class C extends B {
}

class D extends C {
}
```

```java
public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
```

**2. 重载（Overload）** 

存在于**同一个类**中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同，签名不同。

应该注意的是，返回值不同而其它都相同**不算**是重载。



#### 继承的设计技巧

- 将公共操作和域放在超类
- 不要使用protected的域
- 使用继承实现 is-a 关系
- 除非所有继承的方法都有意义，否则不要使用继承
- 在覆盖方法时，不要改变预期的行为
- 使用多态，而非类型信息
- 不要过多的使用反射



