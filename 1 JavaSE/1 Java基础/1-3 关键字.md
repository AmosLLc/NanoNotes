[TOC]

### 关键字

#### final

**1. 数据** 

声明数据为**常量**，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

- 对于基本类型，final 使==数值不变==；
- 对于引用类型，final 使==引用不变==，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```java
final int x = 1;
// x = 2;  // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
```

**2. 方法** 

final 声明方法不能被子类**重写**。

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

**3. 类** 

final 声明类不允许被继承。

**4.final实例域**

- 类的实例域定义为 final，**构造器初始化之后就不能再修改**。该实例域**没有setter方法**。

```java
class Employee{
    private final String name; // final实例域 一旦通过构造器初始化之后不能更改
}
```

- final关键字也可指示变量不能再改变其==引用==

```java
private final StringBujavailder evaluations;    
// 构造器中初始化为 evaluations = new StringBuilder();
// 此时evaluations变量中的对象引用不会再指示其他的StringBuilder对象了。
// 但是当前指示的StringBuilder依然可以正常使用。
```



#### static

**1. 静态变量** 

- 静态变量：又称为**类变量**，也就是说这个变量属于类的，类所有的**实例都共享静态变量**，可以直接通过类名来访问它。静态变量在内存中**只存在一份**。
- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

```java
public class A {

    private int x;         // 实例变量
    private static int y;  // 静态变量

    public static void main(String[] args) {
        // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
        A a = new A();
        int x = a.x;    // 通过对象引用实例变量
        int y = A.y;    // 通过类名引用静态变量
    }
}
```

**2. 静态方法** 

静态方法在**类加载**的时候就存在了，它不依赖于任何实例。所以静态方法**必须有实现**，也就是说它**不能是抽象方法**。

```java
public abstract class A {
    public static void func1(){
    }
    // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
}
```

==只能访问所属类的静态字段和静态方法==，方法中**不能有 this 和 super** 关键字。

```java
public class A {

    private static int x;
    private int y;

    public static void func1(){
        int a = x;      // 静态方法中使用静态变量
        // int b = y;   // 静态方法中不能引用实例变量
        // int b = this.y;     // 静态方法中没有this
    }
}
```

**3. 静态语句块** 

静态语句块在**类初始化**时运行一次。

```java
public class A {
    // 静态初始化语句块
    static {
        System.out.println("123");
    }

    public static void main(String[] args) {
        A a1 = new A();     // 不含static的初始化块在构造方法调用之前执行 
        A a2 = new A();     // 但是static的初始化代码块只在类加载的时候执行一次 因此只print一次123
    }
}
```

```html
123
```

**4. 静态内部类** 

非静态内部类依赖于外部类的实例，而静态内部类不需要。

```java
public class OuterClass {

    class InnerClass {
    }

    static class StaticInnerClass {
    }

    public static void main(String[] args) {
        // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context
        OuterClass outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass();
    }
}
```

静态内部类**不能访问外部类的非静态的变量和方法**。

**5. 静态导包** 

在使用静态变量和方法时不用再指明 ClassName，从而简化代码,无需类名即可使用静态变量与方法，但可读性大大降低。

```java
import static com.xxx.ClassName.*;
```

**6. 初始化顺序** 

静态变量和静态语句块**优先**于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

```java
public static String staticField = "静态变量";
```

```java
static {
    System.out.println("静态语句块");
}
```

```java
public String field = "实例变量";
```

```java
{
    System.out.println("普通语句块");
}
```

最后才是构造函数的初始化。

```java
public InitialOrderTest() {
    System.out.println("构造函数");
}
```

存在继承的情况下，**初始化顺序**为（常考）：静态优先、父类优先、初始化块优先于构造方法

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造方法）
- 子类（实例变量、普通语句块）
- 子类（构造方法）

**7. 静态域** 

- 静态域属于类，一个类仅有==一份==。而每个对象对所有的实例域都有自己的一份拷贝。

```java
public static final double PI = 3.14159 // 静态常量
System.out      // 一个常用的静态常量
```

**8. 静态方法** 

- 静态方法属于类而**不能操作对象**。
- 建议使用类名调用静态方法。
- 使用静态方法的两种场景:
    1.一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。2.一个方法只需要访问类的静态域。
- 静态工厂方法通常是由静态方法实现。应用场景：无法命名构造器；当使用构造器时，无法改变所构造的对象类型。
- main方法是静态的，因此只能调用静态方法。实例方法需要构建对象来调用。一个类的main方法可以用来做**单元测试**。



#### super

- 访问父类的**构造函数**：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。
- 子类构造器必须在**第一句**使用 super(params) 调用父类的构造方法，没写则调用父类的默认构造方法。如果父类有自定义的构造方法而没有默认构造方法，则子类构造方法必须使用 super 调用。否则报错。
- 访问父类的成员：如果子类**重写**了父类的某个方法，可以通过使用 super 关键字来引用父类的**方法**实现。

```java
public class SuperExample {
    protected int x;
    protected int y;

    public SuperExample(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void func() {
        System.out.println("SuperExample.func()");
    }
}
```

```java
public class SuperExtendExample extends SuperExample {
    private int z;  // 添加新的属性
    
    public SuperExtendExample(int x, int y, int z) {
        // 使用父类构造方法 必须在第一句
        super(x, y);    
        this.z = z;
    }

    // 覆写父类的func()方法
    @Override
    public void func() {
        super.func();   // 调用父类的func()方法
        System.out.println("SuperExtendExample.func()");
    }
}
```

```java
SuperExample e = new SuperExtendExample(1, 2, 3);
e.func();
// 输出
// SuperExample.func()
// SuperExtendExample.func()
```

**super 与 this 比较**

this 引用一个对象是实实在在存在的，可以作为函数参数，可以作为返回值，但 super 只是一个关键字，不能作为参数与返回值，它只是告诉编译器访问父类的相关变量与方法。





