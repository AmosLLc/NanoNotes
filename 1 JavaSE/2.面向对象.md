[TOC]



## 一、类的基础

#### 概述

- 引用超类的方法使用super.method();
- 在运行时能够自动地选择调用那个方法的现象称为**动态绑定**。
- 虚拟机会给每个类创建一个**方法表**，列出所有方法的签名和实际调用的方法，减少搜索开销。





#### 对象构造

##### 1.重载

- 相同名字不同参数的方法。
- 方法名 + 参数类型 = **方法签名**。 **返回类型不是**方法签名的一部分。

##### 2.构造器

- 没有构造器时系统提供无参构造器。所有实例设置为默认值。如果类写了构造方法，无参构造方法就没有了除非自己再定义。
- 如果构造的**第一句**为 this(...)，则此构造器会调用**本类**中其他构造器。
- 子类构造器第一句为 super(...) , 会调用父类的构造器，不写 super 会调用父类**默认构造器**。不写super且父类没有默认构造器就会出错。
- 私有构造方法的应用场景：① 不能创建类的实例，类只能被静态访问；②能创建类的实例，但是只能静态方法创建，如单例模式； ③ 用来被其他多个构造方法调用。

##### 3.初始化块

- 普通初始化块会在 ==构造方法调用之前== 执行，构造对象时就会执行。**每次**新建对象在构造方法之前调用。
- ==静态初始化块会在类第一次加载==的时候调用，可对类中的**静态域**进行初始化。且只执行一次。

```java
public class Student{
    
    private static int nextId;
    private int id;
    private String name;
    private int age;
    
    // 普通初始化块 在构造方法之前执行
    {
        id = nextId;
        nextId++;
    }
    
    // 静态初始化块 在第一次类加载的时候执行
    static
    {
        Random generator = new Random();
        nextId = generator.nextInt(100);
    }
}
```

------

#### 包

- 从编译器角度看，嵌套的包之间没有任何关系。如 java.util与java.util.jar 之间没有任何关系。
- 如果有两个相同名称的方法，可以通过**全限定名**使用。类文件中的字节码都是使用**完整的包名**来引用其他类。
- 可静态导入静态方法与静态域。

```java
import static com.cz.test.change;   // 静态导入Test类中的change静态方法

change(harry);      // 使用change静态方法时不再需要类名的前缀
```

- 包名放在源文件开头，没有包名就属于默认包中。

---

#### 类设计技巧

- 一定要保证数据**私有**。不要破坏封装，使用private。
- 一定要对数据进行**初始化**，可以提供默认值，也可以在构造方法中设置默认值。
- 不是所有的域都需要独立的域访问器和域更改器。
- 将职责过多的类分解。
- 类名与方法名能体现作用。
- 优先使用不可变的类。





## 二、类的继承

#### 继承概述

- new 的过程中，父类的构造方法先于子类执行。



#### 多态、静态绑定、动态绑定

- 一个**对象变量**能够指示**多种实际类型**的现象称为多态(比如父类变量能够引用自身类的变量和其子类的变量)。比如一个Employee对象变量能够引用一个Employee类的变量，也可以引用一个Employee类子类的变量。子类赋给父类变量，范围缩小，是容忍的。
- 对于 private、static 和 final 方法或者构造器，编译器可以准确知道要调用哪个方法，将这种调用方式成为**静态绑定**。

```java
UnderGraduateSutdent extends Students{...}

UnderGraduateSutdent ug = new UnderGraduateSutdent();
Student s = ug;		// s声明为 Student类型，也即其静态类型，此处其动态类型为UnderGraduateSutdent
s.display();
```

UnderGraduateSutdent 继承于父类 Student 类。

变量的**静态类型**是出现在**声明**中的类型。变量 s 的静态类型是 Student。 静态类型是在**编译**时确定的。

**动态类型**是指运行时某一时刻变量**指向对象**的类型。动态类型随着运行进程改变。s = ug 是的变量 s 的为 UnderGraduateSutdent 。

Java使用==动态类型==而不是使用它的名字来**确定调用哪个方法**。变量决定使用哪个方法名，而对象决定使用方法的哪个定义。

**动态绑定**实现的机制就是根据对象的**实际类型**查找要执行的方法，子类型中找不到的时候再查找父类。





------

#### 强制类型转换

- 子类引用赋给父类变量，编译器允许。父类引用赋给子类变量，需要强制转换。如：

```java
Child extends Father extends GrandFather{
    Father father = new Child();	// 向上转型 ojbk
    Child child = (Child)father;	// 强制转换
}
```

- 只有在**继承层次内**的才能进行强制转换。
- 在将超类转换为子类之前，应该使用 **instanceof** 进行检查
- 尽量少用类型强制转换。转换失败会抛出异常。

```java
// 标准步骤：先进行instanceof检查再强制转换！
if(staff[0] instanceof Manager){
    boss = (Manager)staff[0];
}
```

一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的**动态类型**（即引用的对象类型）是不是这个子类或者这个子类的子类。如：

```java
GrandFather grandFather = new Child();	// grandFather动态类型为Child
Father father;
Child child = new Child();   // child静态类型与动态类型均为Child
father = (Father)grandFather;	// 强制类型转换
```

因为此时 grandFather 的动态类型为child，所以能成功。

------

#### 访问控制

- 谨慎使用 protected 属性。
- 以下为访问控制符及其可见性。

|  修饰符   | 类内部 | 同一个包中 | 子类 | 其他类 |
| :-------: | :----: | :--------: | :--: | :----: |
|  private  |   √    |            |      |        |
|   默认    |   √    |     √      |      |        |
| protected |   √    |     √      |  √   |        |
|  public   |   √    |     √      |  √   |   √    |

可以对类或类中的成员（字段以及方法）加上访问修饰符。

- 类可见表示其它类可以用这个类创建实例对象。
- 成员可见表示其它类可以用这个类的实例对象访问到该成员；

protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。

设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或**封装**。因此访问权限应当尽可能地使每个类或者成员不被外界访问。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别**不允许低于父类的访问级别**。这是为了确保可以使用父类实例的地方都可以使用**子类实例**，也就是确保满足里氏替换原则。

==字段决不能是公有的==，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

```java
public class AccessExample {
    public String id;
}
```

可以使用公有的 getter 和 setter  方法来替换公有字段，这样的话就可以控制对字段的修改行为。

```java
public class AccessExample {
    // 字段为private
    private int id;
    
    // getter setter为public
    public String getId() {
        return id + "";
    }

    public void setId(String id) {
        this.id = Integer.valueOf(id);
    }
}
```

但是也有例外，如果是**包级私有的类或者私有的嵌套类**，那么直接暴露成员不会有特别大的影响。

```java
public class AccessWithInnerClassExample {
    
    // 内部类就还好
    private class InnerClass {
        int x;
    }

    private InnerClass innerClass;

    public AccessWithInnerClassExample() {
        innerClass = new InnerClass();
    }

    public int getValue() {
        return innerClass.x;  // 直接访问 不用Getter Setter
    }
}
```

----

#### 重写与重载

**1. 重写（Override）** 

存在于**继承体系**中，指子类实现了一个与父类在**方法签名上完全相同**的一个方法。

为了满足里式替换原则，重写有以下三个限制：

- 子类方法的**访问权限**必须大于等于父类方法；
- 子类方法的**返回类型**必须是父类方法返回类型或为其**子类型**。
- 子类方法抛出的**异常类型**必须是父类抛出异常类型或为其**子类型**。

使用 **@Override 注解**，可以让编译器帮忙检查是否满足上面的三个限制条件。

下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：

- 子类方法访问权限为 public，大于父类的 protected。
- 子类的==返回类型==为 ArrayList<Integer>，是父类返回类型 List<Integer> 的==子类==。
- 子类抛出的==异常类型==为 Exception，是父类抛出异常 Throwable 的==子类==。
- 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。

```java
// 父类
class SuperClass {
    protected List<Integer> func() throws Throwable {
        return new ArrayList<>();
    }
}
// 子类
class SubClass extends SuperClass {
    @Override
    public ArrayList<Integer> func() throws Exception {
        return new ArrayList<>();
    }
}
```

在调用一个方法时，先从**本类**中查找看是否有对应的方法，如果没有查找到再到**父类**中查看，看是否有继承来的方法。否则就要对**参数进行转型**，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

- this.func(this)
- super.func(this)
- this.func(super)
- super.func(super)

```java
/*
 * D extends C extends B extneds A
 */
class A {
    public void show(A obj) {
        System.out.println("A.show(A)");
    }

    public void show(C obj) {
        System.out.println("A.show(C)");
    }
}

class B extends A {
    @Override
    public void show(A obj) {
        System.out.println("B.show(A)");
    }
}

class C extends B {
}

class D extends C {
}
```

```java
public static void main(String[] args) {

    A a = new A();
    B b = new B();
    C c = new C();
    D d = new D();

    // 在 A 中存在 show(A obj)，直接调用
    a.show(a); // A.show(A)
    // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
    a.show(b); // A.show(A)
    // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
    b.show(c); // A.show(C)
    // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
    b.show(d); // A.show(C)

    // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样
    A ba = new B();
    ba.show(c); // A.show(C)
    ba.show(d); // A.show(C)
}
```

**2. 重载（Overload）** 

存在于**同一个类**中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同，签名不同。

应该注意的是，返回值不同而其它都相同**不算**是重载。

---

#### 继承的设计技巧

- 将公共操作和域放在超类
- 不要使用protected的域
- 使用继承实现 is-a 关系
- 除非所有继承的方法都有意义，否则不要使用继承
- 在覆盖方法时，不要改变预期的行为
- 使用多态，而非类型信息
- 不要过多的使用反射



## 三、类的扩展

### 接口

#### 接口基础

- 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。Java8 接口中可以有静态方法和默认方法。Java9 甚至可以定义 private 的方法。

- 从 Java 8 开始，接口也可以拥有**==默认==的方法实现**，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。Spring 中很多默认实现方法。必须用**default 修饰符标记**该方法。引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加新的功能。

- 接口的成员（字段 + 方法）**默认都是 public** 的，并且不允许定义为 private 或者 protected。

- 接口不能定义实例变量。但接口中可以定义常量字段，这些域自动设置为**public static final**，实现接口的类继承这些常量，但是不推荐。

```java
// 定义接口
public interface InterfaceExample {
    
    void func1();   // 抽象方法
    
    // 默认实现的方法
    default void func2(){
        System.out.println("func2");
    }

    int x = 123;            // 默认为 public static final
    // int y;               // 必须初始化
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
```

```java
public class InterfaceImplementExample implements InterfaceExample {
    // 实现接口中的非默认方法 默认方法可以不实现
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

- 接口不是类，而是对类的一组需求描述。所以不能用new运算符实例化一个接口。但可以使用接口==引用实现了接口的类对象==。

```java
// InterfaceExample ie1 = new InterfaceExample(); 	// 'InterfaceExample' 接口是抽象的不能实例化
InterfaceExample ie2 = new InterfaceImplementExample();	// 通常使用接口引用实现了接口的对象
ie2.func1();
System.out.println(InterfaceExample.x);
```

- 使用**instanceof**检查一个对象是否实现了某接口。

```java
if(anObject instanceof Comparable){...}
```

- Java SE8之后允许在接口中定义**静态方法**。之前不允许。

------

#### 接口方法与类方法冲突

主要是接口与接口之间 (需要覆盖方法来解决二义性)，接口与超类之间的方法冲突(==超类优先==)。

```java
// 一个含有方法getName的接口
interface Named {
    String getName(){
        return getClass.getName();
    }
}

// 另一个含有getName方法的接口
class Person {
    public String getName(){
        return this.name;
    }
}

// 冲突1：实现了含有相同方法的两个接口
public class Student extends Person implements Named{
    public String getName(return Person.super.getName());   // 必须选择一个来解决此二义性问题
}

// 另一个类也有同样的getName方法
class Animal {
    private String name;
    public String getName(){
        return this.name;
    }
}

// 冲突2：继承的类和实现的接口都有相同的方法
class Student extends Animal implements Named{
    // 此时只会考虑超类的方法，接口的方法会被忽略，这就是“类优先”的原则
}
```





### 抽象类

#### 概述

- 含一个或多个抽象方法(abstract)的就是抽象类。但抽象类可以包含具体数据与方法。
- 即使类不含抽象方法，也可以定义为抽象类。
- ==抽象类不能实例化==。不能创建抽象类的对象。但是可以创建抽象类变量来引用其非抽象子类的对象。也可以继承抽象类来实例化其子类。

```java
public abstract class Person{}          // 抽象类
public class Student extends Person{}   // 抽象类子类
new Person()                // 不合法
Person p = new Student();   // 合法 抽象类引用子类对象
```

```java
public abstract class AbstractClassExample {
    protected int x;
    private int y;
    public abstract void func1();   // 含有抽象方法就是抽象类

    public void func2() {
        System.out.println("func2");
    }
}
```

```java
public class AbstractExtendClassExample extends AbstractClassExample {
    // 需要实现抽象方法
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

```java
// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' 是抽象类不能被实例化
AbstractClassExample ac2 = new AbstractExtendClassExample();	// 抽象类的子类可以实例化
ac2.func1();
```



#### 接口与抽象类比较

- 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 **LIKE-A** 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

##### 使用选择

使用接口：

- 需要让**不相关的类**都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
- 需要使用**多重继承**。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，==接口优先于抽象类==。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。



### 内部类

#### 1. 概述

- 内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。
- 内部类与外部类具有引用关系。**隐式引用**是**编译器**自己加的。
- 只有内部类可以是**私有**类。内部类**不能有static**方法。内部类中声明的所有静态域都必须是 final。
- 内部类是一种**编译器**现象，与虚拟机无关。**编译器**将会把内部类翻译成用 **$** (美元符号）分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知。每个内部类都会被编译为一个独立的类。
- 如果内部类访问了私有数据域， 就有可能通过附加在外围类所在包中的其他类访问它们。这就存在一定的**安全问题**。但需要将攻击代码与被攻击类放在同一个包中。
- 内部类可以为 private 的。



#### 2. 匿名内部类

匿名内部类的实例。

```java
// 将一个匿名内部类定义在方法中
public void start(int interval, boolean beep){
    // 创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内
    ActionListener listener = new ActionListener(){
        @Override
        public void actionPerformed(ActionEvent event){
            System.out.println("At the tone, the time is " + new Date());
        }
    };
    Timer t = new Timer(interval, listener);
    t.start();
}
```

- 多用于实现回调接口。

- 如果**构造参数的闭小括号后面跟一个开大括号**， 正在定义的就是匿名内部类。

```java
Person count = new Person("Dracula") {...}
// an object of an inner class extending Person
```

- 习惯的做法是用匿名内部类实现事件监听器和其他回调。 如今最好还是使用 **lambda** 表达式。
- 高级技巧：使用匿名类实现==双括号初始化==。

```java
// 此处两个{}。第一个{}表明是一个匿名内部类。第二个{}表明为类里面的初始化代码块，会在构造对象时调用。
invite(new ArrayList<String>(){{ add("Harry"); add("Tony"); }});
```

- 调用 getClass方法时调用的是this.getClass(), 而**静态方法**没有 this。所以应该使用以下表达式：

```java
new Object()){}.getClass().getEnclosingClass()      // 获取静态方法的Class
```

在这里，newObject(){} 会建立Object的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。



#### 3. 静态内部类

- 即含有static修饰的内部类。只有**内部类**可以声明为 **static**。
- 静态内部类可以有静态域和方法。
- 非静态内部类依赖于外部类的实例，而静态内部类不需要。
- 静态内部类不能访问外部类的**非**静态的变量和方法。

**外部类如何调用静态内部类中的属性和方法**

- 外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法

- 外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法

**静态内部类如何调用外部类的属性和方法**

静态内部类如果要访问外部的静态成员变量或者成员方法，静态只能访问静态的。

- 静态内部类可以直接调用外部类的静态属性和方法
- 静态内部类可以通过创建外部类**实例**的方法调用外部类的**非静态**属性和方法

**如何创建静态内部类实例**

创建静态内部类的时候是不需要将静态内部类的实例对象绑定到外部类的实例对象上，静态内部类属于**外部类**，而**不是**属于外部类的**对象**。

- 在非外部类中

```
外部类名.内部类名 name = new 外部类名.内部类名();
```

- 在外部类中

```
内部类名 name = new 内部类名();
```

```java
public class Outer {
    // 定义一个实例变量和一个静态变量
    private int a;
    private static int b;

    // 定义一个静态方法和一个非静态方法
    public static void say() {
    }

    public void test() {
        // 在外部类中调用内部类的属性和方法
        // 可以通过静态内部类的全类名来调用静态内部类的静态属性（外部类名.静态内部类名.属性）
        Outer.Inner.c = 1; 
        // 可以通过静态内部类的全类名来调用静态内部类的静态方法（外部类名.静态内部类名.方法）
        Outer.Inner.go(); 
        // Outer.Inner.walk(); // 不能通过类静态内部类的全类名来调用内部类的非静态属性和方法
        Inner inner = new Inner(); //可以通过创建内部类实例来调用静态内部类的非静态属性和方法
        inner.d = 1;
        inner.walk(); 
    }

    // 静态内部类
    public static class Inner {
        // 在静态内部类中定义一个静态变量和一个实例变量
        static int c;
        int d;
        // 可以定义一个匿名代码块和一个静态代码块
        {
        }
        static {
        }

        // 定义一个静态方法和一个普通方法
        public static void go() {
        }

        public void walk() {
            // 在静态内部类中调用外部类的属性和方法
            int f = b; // 可以直接调用外部类的静态属性
            say();     // 可以直接调用外部类的静态方法
            // int e = a; 直接调用外部类的非静态属性出错编译出错
            // test(); 直接调用外部类的非静态方法时编译出错
            Outer outer = new Outer();
            int e = outer.a; // 可以通过创建外部类实例来调用外部类的非静态属性
            outer.test();    // 可以通过创建外部类实例来调用外部类的非静态方法
        }
    }
}
```



#### 4. 局部内部类

- 定义的位置：在一个类的成员方法中。或者说，定义在一个成员方法的中的类就是局部内部类。
- 局部内部类**不能用 public 或 private 修饰符**进行声明。不能用访问修饰符。
- 局部内部类还有一个优点。它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过那些局部变量必须事实上为 final。如果需要变值的话一个替代方案可以是使用长度为1的数组。数组引用为final但是其值可以变化。即局部内部类只能访问**方法**中声明的 **final 类型**的变量。
- 编译后会生成两个.class文件，一个是Outer.class ，另一个是Outer$LocalInner.class。
- 在外部类中不能创建内部类的实例；
- 可知局部内部类可随意访问外部类的成员变量和方法，即使是私有的。
- 内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法。





### 枚举

#### 概述

- 比较两个枚举类型值时，不需要调用equals方法，直接用 == 即可。
- switch case表达式中直接写入枚举值，不需加入枚举类作为限定。
- 枚举类并且不能跟 final，abstract 同时使用，因为它默认是 final 类型了。
- **enum类中的每个enum元素都是其类的static final实例。**

```java
// 定义一个枚举类
public enum Size{
    SMALL, MEDIUM, LARGE
};
Size s = Enum.valueOf(Size.class, "SMALL"); // s = Size.SMALL;
String a = Size.SMALL.toString();           // a = "SMALL";
int b = Size.LARGE.ordinal();               // b = 2;
```

#### 语法

 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum<E extends Enum\<E>>，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。

```java
public enum EnumTest {
	MON, TUE, WED, THU, FRI, SAT, SUN;
}
```

这段代码实际上调用了7次 Enum(String name, int ordinal)：

```java
new Enum<EnumTest>("MON",0);
new Enum<EnumTest>("TUE",1);
new Enum<EnumTest>("WED",2);
... ...
```

#### 枚举类常用方法

|           返回类型           |                    方法名称                     |                           方法说明                           |
| :--------------------------: | :---------------------------------------------: | :----------------------------------------------------------: |
|             int              |                 compareTo(E o)                  |                  比较此枚举与指定对象的顺序                  |
|           boolean            |              equals(Object other)               |           当指定对象等于此枚举常量时，返回 true。            |
|           Class<?            |               getDeclaringClass()               |        返回与此枚举常量的枚举类型相对应的 Class 对象         |
|           `String`           |                     name()                      |       返回此枚举常量的名称，在其枚举声明中对其进行声明       |
|             int              |                    ordinal()                    | 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为 0） |
|            String            |                   toString()                    |              返回枚举常量的名称，它包含在声明中              |
| static<T extends Enum\<T>> T | static valueOf(Class\<T> enumType, String name) |            返回带指定名称的指定枚举类型的枚举常量            |

#### 枚举模板

```java
/**
 * 转码状态
 *
 * @author jiashubing
 * @since 2019/1/18
 */
public enum TranscodeStatusEnum {

    FAIL("转码失败", (short) -1), 
    WAIT("排队等待", (short) 0), 
    COMMIT("提交作业", (short) 1), 
    SUCCESS("完成转码", (short) 2);

    private String name;
    private short index;

    // 构造方法
    TranscodeStatusEnum(String name, short index) {
        this.name = name;
        this.index = index;
    }

    // 覆盖方法
    @Override
    public String toString() {
        return this.index + "_" + this.name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public short getIndex() {
        return index;
    }

    public void setIndex(short index) {
        this.index = index;
    }
}
```







## 四、异常

#### 概述

Throwable 可以用来表示任何可以作为异常抛出的**类**，分为两种： **Error**  和 **Exception**。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：

- **受查异常** ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
- **非受查异常** ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。派生于**Error**类和**RuntimeException类**的异常。

常见的 runtimeException

```java
NullPointerException  // 空指针引用异常
ClassCastException    //类型强制转换异常。
IllegalArgumentException // 传递非法参数异常。
ArithmeticException   // 算术运算异常
ArrayStoreException   // 向数组中存放与声明类型不兼容对象异常
IndexOutOfBoundsException //  下标越界异常
NegativeArraySizeException // 创建一个大小为负数的数组错误异常
NumberFormatException // 数字格式异常
SecurityException     // 安全异常
UnsupportedOperationException // 不支持的操作异常
```



#### 异常体系

- 异常对象都是派生于 Throwable 类的一个实例。异常体系如下如所示。

![1563604669873](assets/1563604669873.png)

------

#### 自定义异常类

继承 Exception 类即可。

```java
class FileFormatException extends IOException{
    public FileFormatException() {
    	this("The file format is not good.");
    }
    public FileFormatException(String gripe){
        super(gripe);
    }
}
```

---

#### Throwable类API

```java
Throwable(); 	// 构造一个新的 Throwabie 对象， 这个对象没有详细的描述信息
Throwable(String message); // 构造一个新的throwable对象， 这个对象带有特定的详细描述信息。习惯上所有派
生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器
String getMessage(); // 获得Throwable 对象的详细描述信息
```

---

#### 受查异常声明与抛出

使用 ==throws== 关键词声明异常。

```java
class MyAnimation{
    // 可以同时声明多个可能抛出的异常
    public Image loadlmage(String s) throws FileNotFoundException, EOFException{
        ...
    }
}
```

使用 ==throw== 关键词抛出异常。

```java
EOFException e = new EOFException();    // 构造异常对象
throw e;    // 抛出异常对象
throw new EOFException("File is not found");    // 抛出异常对象且带异常有信息
```

**再次抛出异常与异常链**

有一好的处理方法，将原始异常设置为新异常的“**原因**”：

```java
try{
    // access the database
} catch (SQLException e) {
    // 构造新的异常对象
    Throwable se = new ServletException ("database error"); 
    se.initCause(e);    // 把原来的原因e传入新对象中
    throw se;   // 抛出新对象
}
```

当捕获到异常时， 就可以使用下面这条语句重新得到原始异常：

```java
Throwable e = se.getCause();
```

**强烈建议**使用这种包装技术。

------

#### try-catch-finally

- finally多用于**回收资源**。
- 不管是否有异常被捕获， finally 子句中的代码都被执行。
- try 语句可以只有 finally 子句，而没有 catch 子句。
- finally语句中可能也会产生异常！如资源关闭close()方法的异常。此时原始的异常将会丢失，转而抛出 close 方法的异常。

##### 带return的finally语句

当 finally 子句包含 return 语句时，将会出现一种意想不到的结果，假设利用 return语句从 try语句块中退出。在方法返回前，finally 子句的内容将被执行。如果 finally 子句中也有一个 return 语句，这个返回值将会**覆盖**原始的返回值。

```java
public static int f(int n){
    try{
        int r = n * n;
        return r;
    }
    finally{
        if (n = 2) {
            return 0;
        }
    }
}
```

如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语句.然而在方法真正返回前，还要执行 finally 子句。finally 子句将使得方法返回 0, 这个返回值覆盖了原始的返回值 4。

- 不要在finally语句中使用return，这不是finally语句的用处。

##### 带资源的try语句

- 如果需要关闭资源，最好使用带资源的try语句。
    假设资源属于一个实现了 **AutoCloseable** 接口的类， Java SE7为这种代码模式提供了一
    个很有用的快捷方式。AutoCloseable 接口有一个方法：

> void **close()** throws Exception

带资源的 try 语句（try-with-resources) 的最简形式为：

```java
try (Resource res = ...){
    // work with res
}
```

try块正常或者发生异常退出时，会**自动调用 res.close()**。就像使用了finally子句。

还可以指定多个资源。例如：

```java
try (Scanner in = new Scanne「(new FileInputStream('7usr/share/dict/words"),  "UTF-8");
PrintWriter out = new Pri ntWriter("out.txt")){
    while (in.hasNex())
    System.out.println(in.next().toUpperCase());
}
```

不论这个块如何退出， in 和 out 都会关闭。有的资源没有实现这个接口就**不能**使用带资源的try语句。

------

#### 覆写父类异常方法

- 如果在子类中覆盖了超类的一个方法， 子类方法中声明的受查异常不能比超类方法中声明的异常更通用 （子类方法中可以抛出更特定的异常， 或者根本不抛出任何异常）。
- 如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。超类异常范围最广泛。

```java
public class SuperClass{
    public void someMethod throws Exception1 {
        ....
    }
}

public class SubClass extends SuperClass {
    @Override
    public void someMethod throws Exception1, Exception2{	// Error 子类方法比父类异常范围更大
        ....
    }
}

public class SubClass extends SuperClass {
    @Override
    public void someMethod throws Exception3{	// OK if Exception3 exntends Exception1
        ....
    }
}
```

覆写的方法不能拓展父类异常的范围。

------

#### 使用异常技巧

- 多使用代码检查机制。捕获异常的开销非常大。
- 不要过分细化异常。
- 利用异常层次结构，不要只抛出RuntimeException异常。应该寻找更加适当的子类或创建自己的异常类。不要只捕获 Thowable 异常， 否则，会使程序代码更难读、更难维护。将一种异常转换成另一种更加适合的异常时不要犹豫。
- 不要压制异常。
- 在检测错误时，“ 苛刻 ” 要比放任更好。
- 不要羞于传递异常。
- 早抛出，晚捕获。
- 多个catch块的次序应该是具体异常放在其祖先类的前面，否则后面的catch语句可能进入不了。



- [Java 入门之异常处理](https://www.tianmaying.com/tutorial/Java-Exception)
- [Java 异常的面试问题及答案 -Part 1](http://www.importnew.com/7383.html)





## 五、常用类

### 1.包装类

#### 自动装箱/拆箱

- 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用**自动装箱与拆箱**完成。
- 对象包器类为 **==final==不可变**，一旦构造就不能改变其包含的值。其内部基本数值类型是私有的，且声明为 final。
- 自动装箱过程是**编译器**自动在代码中插入一条对象装箱代码。拆箱也是如此。
- 每种包装类都有一个静态方法 valueOf(), 接收基本类型，返回引用类型，也有一个实例方法 xxxValue()，返回对应的基本类型。
- 6种数值型的包装类有一个共同的父类 Number 类。

```java
/**
* byte 			Byte
* short			Short
* int			Integer
* long			Long
* float			Float
* double		Double
* char			Character
* boolean		Boolean
*/
// <>中不能写基本类型，需要写其对应的包装器类
ArrayList<Integer> list = new ArrayList<>();    
list.add(3);    
list.add(Integer.valueOf(3));   // 与上句等价，自动装箱
int n = list.get(i);    
int n = list.get(i).intValue(); // 与上句等价，自动拆箱
```

#### Integer类API

```java
int intValue();     // 以int形式返回Integer对象的值
static String toString(int i);
static String toString(int i, int radix);   // 以一个新String对象的形式返回给定数值i的radix进制参数表示。默认10进制。
static int parseInt(String s);
static int parseInt(String s, int radix);   // 解析字符串参数对应的整数，第二个参数为进制
```

#### 缓存池

new Integer(123) 与 Integer.valueOf(123) 的区别在于：

- new Integer(123) 每次都会**==新建==一个对象**；
- Integer.valueOf(123) 会使用**缓存池中的对象**，多次调用会取得**同一个对象**的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```

**valueOf() 方法**的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。Integer 是不可变的，所以缓存的对象可以安全的被共享。是一种享元模式的思想。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在 Java 8 中，Integer 缓存池的大小==默认为 -128\~127==。

```java
static final int low = -128;    // 默认最小值
static final int high = 127;    // 默认最大值
static final Integer cache[];

static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

编译器会在**自动装箱**过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用**相同的对象**。下面 m, n 引用的是缓存中的相同的对象，因此可以直接用 == 比较。但是在 -128~127 区间外的不在缓存区内，不能直接用 == 判断比较，得用equals()方法。

```java
Integer m = 123;  // 在缓存池中
Integer n = 123;
// true 
System.out.println(m == n); 
```

其他基本类型对应的缓冲池范围如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。但是==只有Integer类可以修改默认的缓存范围==。在VM options加入参数：==-XX:AutoBoxChacheMax=7777==.就可以将最大缓存值设置为7777.在此范围内的都可以用 == 进行是否相等判断。

---

#### Integer 与二进制算法

Integer 类有一些二进制操作，包括位翻转与循环移位等。

**位翻转**

Integer 的静态方法，可以进行位翻转。

```java
public static int reverse(int i);
public static int reverseBytes(int i);
```

位翻转就是将 int 当做二进制，左边的位与右边的位进行互换，reverse 是按照位进行互换，reverseBytes 是按 byte 进行互换。高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着4 位一组交换、然后 8 位一组、16位一组交换之后就完成了。









### 2. String类

#### 概述

- String类对象为==不可变==字符串。优点：编译器可以让字符串**共享**。(可以想象各种字符串存放在公共的**存储池**中，字符串变量指向存储池中的位置)。
- 使用 equals() 方法来检验两个字符串是否**相等**。比较的是内容。一定不要用 “==” 比较字符串，此比较的是对象，完全可能有两个字符串对象的内容一样但是地址不同。
- 虚拟机中实际上只有**字符串常量**是共享的(final修饰)，而 + 或 substring 等操作产生的结果通常并不是共享的。
- "" 是空串，也是一个对象，有自己的长度(0)和内容(空)。
- String 被声明为==final==，因此它不可被继承。

#### 源码分析

在 Java 8 中，String 内部使用 char 数组存储数据。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];     // 声明为final不可变
}
```

在 Java 9 之后，String 类的实现改用 ==byte 数组==存储字符串，同时使用 `coder` 来标识使用了哪种编码。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** 用数组存储实际的数据 */
    private final byte[] value;     

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

value 数组被声明为 final，这意味着 value 数组初始化之后就**不能再引用其它数组**。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。

String 类提供了很多看似修改的方法，实际上都是通过创建新的String 对象来实现的。



#### 不可变的好处

**1. 可以缓存 hash 值** 

因为 String 的 hash 值经常被使用，例如 String 用做 **HashMap 的 key**。不可变的特性可以使得 hash 值也不可变，因此只需要进行**一次**计算。

**2. String Pool 的需要** 

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。一个存放String的池。

**3. 安全性** 

String 经常作为参数，String不可变性可以保证**参数不可变**。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

**4. 线程安全** 

String 不可变性天生具备==线程安全==，可以在多个线程中安全地使用。可共享。String类是 **immutable** 类，可以安全的在多线程中共享。



#### String, StringBuffer and StringBuilder

**1. 可变性** 

- String 不可变
- StringBuffer 和 StringBuilder 可变

**2. 线程安全** 

- String 不可变，因此是**线程安全**的
- StringBuilder 不是线程安全的
- StringBuffer 是线程安全的，内部使用 **synchronized** 进行同步



#### String Pool

字符串常量池（String Pool）保存着所有**字符串字面量**（literal strings），这些字面量在**编译时期**就确定。不仅如此，还可以使用 **String 的 intern()** 方法在运行过程中**将字符串添加到 String Pool** 中。

![1567063473576](assets/1567063473576.png)

当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的**引用**；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是**同一个**字符串。

```java
String s1 = new String("aaa");		   
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();                // 检查String Pool中没有"aaa"则添加进去
String s4 = s1.intern();                // 检查String Pool已经有了"aaa"则直接获取出来
System.out.println(s3 == s4);           // true 因为指向的是同一对象
```

如果是采用 "bbb" 这种**字面量**的形式创建字符串，会**自动地将字符串放入 String Pool 中**。

```java
String s5 = "bbb";
String s6 = "bbb";
System.out.println(s5 == s6);  // true
```

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到==堆==中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。



#### new String("abc")

使用这种方式一共会创建**两个字符串对象**（前提是 String Pool 中还没有 "abc" 字符串对象）。

- "abc" 属于字符串**字面量**，因此编译时期会在 **String Pool** 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在**堆中**创建一个字符串对象。

创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。

```java
public class NewStringTest {
    public static void main(String[] args) {
        String s = new String("abc");
    }
}
```

```java
String name1 = "TestName";
String name2 = "TestName";
System.out.println(name1 == name2);	// true name1 name2指向同一对象
```

```java
String name1 = new String("TestName");
String name2 = new String("TestName");
System.out.println(name1 == name2);	// false name1 name2指向不同对象
System.out.println(name1.equals(name2));  // true
```

使用 javap -verbose 进行反编译，得到以下内容：

```java
// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
         9: astore_1
// ...
```

在 Constant Pool 中，#19 存储这字符串**字面量** "abc"，#3 是 String Pool 的字符串**对象**，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。

以下是 String 构造函数的源码，可以看到，在将一个**字符串对象**作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会**指向同一个 value 数组**。

```java
public String(String original) {
    this.value = original.value;    // value是String类中内部存放数据的final数组
    this.hash = original.hash;
}
```



#### String类 API

- 所有已实现的接口：

```java
Serializable, CharSequence, Comparable<String>
```

- 构造方法

```java
String()  				// 初始化一个新创建的 String 对象，使其表示一个空字符序列
String(byte[] bytes) 	 // 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String
String(byte[] bytes, String charsetName) // 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String
String(char[] value) 	 // 使用字符数组(char[])创建String对分配一个新的String 
String(StringBuffer buffer) 	// 分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列
String(StringBuilder builder) 	// 分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列
```

- 字符串的长度，判断字符串是否为空字符串。

```java
 boolean isEmpty() // 当且仅当 length() 为 0 时返回 true
 int length()      // 返回此字符串的长度
```

- 判断该字符串中是否包含指定的字符串，获取字符

```java
 boolean contains(CharSequence s) 	// 当且仅当此字符串包含指定的char值序列时，返回 true
```

- 返回指定索引处的字符值：

```java
 char charAt(int index) 	// 返回指定索引处的 char 值
```

- 字符串连接：

```java
 String concat(String str)  	// 将指定字符串连接到此字符串的结尾
          
```

- 从前向后扫描，返回字符或者字符串参数在该字符串中第一次出现的索引：

```java
 int indexOf(int ch) 		// 返回指定字符在此字符串中第一次出现处的索引
 int indexOf(String str)   	// 返回指定子字符串在此字符串中第一次出现处的索引
 int indexOf(int ch, int fromIndex) 	// 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索
 int indexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
```

- 从后向前扫描，返回字符或字符串参数在该字符串中第一次出现的索引：

```java
 int lastIndexOf(int ch) 		// 返回指定字符在此字符串中最后一次出现处的索引
 int lastIndexOf(String str)  	// 返回指定子字符串在此字符串中最右边出现处的索引 
 int lastIndexOf(int ch, int fromIndex) 	// 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索
 int lastIndexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索
```

- 获取该字符串的一部分子字符串：

```java
tring substring(int beginIndex) 			// 返回一个新的字符串，它是此字符串的一个子字符串
String substring(int beginIndex, int endIndex) // 返回一个新字符串，它是此字符串的一个子字符串
// 这个方法经常与上面两个方法String.lastIndexOf()和String.indexOf()方法一起使用，使用这两个方法查找分割的位置，然后再使用String.subString()方法进行分割
```

- 获取该字符串的一部分，以字符序列返回：

```java
CharSequence subSequence(int beginIndex, int endIndex) // 返回一个新的字符序列，它是此序列的一个子序列
```

- 重写Object的方法：

```java
 boolean equals(Object anObject) // 将此字符串与指定的对象比较
 int hashCode()                  // 返回此字符串的哈希码
 String toString()               // 返回此对象本身（它已经是一个字符串！）
```

- 实现 comparable 接口的比较方法：

```java
 int compareTo(String anotherString)  // 按字典顺序比较两个字符串 
```

- 连接得到字符串

```java
static String join(CharSequence delimiter, CharSequence... elements)      // 在后面的每个字符串之间插入第一个字符串
String all = String.join("/", "a", "b", "c");  // all = "a/b/c";
```

- 不按大小写的比较方法

```java
 int compareToIgnoreCase(String str)  // 按字典顺序比较两个字符串，不考虑大小写 
 boolean equalsIgnoreCase(String anotherString) // 将此 String 与另一个 String 比较，不考虑大小写
```

- 基本类型：int, long, float, double, char, char数组，Object(对象)转换成 String 的方法:String.valueOf(xxx)

```java
static String valueOf(int i)        // 返回 int 参数的字符串表示形式
static String valueOf(long l)       // 返回 long 参数的字符串表示形式
static String valueOf(float f)      // 返回 float 参数的字符串表示形式
static String valueOf(double d)     // 返回 double 参数的字符串表示形式
static String valueOf(boolean b)    // 返回 boolean 参数的字符串表示形式
static String valueOf(char c)       // 返回 char 参数的字符串表示形式
static String valueOf(char[] data)  // 返回 char 数组参数的字符串表示形式
static String valueOf(Object obj)   // 返回 Object 参数的字符串表示形式
static String valueOf(char[] data, int offset, int count) // 返回 char 数组参数的特定子数组的字符串表示形式
```

- 把 String 字符串转换为字节数组：

```java
 byte[] getBytes() // 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中
 byte[] getBytes(Charset charset)  	// 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组	
 byte[] getBytes(String charsetName)// 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中
```

- 对 String 中所有的字符都进行大小写转换：

```java
 String toLowerCase()   	// 使用默认语言环境的规则将此 String 中的所有字符都转换为小写
 String toUpperCase()  		// 使用默认语言环境的规则将此 String 中的所有字符都转换为大写
 String toLowerCase(Locale locale)  // 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写
 String toUpperCase(Locale locale)  // 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写
```

- 判断该字出发是否匹配给定的正则表达式:

```java
 boolean matches(String regex)  // 告知此字符串是否匹配给定的正则表达式
```

- 使用正则表达式分割该字符串为字符串数组：

```java
 String[] split(String regex)   // 根据给定正则表达式的匹配拆分此字符串
 String[] split(String regex, int limit)  // 根据匹配给定的正则表达式来拆分此字符串 
 // 注意，获取的数组中不包含作为分割符的字符(或字符串)
```

- 判断字符串的前缀后缀：

```java
 boolean startsWith(String prefix)  // 测试此字符串是否以指定的前缀开始
 boolean startsWith(String prefix, int toffset) // 测试此字符串从指定索引开始的子字符串是否以指定前缀开
 boolean endsWith(String suffix)    // 测试此字符串是否以指定的后缀结束
```

- 该字符串与指定的字符序列或者 StringBuffer 比较

```java
 boolean contentEquals(CharSequence cs) // 将此字符串与指定的 CharSequence 比较
 boolean contentEquals(StringBuffer sb) // 将此字符串与指定的 StringBuffer 比较 
```

- 把字符数组转换成 String

```java
static String copyValueOf(char[] data) // 返回指定数组中表示该字符序列的 String
static String copyValueOf(char[] data, int offset, int count) // 返回指定数组中表示该字符序列的 String
```

- 把该字符串中的字符拷贝到指定的字符数组中去

```java
 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) // 将字符从此字符串复制到目标字符数组
```

- 把该字符串转换成字符数组

```java
 char[] toCharArray() // 将此字符串转换为一个新的字符数组
```

- 使用新字符替换字符串中的旧字符

```java
 String replace(char oldChar, char newChar) // 返回一个新的字符串，用newChar替换此字符串中所有的oldChar得到
 String replace(CharSequence target, CharSequence replacement) // 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串
```

- 使用新子字符串替换该字符串中匹配正则表达式的那些旧子字符串：一个全部替换，一个只替换第一个

```java
// 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串 
String replaceAll(String regex, String replacement) 
// 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串    
String replaceFirst(String regex, String replacement) 
```

- 把该字符串规范化表示，去掉该字符串的前后空白符：

```java
 String intern()    // 返回字符串对象的规范化表示形式 放到常量池
 String trim()      // 返回字符串的副本，忽略前导空白和尾部空白。中间不去
```

- Unicode代码点相关：

```java
 int codePointAt(int index) 	// 返回指定索引处的字符（Unicode 代码点）
 int codePointBefore(int index) // 返回指定索引之前的字符（Unicode 代码点）
 int codePointCount(int beginIndex, int endIndex) // 返回此String的指定文本范围中的 Unicode 代码点数
 int offsetByCodePoints(int index, int codePointOffset) // 返回此 String 中从给定的 index 处偏移 codePointOffset 个代码点的索引
```

- 格式化字符串：

```java
static String format(Locale l, String format, Object... args) // 使用指定的语言环境、格式字符串和参数返回一个格式化字符串
static String format(String format, Object... args) // 使用指定的格式字符串和参数返回一个格式化字符串
```

- 判断该字符串的子字符串是否相等：

```java
 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等
 boolean regionMatches(int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等
```



### 3. StringBuilder/StringBuffer类

#### 概述

- 字符串修改较为频繁时使用，StringBuilder 与 StringBuffer 实现几乎相同，只是StringBuilder 线程不安全（不能同步访问）， StringBuffer 线程安全。由于 StringBuilder 相较于 StringBuffer 有速度优势，**所以多数情况下建议使用 StringBuilder 类**。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。
- 修改时不产生新的未使用变量。

- 继承体系如下图所示

![1567216224810](assets/1567216224810.png)

- 基本原则：如果要操作少量的数据，用 String ；单线程操作大量数据，用 StringBuilder ；多线程操作大量数据，用 StringBuffer。



#### 源码分析







### 4. Arrays类

#### 概述

- 创建一个数字数组时，所有元素初始化为 0。boolean 数组的元素初始化为 false。对象数组的元素则初始化为 **null**，因此需要对每个对象进行对象引用才行，否则使用时会有 NPE 异常。
- 一旦创建数组就**不能改变其大小**，但可以改变元素。
- 数组拷贝：允许一个数组变量拷贝给另一个数组变量。两个变量将指向同一个数组。一个操作会**影响**另一个。
- 如果希望把一个数组的全部值拷贝到一个新数组里，可使用Arrays类的 copyOf() 方法。
- 使用 **Arrays.sort()** 方法对数值型数组排序，使用的是**快速排序**算法。

```java
int[] a = new int[3];     // 创建新的数字数组 自动初始化为0
int[] b = {1, 2, 3, 4}    // 创建并初始化数组

a.length                // 数组长度，不加方法的括号

for(int element : a){}  // 使用for each遍历可以不关注下标

int[] copyb = Arrays.copyOf(b, b.length);   // 将数组b全部重新拷贝给另一个数组两者指向不同。第二个参数为长度。

String[] args   // 命令行参数
java Test -g ruler test     // args[0] = "-g"  args[1] = "ruler"  args[2] = "test"

Arrays.sort(b);  // 对数组b进行排序，排序结果就在b里面
```



#### Arrays类的API

```java
String static toString(type[] b);   	    // 将数组中的元素拼接成一个字符串 [1, 2, 3, 4]
type static valueOf(type[] a, int length);  // 将数据按照传入的长度拷贝到一个新的数组中
type static copyOfRange(type[] a, int start, int end);  // 将源数组按照传入的开始位置和结束位置拷贝到一个新的数组中;
static void sort(type[] a);     			// 将源数组按照优化的快速排序法进行排序
static int binarySearch(type[] a, type v);   //  在整个数组中按照二分查找法查找数据，查找成功返回下标，否则返回-1
static int binarySearch(type[] a, int start, int end, type v);  // 在整个数组中按照二分查找法从传入的开始位置和结束位置查找数据，查找成功返回下标，否则返回-1
static void fill(type[] a, type v);     	// 将数组中的所有元素值都设置为v
static boolean equals(type[] a, type[] b);  // 如果两个数组的长度和每个元素值都相等，那么返回true,否则返回false

String static deepToString(type[] a);   	    // 将二维数组拼接为字符串形式
int[][] magicSquare = {{1, 2}, {3, 4}, {5, 6}}; // 定义一个二维数组
String s = Arrays.deepToString(magicSquare);    // 将二维数组转字符串
// s = "[[1, 2], [3, 4], [5, 6]]";
```



### 8. Object类

#### 概览

Object类的API

```java
public native int hashCode()
public boolean equals(Object obj)
protected native Object clone() throws CloneNotSupportedException
public String toString()
public final native Class<?> getClass()
protected void finalize() throws Throwable {}
public final native void notify()
public final native void notifyAll()
public final native void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanos) throws InterruptedException
public final void wait() throws InterruptedException
```

------

#### equals()

**1. 等价关系** 

Ⅰ 自反性

```java
x.equals(x); 	// true
```

Ⅱ 对称性

```java
x.equals(y) == y.equals(x); // true
```

Ⅲ 传递性

```java
if (x.equals(y) && y.equals(z))
    x.equals(z);  // true;
```

Ⅳ 一致性

多次调用 equals() 方法结果不变

```java
x.equals(y) == x.equals(y); // true
```

Ⅴ 与 null 的比较

对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false

```java
x.equals(null); // false;
```

**2. 等价与相等** 

- 对于基本类型，== 判断两个值是否**相等**，基本类型没有 equals() 方法。
- **对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。**

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y));  // true 等价
System.out.println(x == y);       // false 对象相等
```

**3. 实现** 

- 检查是否为同一个对象的引用，如果是直接返回 true；
- 检查是否是同一个类型，如果不是，直接返回 false；
- 将 Object 对象进行转型；
- 判断每个关键域是否相等。

```java
public class EqualExample {

    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    // 覆写equals()方法
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;

        if (x != that.x) return false;
        if (y != that.y) return false;
        return z == that.z;
    }
}
```

- Object类中的equals方法用于检测一个对象是否等于另一个对象，判断两个对象是否具有相同的引用。
- equals方法的特性：自反性、对称性、传递性、一致性。

写出**完美equals方法**的建议（源自JavaCore）：

- 显示参数命名为otherObject，之后转换为一个叫 other的变量。
- 检测this与otherObject是否引用同一对象。
- 检测otherObject是否为null。
- 比较this与otherObject是否属于同一个类。
- 将otherObject转换为相应的类类型变量。
- 现在开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。

```java
// 以下是Employee类的equals方法
public boolean equals(Object otherObject){
    if(this == otherObject) return true;    // 检测this与otherObject是否引用同一对
    if(otherObject == null) return false;   // 检测otherObject是否为null
    // 比较this与otherObject是否属于同一个类
    if(getClass() != otherObject.geClass()) return false;
    Employee other = (Employee) otherObject;    // 将otherObject转换为相应的类类型变量
    // 现在开始对所有需要比较的域进行比较。使用 == 比较基本类型域，使用equals比较对象域。
    return Object.equals(name, other.name) && salary == other.salary && Objects.equals(hireDay, other.hireDay);
}
```

------

#### hashCode()

hashCode() 返回**散列值**，而 equals() 是用来判断两个对象是否等价。**等价的两个对象散列值一定相同**，但是散列值相同的两个对象不一定等价。散列值是由对象导出的一个**整形值**。

每个对象都有一个**默认的散列码**，其值为对象的**存储地址**。如果对象不重写该方法，Object类的hashCode方法就返回对象的存储地址。

在覆写 equals() 方法时应当总是覆写 hashCode() 方法，保证等价的两个对象散列值也相等，一般两个需要**同时**覆写。

下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是**不同**的，最终导致集合添加了两个等价的对象。

```java
EqualExample e1 = new EqualExample(1, 1, 1);	// 因为上述的只是覆写了equals()
EqualExample e2 = new EqualExample(1, 1, 1);    // 没有覆写 hashCode()
System.out.println(e1.equals(e2));   		   // true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
```

理想的散列函数应当具有**均匀性**，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。**R 一般取 31**，因为它是一个**奇素数**，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。

一个数与 31 相乘可以转换成移位和减法：`31*x == (x<<5)-x`，编译器会自动进行这个优化。

```java
// 覆写 hashCode() 方法
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
```

- 如果重新定义类中的 equals 方法，就必须**重新**定义 hashCode 方法。因为两种定义必须一致：如果 x.equals(y) 返回true，那么 x.hashCode() 就必须与 y.hashCode() 具有相同的值。Hashtable实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 hashCode 方法和 equals 方法。因为哈希表通过hashCode检索对象。

```java
// 一个简单的覆写hashCode方法
@Override
public int hashCode() {
	return Objects.hash(firstName, lastName);   // 传入多个对象到hash()返回hashCode
}
```

------

#### toString()

该方法默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为**hashCode散列码**的无符号十六进制表示，@前面为类名。

```java
public class ToStringExample {
    private int number;
    public ToStringExample(int number) {
        this.number = number;
    }
}
```

```java
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
```

```html
ToStringExample@4554617c    // 类名@地址值(默认的hashCode)
```

- 建议每个类都覆写toString()方法。方便调试。
- 静态的 Arrays.toString() 方法可以直接打印数组。打印多维数组使用Arrays.deepToString()方法。

```java
System.out.print(System.out);
java.io.PrintStream@2f6684      // 输出类名和HashCode

int[] a = {1, 2, 3};
Arrays.toString(a);             // [1, 2, 3]    Arrays类已经覆写了toString()
```

------

#### clone()

- 是 protected 的方法。
- 详细用法见接口章节中的 Cloneable 接口。





### 9. ArrayList 类

#### 概述

- ArrayList是一个采用类型参数的**泛型数组列表类**。保存元素的**类型**放在尖括号中。
- 如果添加元素时数组满了，会自动创建更大的数组并把所有对象从小数组**拷贝**到大数组。
- ArrayList 实现了Serializable, Cloneable, Iterable\<E>, Collection\<E>, List\<E>, RandomAccess 等接口。
- ArrayList对象**不能存储基本类型**，只能存储**引用类型**的数据。类似 \<int> 不能写，但是存储基本数据类型对应的**包装**类型是可以的。所以，想要存储基本类型数据，<> 中的数据类型，需要使用==基本类型包装类==，如\<Integer> 也可能用到基本数据类型，JVM会根据场景进行自动拆箱、自动装箱。
- 插入与删除元素效率低，因为需要移动其它元素。
- ArrayList中的操作**不是线程安全**的。所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者**CopyOnWriteArrayList**。
- ArrayList 实际上是通过一个数组去保存数据的。当我们构造ArrayList时；若使用默认构造函数，则ArrayList的默认容量大小是10。
- 当ArrayList 容量不足以容纳全部元素时，ArrayList会重新设置容量：新的容量 = “(原始容量x3)/2 + 1”。
- ArrayList 的克隆函数，即是将全部元素克隆到一个数组中。
- ArrayList 实现 java.io.Serializable 的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。

```java
ArrayList<Employee> staff = new ArrayList<Employee>();
// 右边的类型参数可省并指定初始大小 一定要写，避免多次自动扩容影响性能
ArrayList<Employee> staff = new ArrayList<>(100);  
// 遍历方法
for(Employee e : staff){
    e.raiseMoney(300);
}

for(int i = 0; i < staff.size(); i++){
    staff.get(i).raiseMoney(300);
}
```



#### ArrayList类 API

```java
public boolean add(E obj); 				// 将指定元素添加到此集合的尾部
public boolean add(int index, E obj); 	// 在指定位置插入元素，后面的元素往后移动
public E remove(int index); 			// 删除指定位置上的元素，返回被删除的元素
public E get(int index);    			// 返回指定位置上的元素
public int size();  					// 返回此集合中的元素数目
public void trimToSize();  	// 将数组列表的存储容量削减到当前尺寸，确保数组不会有新元素添加的时候调用
public void set(int index, E obj);		// 设置数组列表指定位置的值，覆盖原有内容。
```



#### ArrayList 源码解析

详细见容器章节。





### 100. 其他类

#### BigDecimal / BigInteger

BigInteger 和 BigDecimal 类可以处理任意长度数字序列的数值，用于**精确计算**。

BigInteger不是基本数据类型之一，是一个类，然而它的初始化方式却没有 String 那么方便可以直接赋值，而是需要调用它的**构造器**进行初始化。

BigInger(String val) 这个构造器，可以直接将十进制的字符串格式变成大整数。

既然不是基本数据类型，所以大数的加减乘除也**不能**使用 +、-、*、/ 这些运算符号，Java也没有对这些运算符号进行重定义，取而代之的是用一些方法来代替，比如add()、subtract()、mutiply()、divide() 这四种方法。

```Java
BigInteger a = BigInteger.valueOf(100);
// API BigInteger和BigDecimal 的方法类似
BigInteger abs()                    // 返回大整数的绝对值
BigInteger add(BigInteger val)      // 返回两个大整数的和
BigInteger divide(BigInteger val)   // 返回两个大整数的商
float floatValue()                  // 返回大整数的float类型的值
int intValue()                      // 返回大整数的整型值
long longValue()                    // 返回大整数的long型值
BigInteger max(BigInteger val)      // 返回两个大整数的最大者
BigInteger min(BigInteger val)      // 返回两个大整数的最小者
BigInteger mod(BigInteger val)      // 用当前大整数对val求模
BigInteger multiply(BigInteger val) // 返回两个大整数的积
BigInteger pow(int exponent) 返回当前大整数的exponent次方
BigInteger remainder(BigInteger val) 返回当前大整数除以val的余数
BigInteger subtract(BigInteger val)返回两个大整数相减的结果
String toString() 将当前大整数转换成十进制的字符串形式
```



#### Random 类

##### Random 类概述

- Random 类位于 java.util 包中，主要用于生成伪随机数。

- Random 类将 种子数 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关

- 创建 Random 实例时，若没有指定种子数，则会以**当前时间**作为种子数，来计算生成伪随机数。

- 拥有相同种子的 Random 实例，在相同次数下，生成的伪随机数完全相同

```java
Random random1 = new Random(10);
Random random2 = new Random(10);
System.out.println(random1.nextInt()); // -1157793070
System.out.println(random2.nextInt()); // -1157793070
```

- Random 类是**线程安全**的，多个线程可以同时使用一个Random 实例对象，不过如果并发性很高，会产生竞争，这是可以考虑使用多线程库中的 **ThreadLocalRandom** 类。

##### Random 类的常用方法

**random.nextBoolean()**

- 用于从该随机数生成器的序列中得到下一个伪均匀分布的 boolean 值

    ```java
    Random random = new Random();
    System.out.println(random.nextBoolean()); // true
    ```

**random.nextBytes()**

- 用于生成随机 byte 值并将其放入用户提供的 byte 数组中

- 生成的随机 byte 数等于 byte 数组的长度

```java
Random random = new Random();
byte[] data = new byte[5];
random.nextBytes(data);
System.out.println(Arrays.toString(data)); // [29, 73, -58, -60, -101]
```

**random.nextInt()**

- 用于从该随机数生成器的序列中得到下一个伪均匀分布的 int 值

    ```java
    Random random = new Random();
    System.out.println(random.nextInt()); // 1414623307
    ```

**random.nextInt(int bound)**

- 用于从该随机数生成器的序列中得到下一个 0 到结束值之间伪均匀分布的 int 值，**[0, 结束值)**

```java
Random random = new Random();
System.out.println(random.nextInt(10)); // 5
```









## 六、常用接口

### 1. Comparable接口

- **Arrays.sort()** 方法可以对==对象数组==排序，但是要求对象所属的类必须实现了==Comparable接口==。
- Comparable接口

```java
public interface Comparable<T> {
    // 用这个对象与other进行比较，如果这个对象小于other则返回负值，相等返回0，大于other则返回正值
    int compareTo(T other);     // parameter has type T 已经为泛型接口
}
```

使用泛型Comparable接口可提供类型参数。

```java
Class Employee implements Comparable<Employee> {    // 传入类型参数
    // 实现接口中的方法
    @Override
    public int compareTo(Employee other){   
        return Double.compare(salary, other.salary);    
    }
}
```

排序测试

```java
Employee[] staff = new Employee[3];     // 对象数组

staff[0] = new Employee("Harry Hacker", 35000);
staff[1] = new Employee("Carl Cracker", 75000);
staff[2] = new Employee("Tony Tester", 38000);

Arrays.sort(staff);     // 使用静态方法进行排序 排序方式为指定的方法排序

// 打印排序后的结果
for (Employee e : staff){
    System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
}
```





### 2.  Comparator 接口

- 注意对比上一节。
- **Arrays.sort()**方法可以对实现了 Comparable 接口的类对象的数组进行排序。
- Arrays.sort()方法还有第二种形式，即传入**一个对象数组和一个比较器**作为参数。**比较器**是实现了Comparator 接口的类的实例。
- 比较 Comparator 接口和 Comparable 接口

```java
public interface Comparator<T> {
    int compare(T first, T second);     // 比较方法
}

public interface Comparable<T> {
    int compareTo(T other);     // parameter has type T 已经为泛型接口
}
```

Comparator 接口使用示例

```Java
// 实现一个长度比较器类
class LengthComparator implements Comparator<String> {
    public int compare(String first, String second){    // 实现接口方法
        return first.lenth - second.length();
    }
}

// 一般使用
Comparator<String> comp = new LengthComparator();
if(comp.compare(words[i], words[j]) > 0){...}

// 在Arrays.sort()中使用
String[] names = {"Bob", "Jack", "Alice"};
// 传入一个比较器对象
Arrays.sor(names, new LengthComparator());
```





### 3. Cloneable接口(对象克隆)

#### Cloneable接口与Clone方法

clone() 是 Object 的 **protected** 方法，它不是 public，一个类不显式去重写 clone()，其它类就**不能直接去调用**该类实例的 clone() 方法。

```Java
public class CloneExample {
    private int a;
    private int b;
}
```

```java
CloneExample e1 = new CloneExample();
// CloneExample e2 = e1.clone(); // 'clone()' has protected access in  'java.lang.Object' 不能直接通过简单对象访问
```

**重写Clone方法**得到以下实现：

```java
public class CloneExample {
    private int a;
    private int b;

    // 仅覆写clone()方法没有实现了Cloneable接口
    @Override
    public CloneExample clone() throws CloneNotSupportedException {
        return (CloneExample)super.clone();
    }
}
```

```java
CloneExample e1 = new CloneExample();
try {
    CloneExample e2 = e1.clone();       // 尝试克隆
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
```

```java
java.lang.CloneNotSupportedException: CloneExample      // 上述结果抛出异常
```

以上抛出了**CloneNotSupportedException**，这是因为 CloneExample **没有**实现 Cloneable 接口。

应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，**如果一个类没有实现 ==Cloneable 接口==又调用了 clone() 方法，就会抛出 CloneNotSupportedException**。以下是实现Cloneable 接口便可以克隆了。

```java
// 实现Cloneable接口
public class CloneExample implements Cloneable {
    private int a;
    private int b;

    // 覆写clone()方法
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();   // 实现了Cloneable接口才能使用超类的clone方法
    }
}
```

Cloneable接口其实**不含任何方法**，成为**标记接口**。其作用在于允许在类型查询中使用 instanceof 方法，如果没有这个标记接口而使用clone方法就会像上面抛出异常。

#### 克隆与拷贝(复制)

对于浅拷贝，拷贝对象和原始对象的引用类型引用同一个对象。也就是两个对象会有==共享的子对象==。String 等**不可变**的对象即使是浅拷贝也是安全的。

实例代码如下：

```java
public class ShallowCloneExample implements Cloneable {

    private int[] arr;      // 可变类，浅拷贝会造成原对象与拷贝后的对象对此子对象域共享 
    private int index;      // 基本类型没问题
    private String name;    // String 等不可变类就算共享也安全 因为不可变

    public ShallowCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
	
    // 覆写克隆方法
    @Override
    public ShallowCloneExample clone() throws CloneNotSupportedException {
        return (ShallowCloneExample) super.clone();
    }
}
```

测试代码

```java
ShallowCloneExample e1 = new ShallowCloneExample();
ShallowCloneExample e2 = null;
try {
    e2 = e1.clone();
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);     			// 改变e1，e2中的arr[]也被改变了。因为浅拷贝使两者共享此子对象
System.out.println(e2.get(2));  // 222
```

#### 深拷贝

- 深拷贝：拷贝对象和原始对象的引用类型引用不同对象。重新定义clone方法来同时克隆所有子对象。
- 即使clone默认的(浅拷贝)实现能够满足要求，还是需要实现 Cloneable 接口，并将clone重新定义为public，再调用 super.clone()。

深拷贝实例代码

```java
public class DeepCloneExample implements Cloneable {

    private int[] arr;      

    public DeepCloneExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }

    // 重写了一个实现了深拷贝的clone方法
    @Override
    protected DeepCloneExample clone() throws CloneNotSupportedException {
        DeepCloneExample result = (DeepCloneExample) super.clone(); // 先默认方法克隆一个对象
        // 再克隆该对象的全部可变类子类的内容
        result.arr = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            result.arr[i] = arr[i];
        }
        return result;  // 返回克隆好的对象
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
```

```java
DeepCloneExample e1 = new DeepCloneExample();
DeepCloneExample e2 = null;
try {
    e2 = e1.clone();    // 克隆e1
} catch (CloneNotSupportedException e) {
    e.printStackTrace();
}
e1.set(2, 222);         // 设置e1
System.out.println(e2.get(2));      // 深拷贝后e2不受影响
```

#### clone() 的替代方案

使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，**可以使用拷贝构造方法或者拷贝工厂来拷贝一个对象**。

```java
// 不使用Cloneable接口的拷贝
public class CloneConstructorExample {

    private int[] arr;  

    // 默认构造方法
    public CloneConstructorExample() {
        arr = new int[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
        }
    }
    
    // 实现一个可以进行深拷贝的构造方法 传入需要拷贝的原对象
    public CloneConstructorExample(CloneConstructorExample original) {
        arr = new int[original.arr.length];
        for (int i = 0; i < original.arr.length; i++) {
            arr[i] = original.arr[i];
        }
    }

    public void set(int index, int value) {
        arr[index] = value;
    }

    public int get(int index) {
        return arr[index];
    }
}
```

```java
CloneConstructorExample e1 = new CloneConstructorExample();     // 构造e1
CloneConstructorExample e2 = new CloneConstructorExample(e1);   // 拷贝e1
e1.set(2, 222);
System.out.println(e2.get(2));      // 2 实现深拷贝
```

------

#### 数组与拷贝

所以数组类型都有一个 public 的 clone 方法，而不是 protected ，可以使用这个方法建立一个完全**新的**数组，包含原数组的副本。

```javascript
int[] numbers = {2, 3, 4};
int[] cloned = number.clone();
cloned[1] = 12;     // numbers数组不受影响
```





### 4. Iterator 接口

迭代器（iterator）让我们能够从第一项开始完整**遍历**一个数据集合。一个迭代周期内，每个数据项都被访问一次。

#### Iterable 接口

```java
public interface Iterable<T> {
    /**
     * 返回一个迭代器 ※
     */
    Iterator<T> iterator();

    /**
     * 默认实现
     */
    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }

    default Spliterator<T> spliterator() {
        return Spliterators.spliteratorUnknownSize(iterator(), 0);
    }
}
```

实现了此接口的类可以返回一个Iterator迭代器对象，可以进行迭代操作。

---

#### Iterator 接口

```java
public interface Iterator<E> {
    /**
    * 是否含有下一个元素
    */    
    boolean hasNext();

    /**
    * 返回下一个元素
    */
    E next();

    /**
     * 删除一个元素
     */
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /**
     * 默认实现方法
     */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

共4个方法，常用是前三个。

迭代器对象内部有一个**游标**，如下图所示的集合。集合有 N 个元素，则游标可能出现在 N + 1 个位置。

![1564904971002](assets/1564904971002.png)

方法hasNext() 返回游标后面是否还有元素，方法 next() 返回游标后的一个元素，并将游标后移；方法 remove() 将删除**最后一次调用** next() 方法时返回的项。

![1564905147285](assets/1564905147285.png)



**不能同时连续两次调用** remove() 方法，因为调用之前必须要调用 next() 方法**移动游标**才行，否则抛UnsupportedOperationException异常。一般操作如下。

```java
// String类型的迭代器
Iterator<String> nameIterator = nameList.iterator();
while(nameIterator.haseNext()) {
    System.out.println(nameIterator.next());
}
```

---

#### ListIterator接口

| 方法          | 功能                               |
| :------------ | :--------------------------------- |
| hasNext()     | 判断是否还有下一个元素可以迭代     |
| next()        | 返回下一个元素                     |
| hasPrevious() | 判断是否还有上一个元素可以迭代     |
| previous()    | 返回上一个元素                     |
| add()         | 返回上一个元素（可选方法）         |
| set(E e)      | 用指定的元素**替换**最近返回的元素 |
| remove()      | 移除最近返回的元素                 |

比 Iterator 接口多了一些方法。使其可以在前后两个方向上移动游标，同样 remove() 方法需要**先**调用next() 或者previous() 方法。

![1564905982004](assets/1564905982004.png)

- ListIterator有`add()`方法，可以向List中添加对象，而 Iterator 不能。
- ListIterator 和 Iterator 都有 hasNext() 和 next() 方法，可以实现顺序向后遍历，但是 ListIterator 有**hasPrevious() ** 和 **previous() **方法，可以实现**逆向（顺序向前）遍历**。Iterator 就不可以。
- 都可实现删除对象，但是 ListIterator 可以实现对象的**修改**，set() 方法可以实现。Iierator 仅能遍历，不能修改。









































