[TOC]

### 树题目

#### 判断是否是平衡二叉树

##### 1. 题目

给定一个二叉树，判断它是否是**高度平衡的二叉树**。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的**绝对值不超过 1**。

**示例 1:**

给定二叉树 [3, 9, 20, null, null, 15, 7]

```java
    3
   / \
  9  20
    /  \
   15   7
```
返回 true 。

**示例 2:**

给定二叉树 [1,2,2,3,3,null,null,4,4]

```java
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回 false 。
链接：https://leetcode-cn.com/problems/balanced-binary-tree

##### 2. 题解

###### 暴力递归法

直接使用树形 dp 套路求解。

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }
	// 递归函数
    private Info process(TreeNode root) {
        // Base case
        if(root == null) {
            return new Info(true, 0);
        }
		// 默认获取到左右的信息
        Info left = process(root.left);
        Info right = process(root.right);
        // 构造自己的返回信息
        boolean isBalanced = left.isBalanced && right.isBalanced && (Math.abs(left.height - right.height) <= 1);
        // 最大高度+1
        int height = Math.max(left.height, right.height) + 1;
        return new Info(isBalanced, height);
    }
}
// 定义一个返回类
class Info {
    // 是否平衡
    boolean isBalanced;
    // 最大高度
    int height;

    public Info(boolean isBalanced, int height) {
        this.isBalanced = isBalanced;
        this.height = height;
    }
}
```

----

#### 求二叉树的深度

##### 1. 题目

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，**最长**路径的长度为树的深度。

例如：

给定二叉树 [3, 9, 20, null, null, 15, 7]

        3
       / \
      9  20
        /  \
       15   7
返回它的最大深度 3 。

链接：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof

##### 2. 题解

树的遍历方式总体分为**两类**：**深度优先搜索（DFS）、广度优先搜索（BFS）**；

**常见的 DFS** ： **先序遍历、中序遍历、后序遍历；**
**常见的 BFS** ： **层序遍历（即按层遍历）。**

求树的深度需要遍历树的所有节点，本文将介绍基于 **后序遍历（DFS） 和 层序遍历（BFS）**的两种解法。

###### 递归法 DFS（后序遍历）

树形 dp 套路求解，但是此处的**返回值就是 int** 本身，其实都不用额外构造返回的数据结构了。

树的后序遍历 / 深度优先搜索往往利用 **递归 或 栈** 实现，本文使用**递归**实现。
关键点： 此树的深度和其左（右）子树的深度之间的**关系**。显然，此树的深度 等于 左子树的深度 与 右子树的深度 中的 **最大值 +1** 。

```java
public int maxDepth(TreeNode root) {
    // Base case
    if(root == null) {
        return 0;
    }
    // 默认从左右获取信息
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    // 构造自己的高度信息
    return Math.max(left, right) + 1;
}
```

简化一点 ....

```java
public int maxDepth(TreeNode root) {
    if(root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

###### ② 层序遍历（BFS）

树的层序遍历 / 广度优先搜索往往利用 **队列** 实现。

**关键点：** 每遍历一层，则计数器 +1 ，直到**遍历完成**，则可得到树的深度。

这种方式慢一点只能击败 20%，但是面试经常考非递归。

```java
class Solution {
    public int maxDepth(TreeNode root) {
        // Base case
        if(root == null)
            return 0;
        // 维护一个队列
        Queue<TreeNode> queue = new LinkedList<>();
        // 初始化高度为0
        int h = 0;
        // 根节点入队列
        queue.offer(root);
        // 循环直到队列为空
        while(!queue.isEmpty()){
            // 高度+1
            h++;
            // 获取当前队列的尺寸，也就是这一层的元素
            int size = queue.size();
            // 弹出当前这一层的元素，并把其左右子节点放入队列中
            for(int i = 0; i < size; i++){
                // 取队列
                TreeNode node =  queue.poll();
                if(node.left != null)
                    queue.offer(node.left);
                if(node.right != null)
                    queue.offer(node.right);
            }
        }
        return h;
    }
}
```



#### 二叉树的最小深度

##### 1. 题目

给定一个二叉树，找出其最小深度。

最小深度是**从根节点到最近叶子节点**的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3, 9, 20, null, null, 15, 7]。

```java
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最小深度  2.

链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree

##### 2. 题解

###### ① 递归法

直接使用暴力递归非常 easy。

```java
class Solution {
    public int minDepth(TreeNode root) {
        // Base case
        if(root == null) {
            return 0;
        }
        // 直接获取左边的信息和右边信息
        int minLeft = minDepth(root.left);
        int minRight = minDepth(root.right);
        // 构造自己的返回信息
        if(minLeft != 0 && minRight == 0) {
            return minLeft + 1;
        } 
        if(minLeft == 0 && minRight != 0) {
            return minRight + 1;
        } 
        // 左右高度较小的+1
        return Math.min(minLeft, minRight) + 1;
    }
}
```

###### ② 深度优先搜索迭代

我们可以利用**栈**将上述解法中的递归变成**迭代**。

想法是对于**每个节点**，按照**深度优先搜索**的策略访问，同时在**访问到叶子节点**时**更新最小深度**。

我们从一个**包含根节点**的栈开始，当前深度为 1 。

然后开始迭代：**弹出**当前栈顶元素，将它的孩子节点**压入栈**中。当遇到叶子节点时**更新最小深度**。

```java
import javafx.util.Pair;
public int minDepth(TreeNode root) {
    // 使用：使用了Pair类来管理当前结点和它的高度
    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();
    // Base case
    if (root == null) {
        return 0;
    } else {
        // 将root入栈
        stack.add(new Pair(root, 1));
    }
	// 最小深度
    int minDepth = Integer.MAX_VALUE;
    // 栈不为空持续弹出
    while (!stack.isEmpty()) {
        // 弹出元素并处理数据
        Pair<TreeNode, Integer> current = stack.pollLast();
        root = current.getKey();
        int currentDepth = current.getValue();
        if ((root.left == null) && (root.right == null)) {
            minDepth = Math.min(minDepth, currentDepth);
        }
        // 添加数据到栈
        if (root.left != null) {
            stack.add(new Pair(root.left, currentDepth + 1));
        }
        if (root.right != null) {
            stack.add(new Pair(root.right, currentDepth + 1));
        }
    }
    return minDepth;
}
```

- 时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。
- 空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 O(N)。

###### ③ 广度优先搜索迭代

前面**深度优先搜索方法**的**缺陷**是**所有节点**都必须访问到，以保证能够找到最小深度。因此复杂度是 O(N) 。

一个**优化**的方法是利用**广度优先搜索**，我们按照树的**层去迭代**，**第一个访问到的叶子就是最小深度的节点**，这样就不用遍历所有的节点了。

```java
import javafx.util.Pair;
public int minDepth(TreeNode root) {
    // 使用栈
    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();
    if (root == null) {
        return 0;
    } else {
        stack.add(new Pair(root, 1));
    }

    int currentDepth = 0;
    while (!stack.isEmpty()) {
        // 弹出元素
        Pair<TreeNode, Integer> current = stack.poll();
        // 获取当前元素的结点与值
        root = current.getKey();
        currentDepth = current.getValue();
        // 如果当前元素是一个叶子结点，直接跳出循环，然后返回高度即可
        if ((root.left == null) && (root.right == null)) {
            break;
        }
        // 否则先将左子节点压栈，再将右子节点压栈即可
        if (root.left != null) {
            stack.add(new Pair(root.left, currentDepth + 1));
        }
        if (root.right != null) {
            stack.add(new Pair(root.right, currentDepth + 1));
        }
    }
    return currentDepth;
}
```



#### N叉树的最大深度

##### 1. 题目

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 `3叉树` :

<img src="树题目.assets/image-20200421094921748.png" alt="image-20200421094921748" style="zoom:40%;" />

我们应返回其最大深度，3。

连接：https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/

##### 2. 题解

###### ① 递归法

也是使用递归法，也是用暴力递归即可。过程不多说了，只是获取默认信息的时候默认是从全部的子树获取的信息。

```java
public int maxDepth(Node root) {
    // Base case：为null
    if(root == null) {
        return 0;
    }
    // 当为叶子结点直接返回1
    if(root.children == null || root.children.size() == 0) {
        return 1;
    }
    // 使用列表存储各个子树的高度信息值
    List<Integer> heightList = new ArrayList();
    // 获取各个子树的高度信息并存入列表
    for(Node head : root.children) {
        heightList.add(maxDepth(head));
    }
    // 返回最大的高度+1
    return Collections.max(heightList) + 1;
}
```

###### ② 迭代法

我们还可以在**堆栈**的帮助下将上面的递归转换为**迭代**。

思路是是使用**深度优先**搜索策略访问每个节点，同时**更新每次访问时的最大深度**。

所以可以从包含根节点的、对应深度为 1 的栈开始。
然后继续迭代，**从栈中弹出当前节点并将子节点压入栈中**，每次都**更新对应深度**。

```java
import javafx.util.Pair;
import java.lang.Math;

class Solution {
    public int maxDepth(Node root) {
        // 使用栈保存结点和高度信息
        Queue<Pair<Node, Integer>> stack = new LinkedList<>();
		// 加入root结点
        if (root != null) {
            stack.add(new Pair(root, 1));
        }
		// 最大深度为0
        int depth = 0;
        while (!stack.isEmpty()) {
            // 弹出一个结点
            Pair<Node, Integer> current = stack.poll();
            // 获取当前节点和高度值
            root = current.getKey();
            int currentDepth = current.getValue();
            // 当前节点不为null时
            if (root != null) {
                // 更新最大深度值
                depth = Math.max(depth, currentDepth);
                // 并将子节点全部加入栈中
                for (Node c : root.children) {
                    stack.add(new Pair(c, currentDepth + 1));    
                }
            }
        }
        return depth;
    }
}
```



#### 二叉树遍历

##### 1. 题目

写出二叉树的前序、中序、后续遍历。

##### 2. 题解

###### ① 递归方式前序遍历

```java
/**
 * 递归方式前序遍历
 *
 * @param head 头结点
 */
public void preOrderRecursive(Node head) {
    if (head == null) {
        return;
    }
    // 第一次到达结点时处理数据
    System.out.println(head.value + " ");
    preOrderRecursive(head.left);
    preOrderRecursive(head.right);
}
```

###### ② 递归方式中序遍历

```java
/**
 * 递归方式中序遍历
 *
 * @param head 头结点
 */
public void midOrderRecursive(Node head) {
    if (head == null) {
        return;
    }
    preOrderRecursive(head.left);
    // 第二次到达结点时处理数据
    System.out.println(head.value + " ");
    preOrderRecursive(head.right);
}
```

######  ③ 递归方式后序遍历

```java
/**
 * 递归方式后序遍历
 *
 * @param head 头结点
 */
public void postOrderRecursive(Node head) {
    if (head == null) {
        return;
    }
    preOrderRecursive(head.left);
    preOrderRecursive(head.right);
    // 第三次到达结点时处理数据
    System.out.println(head.value + " ");
}
```

###### ④ 非递归方式前序遍历

使用栈，先将根节点压栈，只要栈不为空则一直弹出，弹出一个处理数据，然后先压入右孩子，再压入左孩子（一定是先右后左）。

   1.先将**根节点**入栈
   2.访问根节点
   3.如果根节点存在右孩子，则将**右孩子**入栈
   4.如果根节点存在左孩子，则将**左孩子**入栈（注意：**一定是右孩子先入栈，然后左孩子入栈**）
   5.重复 2 - 4

```java
/**
 * 非递归方式前序遍历
 *
 * @param head 头结点
 */
public void preOrderUnRecursive(Node head) {
    if (head != null) {
        // 准备一个栈并把根节点压栈
        Stack<Node> stack = new Stack<>();
        stack.push(head);
        // 不断从栈中弹出元素弹出时处理数据，并先将右孩子压栈再讲左孩子压栈
        while(!stack.isEmpty()) {
            // 弹出栈顶的结点
            head = stack.pop();
            // 处理数据
            System.out.println(head.value + " ");
            // 右孩子压栈
            if (head.right != null) {
                stack.push(head.right);
            }
            // 左孩子压栈
            if (head.left != null) {
                stack.push(head.left);
            }
        }
    }

}
```

###### ⑤ 非递归方式中序遍历

   1.先将**根节点**入栈
   2.将当前节点的**所有左孩子**入栈，直到**左孩子为空**
   3.访问**栈顶**元素，如果栈顶元素**存在右孩子**，则继续第 2 步
   4.重复第 2、3 步，直到**栈为空**并且所有的节点都被访问

```java
/**
 * 非递归方式中序遍历
 *
 * @param head 头结点
 */
public void midOrderUnRecursive(Node head) {

    if (head != null) {
        // 准备一个栈
        Stack<Node> stack = new Stack<>();
        while (!stack.isEmpty() || head != null) {
            // 持续将左子节点压栈直到左子树全部压栈
            if (head != null) {
                stack.push(head);
                head = head.left;
            } else {
                // 弹出一个结点并处理数据
                head = stack.pop();
                System.out.println(head.value + " ");
                // 当前节点变到右子树
                head = head.right;
            }
        }
    }
}
```

###### ⑥ 非递归方式后序遍历

使用**两个栈** s1 和 s2。

1. 将**根节点**压入 s1 中。
2. 从 s1 中弹出元素，并依次将其**左孩子和右孩子压入 s1** 中。此过程中**每从 s1 弹出一个元素都将其压入到栈 s2 中**。直到 s1 **为空**为止。
3. 从 s2 中依次弹出元素处理即是**后序遍历**。

```java
/**
 * 非递归方式后序遍历
 *
 * @param head 头结点
 */
public void postOrderUnRecursive(Node head) {
    if (head != null) {
        // 准备两个栈
        Stack<Node> s1 = new Stack<>();
        Stack<Node> s2 = new Stack<>();
        // 根节点压入栈1
        s1.push(head);
        // 退出条件为栈1为空
        while (!s1.isEmpty()) {
            // 栈1弹出一个元素就放入栈2
            head = s1.pop();
            s2.push(head);
            // 再将弹出结点的左右子节点分别入栈S1
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s1.push(head.right);
            }
        }
        // 当栈1的全部元素进入栈2时 栈2依次弹出即可
        while (!s2.isEmpty()) {
            System.out.println(s2.pop().value + "");
        }
    }
    
}
```

###### ⑦ 二叉树的 Morris 遍历

参考

https://www.jianshu.com/p/484f587c967c

可以根据 Morris 遍历加工出二叉树的前中后序遍历。空间复杂度 **O(1)**。



#### 二叉树的层序遍历 I

##### 1. 题目

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即**逐层地**，从左到右访问所有节点）。

示例：
二叉树：[3, 9, 20, null, null, 15, 7]

```java
    3
   / \
  9  20
    /  \
   15   7
```
返回其层次遍历结果：

```java
[
  [3],
  [9,20],
  [15,7]
]
```

链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal

##### 2. 题解

###### ① 迭代法BFS

对二叉树的层序遍历就是使用 BFS 遍历，那么可以使用**队列**进行辅助。

- 根节点入队
- 循环直到队列为空，每次出队一个结点，并将其左右子节点入队
- 为了控制按层进行打印，需要有个循环记录一下这一层的结点个数，所以使用一个 for 循环来遍历这一层。
- 当一层的元素处理完的时候，下一层的结点又已经全部入队，持续循环即可。

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        // Base case
        if(root == null) {
            return new ArrayList();
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>() ;
        // 根节点入队列
        queue.add(root);
        List<List<Integer>> resList = new ArrayList();
        // 队列为空时推退出循环
        while(queue.size() != 0) {
            // 获取当前队列中的元素个数，也就是当前这一层有多少个结点
            int len = queue.size();
            List<Integer> levelList = new ArrayList();
            // 将当前层的元素依次出队列并处理数据，每弹出一个结点并再次将其左右子节点入队列
            for(int i = 0; i < len; i++) {
                // 出队列并处理数据
                TreeNode temp = queue.poll();
                levelList.add(temp.val);
                // 将出队结点的左右子节点入队
                if(temp.left != null) queue.add(temp.left);
                if(temp.right != null) queue.add(temp.right);
            }
            // 这一层弹出的元素处理完毕
            resList.add(levelList);
            // 此时下一层的全部节点已经到队列中，再次循环即可
        }
        return resList;
    }
```

###### ② 递归法DFS

最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：

- 输出列表称为 levels，当前**最高层数**就是列表的**长度 len(levels)**。比较访问节点**所在的层次 level** 和**当前最高层**次 len(levels) 的大小，如果前者**更大就向 levels 添加一个空列表**。
- 将当前节点插入到**对应层的列表** **levels[level]** 中。
- 递归**非空的孩子节点**：helper(node.left / node.right, level + 1)。

```java
class Solution {
    List<List<Integer>> levels = new ArrayList<List<Integer>>();
	// 辅助方法
    public void helper(TreeNode node, int level) {
        // start the current level
        if (levels.size() == level)
            // 添加一层新的到结果中
            levels.add(new ArrayList<Integer>());

         // fulfil the current level
         levels.get(level).add(node.val);

         // process child nodes for the next level
         if (node.left != null)
            helper(node.left, level + 1);
         if (node.right != null)
            helper(node.right, level + 1);
    }
    
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return levels;
        helper(root, 0);
        return levels;
    }
}
```

##### 3. 变形

给定一个二叉树，返回其节点值**自底向上的层次遍历**。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。

例如：
给定二叉树 [3, 9, 20, null, null, 15, 7]

```java
	3
   / \
  9  20
    /  \
   15   7
```

返回其自底向上的层次遍历为：

```java
[
  [15,7],
  [9,20],
  [3]
]
```

链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii

##### 2. 题解

思路类似前面的普通层序遍历，但是是反过来的，其实很容易想到只需要把上述题目的解逆序即可。

参考上述的 BFS 解法，只需在最后调用

```java
Collections.reverse(resList);
```

将结果逆序即可。



#### 二叉树的层平均值

##### 1. 题目

给定一个非空二叉树, 返回一个由每层节点**平均值**组成的数组.

输入:

```java
    3
   / \
  9  20
    /  \
   15   7
```

输出: [3, 14.5, 11]
解释:
第 0 层的平均值是 3,  第 1 层是 14.5, 第 2 层是 11。因此返回 [3, 14.5, 11]。
链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree

##### 2. 题解

###### ① 广度优先遍历方式

参考层序遍历二叉树的代码，求每一层的平均值即可。在原来的代码上小改即可。

```java
public List<Double> averageOfLevels(TreeNode root) {
    // Base case
    if(root == null) {
        return new ArrayList();
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>() ;
    // 根节点入队列
    queue.add(root);
    List<Double> resList = new ArrayList();
    // 队列为空时推退出循环
    while(queue.size() != 0) {
        // 获取当前队列中的元素个数，也就是当前这一层有多少个结点
        int len = queue.size();
        double sum = 0;
        // 将当前层的元素依次出队列并处理数据，每弹出一个结点并再次将其左右子节点入队列
        for(int i = 0; i < len; i++) {
            // 出队列并处理数据
            TreeNode temp = queue.poll();
            // 转换成double类型
            sum = sum + (double)temp.val;
            // 将出队结点的左右子节点入队
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
        // 这一层弹出的元素处理完毕
        resList.add(sum / len);
        // 此时下一层的全部节点已经到队列中，再次循环即可
    }
    return resList;
}
```

###### ② 深度优先搜索

我们可以使用**深度优先搜索**遍历整颗二叉树。我们使用**两个数组 sum** 存放树中**每一层的节点数值之和**，以及 count 存放树中每一层的**节点数量之和**。在遍历时，我们需要**额外记录当前节点所在的高度**，并根据高度 h **更新数组元素 sum[h]** 和 count[h]。在遍历结束之后，**res = sum / cnt** 即为答案。

```java
public class Solution {
    public List <Double> averageOfLevels(TreeNode root) {
        // 每层的元素个数数组
        List <Integer> count = new ArrayList<>();
        // 每层元素和数组
        List <Double> sum = new ArrayList<>();
        // 递归求上述的两个数组的值
        average(root, 0, sum, count);
        // 求平均值
        for (int i = 0; i < res.size(); i++)
            res.set(i, sum.get(i) / count.get(i));
        return sum;
    }
    
    public void average(TreeNode t, int i, List<Double> sum, List<Integer> count) {
        // Base case
        if (t == null)
            return;
        if (i < sum.size()) {
            sum.set(i, sum.get(i) + t.val);
            count.set(i, count.get(i) + 1);
        } else {
            sum.add(1.0 * t.val);
            count.add(1);
        }
        average(t.left, i + 1, sum, count);
        average(t.right, i + 1, sum, count);
    }
}
```











