[TOC]

## 子字符串查找

### 1 字符串匹配问题

一个字符串 str1= "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好，和一个子串 str2="尚硅谷你尚硅你"
现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回 -1。



### 2 暴力匹配算法

如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有:

- 如果当前字符匹配成功（即str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符
- 如果失配（即str1[i] ! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。
- 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)

```java
/**
 * 暴力匹配字符串
 * @author cz
 */
public class ViolentMatch {

    public static void main(String[] args) {
        // 测试暴力匹配算法
        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String str2 = "尚硅谷你尚硅你";
        int index = violenceMatch(str1, str2);
        System.out.println("index =" + index);
    }

    /**
     * 暴力匹配算法实现
     * @param str1 原始字符串
     * @param str2 子串
     * @return 是否存在
     */
    public static int violenceMatch(String str1, String str2) {
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int stringLength1 = s1.length;
        int stringLength2 = s2.length;

        // i索引指向s1
        int mainIndex = 0;
        // j索引指向s2
        int subIndex = 0;
        // 保证匹配时，不越界
        while (mainIndex < stringLength1 && subIndex < stringLength2) {
            // 匹配ok
            if(s1[mainIndex] == s2[subIndex]) {
                mainIndex++;
                subIndex++;
                // 没有匹配成功
            } else {
                // 匹配不成功
                mainIndex = mainIndex - (subIndex - 1);
                subIndex = 0;
            }
        }

        // 判断是否匹配成功
        if(subIndex == stringLength2) {
            return mainIndex - subIndex;
        } else {
            return -1;
        }
    }

}
```



### 3 KMP算法

KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。

Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串 P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这 3 人的姓氏命名此算法.
KMP方法算法就利用之前判断过信息，通过一个 **next** 数组，保存模式串中前后**最长公共子序列**的长度，每次回溯时，通过 nex t数组找到前面匹配过的位置，省去了大量的计算时间。

非常详细的帖子：https://www.cnblogs.com/imzhr/p/9613963.html

```java
/**
 * KMP 匹配
 * @author cz
 */
public class KmpMatch {

    /**
     * 求出一个字符数组的next数组
     * @param subChars 字符数组
     * @return next数组
     */
    public static int[] getNextArray(char[] subChars) {
        int[] next = new int[subChars.length];
        next[0] = -1;
        next[1] = 0;
        int k;
        for (int j = 2; j < subChars.length; j++) {
            k = next[j-1];
            while (k != -1) {
                if (subChars[j - 1] == subChars[k]) {
                    next[j] = k + 1;
                    break;
                }
                else {
                    k = next[k];
                }
                // 当k == -1而跳出循环时，next[j] = 0，否则 next[j] 会在 break 之前被赋值
                next[j] = 0;
            }
        }
        return next;
    }

    /**
     * 对主串s和模式串t进行KMP模式匹配
     * @param main 主串
     * @param sub 模式串
     * @return 若匹配成功，返回t在s中的位置（第一个相同字符对应的位置），若匹配失败，返回-1
     */
    public static int kmpMatch(String main, String sub){
        char[] mainArray = main.toCharArray();
        char[] subArray = sub.toCharArray();
        int[] next = getNextArray(subArray);
        int i = 0, j = 0;
        while (i < mainArray.length && j < subArray.length){
            if(j == -1 || mainArray[i] == subArray[j]){
                i++;
                j++;
            }
            else {
                j = next[j];
            }
        }
        if(j == subArray.length) {
            return i - j;
        }
        else {
            return -1;
        }
    }

    public static void main(String[] args) {
        System.out.println(kmpMatch("abcabaabaabcacb", "abaabcac"));   // 6
    }
}
```



