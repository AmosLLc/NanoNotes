### 反转链表

#### 1 题目

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-linked-list



#### 2 题解

##### 递归法

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {

        if(head == null || head.next == null) {
            return head;
        }
        ListNode resultNode = new ListNode(head.val);
        head = head.next;
        while(head != null) {
            ListNode newNode = new ListNode(head.val);
            newNode.next = resultNode;
            resultNode = newNode;
            head = head.next;
        }

        return resultNode;
    }
}
```





##### 递归法

递归的两个条件：

- **终止条件**是当前节点或者下一个节点 == null

- 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

  ```java
  head.next.next = head
  ```

  很不好理解，其实就是 head 的下一个节点指向 head。
  递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。
  动画演示如下：     

![递归.gif](assets/206-反转链表（简单）/反转链表之递归.gif)

```java
class Solution {
	public ListNode reverseList(ListNode head) {
		// 递归终止条件是当前为空，或者下一个节点为空
		if(head == null || head.next == null) {
			return head;
		}
		// 这里的cur就是最后一个节点
		ListNode cur = reverseList(head.next);
		// 这里请配合动画演示理解
		// 如果链表是 1->2->3->4->5，那么此时的cur就是5
		// 而head是4，head的下一个是5，下下一个是空
		// 所以head.next.next 就是5->4
		head.next.next = head;
		// 防止链表循环，需要将head.next设置为空
		head.next = null;
		// 每层递归函数都返回cur，也就是最后一个节点
		return cur;
	}
}
```





