[TOC]

### Redis哨兵

主从复制带来了以下问题：

- 一旦主节点**出现故障**，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要**人工干预**。
- 主节点的写能力受到单机的限制。

- 主节点的存储能力受到单机的限制。

这一点也不高可用。

主节点出现故障时，**Redis Sentinel** 能**自动完成故障发现和故障转移**，并**通知应用方**，从而实现真正的**高可用** 。

#### Redis Sentinel架构

Redis Sentinel 是一个**分布式架构**，其中包含若干个 Sentinel 节点和 Redis 数据节点，每个 Sentinel 节点会对数据节点和**其余** Sentinel 节点进行监控，当它发现节点不可达时，会对节点做**下线标识**。如果被标识的是**主节点**，它还会和其他Sentinel 节点进行“协商”，当大多数 Sentinel 节点**都认为主节点不可达**时，它们会**选举出一个 Sentinel 节点**来完成**自动故障转移**的工作，同时会将这个变化实时通知给 Redis 应用方。

整个过程完全是自动的，不需要人工来介入，实现了高可用。

Redis Sentinel 与 Redis 主从复制模式**只是多了若干 Sentinel 节点**，所以 Redis Sentinel **并没有**针对 Redis 节点做了特殊处理。

<img src="9 Redis哨兵.assets/image-20200429213813871.png" alt="image-20200429213813871" style="zoom:48%;" />

**Sentinel 节点本身就是独立的 Redis 节点，只不过它们有一些特殊，它们不存储数据，只支持部分命令。** 

Sentinel 节点**集合**会定期对**所有节点**进行监控，特别是对主节点的**故障实现自动转移**。

#### 故障转移过程

主节点出现**故障**，此时两个从节点与主节点**失去连接**，**主从复制失败**。

<img src="9 Redis哨兵.assets/image-20200429215800635.png" alt="image-20200429215800635" style="zoom:32%;" />

每个 Sentinel 节点通过**定期监控**发现主节点出现了故障。 

<img src="9 Redis哨兵.assets/image-20200429220002221.png" alt="image-20200429220002221" style="zoom:35%;" />

多个 Sentinel 节点对主节点的故障**达成一致**，**选举出 sentinel-3 节点作为领导者负责故障转移**。

<img src="9 Redis哨兵.assets/image-20200429220304376.png" alt="image-20200429220304376" style="zoom:33%;" />

Sentinel 领导者节点执行了**故障转移**。

<img src="9 Redis哨兵.assets/image-20200429220337493.png" alt="image-20200429220337493" style="zoom:33%;" />

这里从节点 1 变成主节点。首先从节点 1 设置 slave of no one 使其成为主节点，然后从节点 2 的主节点设置为从节点 1，然后 Sentinel 领导者节点**通知**客户端，之后原来的故障主节点重启成为一个**从节点**。

故障转移后整个 Redis Sentinel 的拓扑结构图如下。

<img src="9 Redis哨兵.assets/image-20200429221148481.png" alt="image-20200429221148481" style="zoom:33%;" />

可以看出 Redis Sentinel 具有以下几个功能:

- **监控**：Sentinel 节点会定期检测 Redis 数据节点、其余 Sentinel 节点是否可达。
- **通知**：Sentinel 节点会将故障转移的结果通知给应用方。
- **主节点故障转移**：实现从节点晋升为主节点并维护后续正确的主从关系。
- **配置提供者**：在 Redis Sentinel 结构中，客户端在初始化的时候连接的是 Sentinel 节点**集合**，从中获取主节点信息。

Redis Sentine l包含了**若个 Sentinel 节点**，这样做也带来了两个好处:
1. 对于节点的**故障判断**是由多个 Sentinel 节点**共同完成**，这样可以有效地**防止误判**。
2. Sentinel节点集合是由若干个 Sentinel节 点组成的，这样即使个别 Sentinel 节点不可用，整个 Sentinel 节点集合依然是健壮的。防止 Sentinel 的单点故障。



#### Redis Sentinel部署与配置

部署实操可以看看 Sentinel 架构的部署过程：https://blog.csdn.net/cuiwjava/article/details/98844949

##### 1. 配置参数及优化

Redis 安装目录下有一个 **sentinel.conf**，是默认的 Sentinel 节点配置文件。

```bash
port 26379	# 端口
dir /opt/soft/redis/data  # 工作目录
sentinel monitor mymaster 127.0.0.1 6379 2	# 配置主节点地址端口，不可达票数为2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
#sentinel auth-pass <master-name> <password>
#sentinel notification-script <master-name> <script-path>
#sentinel client-reconfig-script <master-name> <script-path>
```

**① sentinel monitor**

```bash
sentinel monitor <master-name> <ip> <port> <quorum>
```

Sentinel 节点会定期监控**主节点**，所以从配置上必然也会有所体现，Sentinel 节点要监控的是一个名字叫做 \<master-name>，ip 地址和端口为 \<ip>\<port> 的**主节点**。

**\<quorum>** 代表要判定**主节点最终不可达所需要的票数**。\<quorum>参数用于故障发现和判定，例如将 quorum 配置为2，代表至少有 2 个 Sentinel 节点**认为**主节点不可达，那么这个不可达的判定才是客观的。一般建议将其**设置为 Sentinel 节点数量的一半加 1**。

同时 **\<quorum>** 还与 Sentinel 节点的**领导者选举**有关，至少要有 **max（quorum，num（sentinels）/2+1）**个 Sentinel 节点参与选举，才能选出领导者 Sentinel，从而完成故障转移。

但实际上 Sentinel 节点会对**所有节点**进行监控，但是在 Sentinel 节点配置中没有看到有关从节点和其余 Sentinel 节点的配置，那是因为 Sentinel 节点会**自动**从**主节点**中获取有关**从节点以及其余 Sentinel 节点**的相关信息。 

例如某个 Sentinel **初始节点配置**如下：

```bash
port 26379
daemonize yes
logfile "26379.log"
dir /opt/soft/redis/data
sentinel monitor mymaster 127.0.0.1 6379 2	# 只有主节点的配置
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
```

 当所有节点启动后，配置文件中的内容发生了**变化**，原来的配置文件中会**自动加入从节点和其他 Sentinel 结点的信息**，并且会去掉一些默认配置参数。如下。

```bash
port 26379
daemonize yes
logfile "26379.log"
dir "/opt/soft/redis/data"
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
#发现两个slave节点
sentinel known-slave mymaster 127.0.0.1 6380
sentinel known-slave mymaster 127.0.0.1 6381
#发现两个sentinel节点
sentinel known-sentinel mymaster 127.0.0.1 26380 282a70ff56c36ed56e8f7ee6ada741
24140d6f53
sentinel known-sentinel mymaster 127.0.0.1 26381 f714470d30a61a8e39ae031192f1fe
ae7eb5b2be
sentinel current-epoch 0
```

Redis Sentine l可以**同时监控多个主节点**。配置时只需要指定**多个 masterName** 来区分不同的主节点即可。

<img src="9 Redis哨兵.assets/image-20200429230935558.png" alt="image-20200429230935558" style="zoom:43%;" />

**② sentinel down-after-milliseconds**

配置结点间不可达超时时间。

```bash
sentinel down-after-milliseconds <master-name> <times>
```

每个 Sentinel 节点都要通过**定期发送 ping 命令**来判断 Redis 数据节点和其余 Sentinel 节点**是否可达**，如果超过了 down-after-milliseconds 配置的**时间**且没有有效的回复，则判定节点不可达，\<times>（单位为毫秒）就是超时时间。

**③ sentinel parallel-syncs **

用来限制在一次故障转移之后，**每次向新的主节点发起复制操作**的从节点个数。

```bash
sentinel parallel-syncs <master-name> <nums>
```

**④ sentinel failover-timeout **

failover-timeout 通常被解释成**故障转移超时时间**，但实际上它作用于故障转移的各个阶段。

##### 2. 部署技巧

- Sentinel 节点不应该部署在一台物理“机器”上。
- 部署**至少三个且奇数个**的 Sentinel 节点。3 个以上是通过增加 Sentinel 节点的个数提高对于故障判定的**准确性**，因为领导者选举需要至少一半加 1 个节点，奇数个节点可以在满足该条件的基础上节省一个节点。



#### Redis Sentinel API与客户端

##### 1. Sentinel API

Sentinel 节点是一个**特殊的 Redis 节点**，它有自己**专属的 API**。

**① sentinel masters**

展示所有被监控的**主节点**状态以及相关的统计信息。

```bash
127.0.0.1:26379> sentinel masters
1) 1) "name"
2) "mymaster-2"
3) "ip"
4) "127.0.0.1"
5) "port"
6) "6382"
.........忽略............
2) 1) "name"
2) "mymaster-1"
3) "ip"
4) "127.0.0.1"
5) "port"
6) "6379"
.........忽略............
```

**② sentinel master \<master name>**

展示指定 \<master name> 的**主节点**状态以及相关的统计信息。

**③ sentinel slaves \<master name>**

展示指定 \<master name> 的**从节点**状态以及相关的统计信息。

**④ sentinel sentinels \<master name>**

 展示指定 \<master name> 的 **Sentinel 节点集合**（不包含当前 Sentinel节点)。

**⑤ sentinel failover \<master name>**

对指定 \<master name> **主节点进行强制故障转移**（没有和其他 Sentinel 节点“协商”），当故障转移完成后，其他 Sentinel 节点按照故障转移的结果**更新自身配置**，这个命令在 Redis Sentinel 的**日常运维中非常有用**.

```bash
127.0.0.1:26379> sentinel failover mymaster-2
OK
```

**⑥ sentinel remove \<master name>**

取消对某个主节点的监控。

##### 2. 客户端连接

###### ①概述

Sentinel 节点集合具备了监控、通知、自动故障转移、配置提供者若干功能，也就是说实际上最了解主节点信息的就是 Sentinel 节点集合，而各个主节点可以通过 \<master-name> 进行标识的，所以无论哪种编程语言的客户端，如果需要正确地连接 Redis Sentinel，必须有 **Sentinel 节点集合和 masterName 两个参数**。

客户端基本操作：

- 遍历 Sentinel 节点集合获取一个可用的 Sentinel 节点，Sentinel 节点之间可以**共享数据**，所以从**任意**一个 Sentinel 节点获取**主节点**信息都是可以的。

- 需要**验证**当前获取的“主节点”是真正的主节点，这样做的目的是为了防止**故障转移期间**主节点的变化。

- 保持和 Sentinel 节点集合的“联系”，时刻获取关于主节点的相关“信息”。

###### ② Jedis

Jedis 提供了 Sentinel 连接池。

````java
public JedisSentinelPool(String masterName, # 主节点名
       Set<String> sentinels,	# Sentinel节点集合
       final GenericObjectPoolConfig poolConfig,    # common-pool连接池配置
       final int connectionTimeout,		# 连接超时
       final int soTimeout,			# 读写超时
       final String password, 	# 主节点密码
       final int database,		# 当前数据库索引
       final String clientName)	# 客户端名
````

连接时**遍历** Sentinel 结点集合，找到**一个**可用的 Sentinel 结点，然后从中得到**主节点信息**。