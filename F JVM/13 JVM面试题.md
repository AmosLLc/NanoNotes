[TOC]

### JVM面试题

#### JVM是如何工作的？

如下面的体系结构图所示（Java8 之前），JVM 分为三个主要的子系统：

1. 类加载器子系统
2. 运行时数据区
3. 执行引擎

<img src="assets/435918-20180701233830808-854564995.png" alt="img" style="zoom:47%;" />

**1、类加载器子系统**

Java 的动态类加载功能是由类加载器子系统处理的。它负责加载、链接，并且在**运行时**首次引用类的时候初始化类，而不是在编译期间。

**1.1、加载**

这个组件负责加载类。BootStrap 类加载器、Extension 类加载器和 Application 类加载器是实现这个功能的三大类加载器。

1. **BootStrap 类加载器** —— 负责从 classpath 加载类，如果没有类存在，将只加载**rt.jar**。这个加载器的优先级最高。
2. **Extension 类加载器** —— 负责加载**扩展文件夹（jre\lib）**中的类。
3. **Application 类加载器** —— 负责加载**应用级 classpath **和环境变量指向的路径下的类。

上述**类加载器**在加载类文件时遵循**委托层次结构算法**。

**1.2、链接**

1. **校验** —— 字节码验证器将校验生成的字节码是否正确，如果校验失败，我们将获得**校验错误信息**。
2. **准备** —— 对于所有的静态变量，内存将被申请并分配默认值。
3. **解析** —— 所有**标记的内存引用**从**方法区域**被替换成的**原始引用**。

**1.3、初始化**

这是类加载的最后阶段，所有的静态变量都将被分配原值，静态代码块将被执行。

**2. 运行时数据区**

运行时数据区被划分为五个主要部分：

- **方法区** —— 所有**类级数据**都将存储在这里，包括**静态变量**。每一个JVM只有一个方法区，并且它是一个共享资源。
- **堆区** —— 所有**对象**及其对应的**实例变量**和**数组**等存储在此，每个JVM同样只有一个堆区。由于**方法区**和**堆区**是多线程内存共享，因此存储的数据是非线程安全的。
- **栈区** —— 每个线程都会创建一个单独的**运行时栈**。在每一次**方法调用**，都会在栈内存中创建一个**栈帧（Stack Frame）**。所有**局部变量**将在栈内存中创建。栈区是线程安全的，因为它不是一个共享资源。栈帧可以被划分为三个实体：

> **局部变量数组** —— 与方法中有多少局部变量有关，相应的值将存储在此处。
> **操作数栈** —— 如果任何的中间操作需要被执行，**操作数栈**将作为运行时工作区来执行操作。
> **帧数据** —— 与方法相对应的所有符号存储在此。在任何异常情况下，catch块的信息被保留在帧数据中。

- **PC寄存器** —— 每一个线程都有单独的**PC寄存器**，一旦执行指令，PC寄存器将被下一条指令**更新**，保存当前**执行指令**的地址。
- **本地方法栈** —— 本地方法栈保存本地方法信息，每一个线程都会创建一个单独的本地方栈。

**3、执行引擎**

分配到运行时数据区的字节码将被执行引擎执行。执行引擎读取字节码并逐一执行。

- **解释器** —— 解释器能更加快速地解释字节码，但是执行缓慢。解释器的缺点是当多次调用一个方法时，每次都要重新解释。
- **JIT编译器** —— JIT编译器弥补了解释器的不足。执行引擎使用解释器来转换字节码，当它发现重复的代码时，它将使用JIT编译器来编译整个字节码并转换为本地代码。本地代码将直接被重复的方法所调用，从而提高系统性能。
- **中间代码生成器** —— 生成中间代码。
- **代码优化器** —— 负责优化上述生成的中间代码。
- **目标代码生成器** —— 负责生成机器码或者本地代码。
- **分析器** —— 一个特殊的组件，负责查找热点代码，比如一个方法是否被调用多次。
- **垃圾回收器** —— 回收并删除未引用的对象。可以通过调用**System.gc()**来触发垃圾回收，但不能保证它执行。JVM的垃圾回收是回收被创建的对象。

**Java本地接口（JNI）**：**JNI**与**本地方法库**交互，并为执行引擎提供**本地方法库**。

**本地方法库（Native Method Libraries）**：它是执行引擎所需的本地库集合。



#### Student s = new Student(); 在内存中做了哪些事情

1. 加载 Student.**class 文件进内存** 。
2. 在**栈内存**为 s 开辟空间 。
3. 在**堆内存**为 Student **对象开辟空间** 。
4. 对 Student 对象的成员变量进行**默认初始化** 。
5. 对 Student 对象的成员变量进行**显示初始化** 。
6. 通过**构造方法**对 Student 对象的成员变量赋值 。
7. Student 对象**初始化完毕**，把**对象地址赋值给 s 变量** 。



#### JVM线程死锁，你该如何判断是因为什么？如果用VisualVM，dump线程信息出来，会有哪些信息

常常需要在隔两分钟后再次收集一次 thread dump，如果得到的输出相同，仍然是大量 thread 都在等待给同一个地址上锁，那么肯定是死锁了。