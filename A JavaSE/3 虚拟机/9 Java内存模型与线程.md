[TOC]

### Java 内存模型与线程

#### 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有好几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的**高速缓存**来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：**缓存一致性。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存**，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生了这样的情况，那同步回到主内存时以谁的缓存数据为准呢？

为了解决缓存一致性问题，需要**各个处理器访问缓存时都遵守一些协议，在读写时要根据协议来进行操作**，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。在本章中将会多次提到“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型。

除了增加了高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行结果进行重组，保证结果与顺序执行的结果是一致的，但不保证程序中的各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后执行顺序来保证。

与处理器的乱序执行优化类似，Java虚拟机的**即时编译器中也有类似的指令重排序优化**。
![image-20191212141507998](assets/image-20191212141507998.png)



#### Java 内存模型

Java虚拟机规范中试图定义一种**Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上都能达到一致的内存访问效果。**



##### 主内存与工作内存

Java 内存模型的主要目标是定义程序中各个**变量的访问规则**，即在虚拟机中将变量**存储到内存和从内存中取出**变量这样的底层细节。此处的变量与 Java 编程中的所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不会存在竞争问题。
Java 内存模型规定了所有的**变量**都存储在**主内存**中（此处的主内存与物理硬件时的主内存名字一样，两者可以相互类比，但此处仅是虚拟机内存的一部分）。

每条**线程**都有自己的**工作内存**（与前面讲的处理器高速缓存类比），线程的工作内存保存了被该线程**==使用到的变量的主内存副本拷贝==**，**==线程对变量的所有操作都必须在工作内存中进行，而不是直接读写主内存中的变量==**。不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存**来完成，线程、工作内存、主内存之间的关系，如下图所示：
![image-20191212141821169](assets/image-20191212141821169.png)

这里所讲的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等并不是同一层次的内存划分。这两者基本没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。（**主内存保存了对象实例数据，工作内存保存了被该线程使用到的变量的主内存副本拷贝**）



##### 内存间交互操作

主内存和工作内存之间具体的**交互协议**：一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之类的实现细节，Java 内存模型中定义了 8 种**操作**来完成，虚拟机实现时

需保证这**==八种操作都是原子==**的、不可再分的（对于 long 和 double 类型的变量来说，load、store、read、write 操作在某些平台上允许例外）。

|  操作  |                             说明                             |
| :----: | :----------------------------------------------------------: |
|  lock  | （锁定）作用于主内存的变量，它把一个变量标识为一条线程独占的状态 |
| unlock | （解锁）作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 |
|  read  | （读取）作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用 |
|  load  | （载入）作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入到工作内存的变量副本中 |
|  use   | （使用）作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时将会执行这个操作 |
| assign | （赋值）作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 |
| store  | （存储）作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中，以便随后的write操作使用 |
| write  | （写入）作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入到主内存的变量中 |

如果要把一个变量从主内存复制到工作内存，那就要**顺序**地执行 read 和 load 操作，如果要把变量从工作内存同步到主内存中，就要顺序地执行 store 和 write 操作。注意，Java 内存模型只要求上述**两个**操作**必须按顺序**执行，而**没有保证是连续**执行。也就是说在 read 和 load，store 和 write 之间是可插入**其他指令**的。除此之外，Java 内存模型还规定了在执行上述八种基本操作时必须满足的规则。



##### 对于volatile型变量的特殊规则

关键字 volatile 可以说是 Java 虚拟机提供的**最轻量级的同步机制**。

当一个变量被声明为 volatile 之后，它将具备两种特性：**第一是保证此变量对所有线程的==可见性==**。这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即可知的，任何被 volatile 修饰的变量，都不拷贝副本到工作内存，任何修改都及时写在主存。因此对于 valatile 修饰的变量的修改，所有线程马上就能看到。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。例如，线程 A 修改了一个普通变量的值，然后向主内存中进行回写，另外一条线程 B 在线程 A 回写完成之后再从主内存进行读取操作，新变量值才会对线程 B 可见。

volatile 变量在各个线程的工作内存中**不存在一致性**问题，但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是**不安全**的。

由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。

运算结果不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值。
变量不需要与其他的状态变量参与不变约束。
**使用volatile变量的第二个语义是==禁止指令重排序优化==**，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的“线程内表现为串行的语义”。
volatile 修饰的变量，赋值后多执行了一个 “lock ....” 操作，这个操作相当于一个**==内存屏障==**（重排序时不能把后面的指令重排序到内存屏障之前的位置），在有多个 CPU 访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性。

volatile 为何要禁止指令重排序呢？从硬件架构上讲，指令重排序是指  CPU 采用了允许将多条指令不按程序规定的顺序分开发送给相应的电路单元处理。但并不是指令任意重排，CPU 需要能正确处理指令依赖情况以保障程序能得到正确的执行结果。例如指令 1 把地址 A 中的值加 10，指令 2 把地址 A 中的值乘以 2，指令 3 把地址 B 中的值减去 3，这时指令 1 和指令 2 是有依赖的，它们之间的顺序是不能重排的，但是指令 3 可以重排到指令 1 和 2 之前或者中间，只要保证 CPU 执行后面依赖 A、B 值的操作时能获得正确的 A、B 值即可。所以在本内 CPU 中，重排序看起来依然是有序的。因此，lock 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。

我们在 volatile 与锁之中选择的唯一依据仅仅是 volatile 的语义是否满足使用场景的要求。


##### 对于long和double型变量的特殊规则

Java 内存模型要求 lock、unlock、read、load、use、assign、store、write 这八个操作都具有**原子性**，但是对于 64 位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile修饰的 **64 位数据类型**的读写操作划分为**两次 32 位的操作**来进行，即允许虚拟机实现选择**可以不保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性**，这点就是所谓的 long 和 double 的**非原子协定**。

上面也就是说没有被 volatile 修饰的  64 位数据类型的变量如果被多个线程共享，并且同时对其进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也非其他线程修改的“**半个变量**”的数值。

不过读取到“半个变量”的情况非常罕见（在目前的商用 Java 虚拟机中不会出现），因为 Java 内存模型虽然允许虚拟机不把 long  和  double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。

在实际的开发中，目前各种平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的 long 和 double 变量专门声明为 volatile。


##### 原子性、可见性与有序性

Java 内存模型围绕着在并发过程中如何处理**原子性、可见性、有序性**这三个特征来建立的。

- **原子性**：由 Java 内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是**具备原子性**的（例外的就是 long 和 double 的**非原子协定**，读者只要知道这件事就可以了，无需太过在意这些几乎不会发生的例外情况）。如果应用场景需要**更大范围的原子性**保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机没有直接将 lock 和 unlock 操作开放给用户使用，但是却提供了更高层次的字节码指令：**monitorenter 和 monitorexit**，这两个字节码指令反映到 Java 代码中就是**同步块 - synchronized关键字**，因此在 Synchronized 块之间的操作也具备**原子性**。
- **可见性**：是指当一个线程修改了共享变量的值，其他线程能立即得知这个修改。Java 内存模型是通过在变量修改之后**将新值同步到主内存**，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是 volatile 变量都是如此，普通变量与 volatile 变量的区别在于：volatile 的特殊规则保证了新值能立即同步到主内存中，以及每次**使用前立即从主内存刷新**。因此，可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。除了 volatile 之外，Java 还有两个关键字能实现可见性：**Synchronized 和 final**。Synchronized 同步块的可见性是由“对一个变量执行 unlock 之前，必须先把此变量同步到主内存中（执行 store 和write 操作）”这条规则来获得的。而 final 关键字的可见性是指：被final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this” 的引用传递出去（this引用逃逸是一件非常危险的事情，其他线程可能通过这个引用访问到初始化一半的对象），那在其他线程中就能看见 final 字段的值。也就是说 final 变量**都具备可见性**，无需同步就能被其他线程正确访问。
- **有序性**：Java 程序中天然的有序性可以总结为一句话：如果在**本线程内观察，所有的操作都是有序**的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指 “线程内表现为串行的语义”。后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java 提供了 volatile 和 Synchronized 两个关键字来保证线程之间操作的有序性，**volatile 关键字本身就包含了禁止指令重排序的语义**，**而 Synchronized 关键字则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作**”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。
    在需要这三种特性的时候，Synchronized 关键字**都可以**作为其中一种解决方案，看起来是“万能”的。这也造就了 Synchronized 的滥用现象，要注意越是“万能”的并发控制，通常会伴随着越大的性能**消耗**。


##### 重排序对线程的影响

重排序对单线程和多线程程序的执行结果有什么影响呢？
as-if-serial 语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变（顺序一致性）。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。
为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做**重排序**，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。
as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按**程序的顺序**来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。
**重排序会破坏了多线程程序的语义**，因此才需要诸如 volatile 这样的技术来禁止重排序！

**synchronized** 作为一种同步手段，解决 Java 多线程的执行有序性和内存可见性，synchronized **块内仍然存在**重排序现象，但是因为线程的独占性，所以对于一个线程来说，仍然是有顺序一致性保障的。



##### 先行发生原则

如果 Java 内存模型中所有的有序性都仅仅靠 volatile 和 Synchronized 来完成，那么有一些操作将变得很烦琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个“先行发生”的原则。这个原则很重要，是判断数据是否存在竞争、线程是否安全的依据，依靠这个原则，我们通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

Java 内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。

- 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为考虑到分支、循环等结构；
- 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序；
- volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序；
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；
- 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行；
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生；
- 对象终结规则：一个对象初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始；
    传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论；

Java 语言无需任何同步手段保障就能成立的先行发生规则就只有上面这些。
注意：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。





