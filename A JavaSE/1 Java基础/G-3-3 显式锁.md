[TOC]

### 显式锁

#### 1 Lock 接口

`synchronized` 方法或语句的使用提供了对与每个**对象**相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。这个时候 Lock 出现。

Lock 不是 Java 中的关键字而是 java.util.concurrent.locks 包中的一个**接口**。

`Lock` 实现提供了比使用 `synchronized` 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 **`Condition`** 对象。

Lock 相对于 synchronized 关键字而言更加灵活，你可以自由的选择想要加锁的地方。当然更高的自由度也带来更多的责任。

我们通常会在 **try...catch 模块**之前使用 **lock** 关键字，在 **finally** 模块中**释放锁**（保证锁必须释放）。下面是示范代码。

```java
Lock myLock = ...; 
myLock.lock();
try {
    // access the resource protected by this lock
} finally {
    myLock.unlock();
}
```

锁的锁定和释放如果在不同的模块时，需要谨慎编码，确保最后锁一定能够得到**释放**。

##### ① Lock接口中的方法

```java
// 获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态
void lock() 

// 如果当前线程未被中断，则获取锁。
void lockInterruptibly() 

// 返回绑定到此Lock实例的新Condition实例。
Condition newCondition() 

// 仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值true。如果锁不可用，则此方法将立即返回值false。
boolean tryLock() 

// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。
boolean	tryLock(long time, TimeUnit unit) 

// 释放锁。在等待条件前，锁必须由当前线程保持。调用 Condition.await() 将在等待前以原子方式释放锁，并在等待返回前重新获取锁。
void unlock() 
```

Lock 接口有三个**实现类**分别是==**ReentrantLock**,  **ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock**==。后面两个是**内部类**。**ReentrantReadWriteLock** 实现了 **ReadWriteLock** 接口，同时其内部有两个内部类实现了 Lock 接口。

关系图如下所示。

![1582715870763](assets/G-3-3%20%E6%98%BE%E5%BC%8F%E9%94%81/1582715870763.png)





#### 2 ReentrantLock

##### ① 基本使用

**ReentrantLock** 是 java.util.concurrent（**JUC**）包中的锁。

ReentrantLock 的 fair 参数是可以保证公平的，但是保证**公平会影响性能**，一般也不需要，所以**默认非公平**，synchronized 锁也是不保证公平的。

使用 **tryLock** 可以**避免死锁**。它会在持有一个锁 A 获取另一个锁 B 而获取不到 B 的时候，可以释放已持有的锁 A ，给其他线程获取锁 A 的机会，然后**重试**获取所有锁。

```java
public class LockExample {
	// 定义锁
    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();	// 加锁
        try {
            for (int i = 0; i < 10; i++) {
                System.out.print(i + " ");
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁
        }
    }
}
```

```java
public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    // 加锁效果与synchronized类似
    executorService.execute(() -> lockExample.func());
    executorService.execute(() -> lockExample.func());
}
```

```html
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

##### ② 源码解析

###### 1. 公平锁和非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

ReentrantLock 的内部类 **Sync** 继承了 **AQS**，分为**公平**锁 FairSync 和**非公平**锁 NonfairSync。

- 公平锁：线程获取锁的顺序和调用 lock 的顺序一样，**FIFO**；
- 非公平锁：线程获取锁的顺序和调用 lock 的**顺序无关**。

ReentrantLock 默认使用**非公平锁**是基于**性能**考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。

###### 2. 公平锁的实现

尝试**获取锁**，先来看公平锁的实现，lock 方法很简单的一句话调用 AQS 的 **acquire** 方法。

```java
final void lock() { acquire(1);}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

```java
protected boolean tryAcquire(int arg) {    
        throw new UnsupportedOperationException();
}
```

AQS的 tryAcquire 未做具体实现，因为是否获取锁成功是由子类决定的，我们直接来看 ReentrantLock 的**tryAcquire** 的实现。

```java
protected final boolean tryAcquire(int acquires) {
   final Thread current = Thread.currentThread();
   int c = getState();
   if (c == 0) {
       if (!hasQueuedPredecessors() &&
           compareAndSetState(0, acquires)) {
           setExclusiveOwnerThread(current);
           return true;
       }
   }
   else if (current == getExclusiveOwnerThread()) {
       int nextc = c + acquires;
       if (nextc < 0)
           throw new Error("Maximum lock count exceeded");
       setState(nextc);
       return true;
   }
   return false;
}
```

获取锁成功分为两种情况，第一个 if 判断 AQS 的 state 是否等于 0，表示锁**没有人占有**。接着，hasQueuedPredecessors 判断队列是否有排在前面的线程**在等待锁**，没有的话调用 compareAndSetState 使用 CAS 的方式修改 state，传入的 acquires 写死是1。最后线程获取锁成功，setExclusiveOwnerThread 将线程记录为独占锁的线程。

第二个 if 判断当前线程是否为**独占锁**的线程，因为 ReentrantLock 是**可重入**的，线程可以不停地 lock 来增加  state 的值，对应地需要 unlock 来解锁，直到 state 为零。

如果最后获取锁失败，下一步需要将线程加入到等待队列。

###### 3. 线程进入等待队列

AQS 内部有一条**双向队列**存放**等待线程**，节点是 **Node** 对象。每个 Node 维护了线程、前后 Node 的指针和等待状态等参数。

线程在加入队列之前，需要包装进 Node，调用方法是 addWaiter：

```java
private Node addWaiter(Node mode) {
   Node node = new Node(Thread.currentThread(), mode);
   // Try the fast path of enq; backup to full enq on failure
   Node pred = tail;
   if (pred != null) {
       node.prev = pred;
       if (compareAndSetTail(pred, node)) {
           pred.next = node;
           return node;
       }
   }
   enq(node);
   return node;
}
```

每个 Node 需要标记是**独占的还是共享**的，由传入的 mode 决定，ReentrantLock 自然是使用独占模式Node.EXCLUSIVE。

创建好 Node 后，如果队列不为空，使用 CAS 的方式将 Node 加入到队**列尾**。注意，这里只执行了一次修改操作，并且可能因为并发的原因失败。因此修改失败的情况和队列为空的情况，需要进入enq。

```java
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

enq 是个死循环，保证 Node 一定能插入队列。注意到，当队列为空时，会先为头节点创建一个空的 Node，因为头节点代表获取了锁的线程，现在还没有，所以先空着。

###### 4. 阻塞等待线程

线程加入队列后，下一步是调用 **acquireQueued** 阻塞线程。

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // 1
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 2
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

标记 1 是线程唤醒后尝试获取锁的过程。如果前一个节点正好是 head，表示自己排在**第一位**，可以马上调用tryAcquire 尝试。如果获取成功就简单了，直接修改自己为 head。这步是实现公平锁的**核心**，保证释放锁时，由下个排队线程获取锁。（看到线程解锁时，再看回这里）

标记 2 是线程获取锁失败的处理。这个时候，线程可能等着下一次获取，也可能不想要了，Node 变量 waitState描述了线程的等待状态，一共四种情况：

```java
static final int CANCELLED =  1;   	// 取消
static final int SIGNAL    = -1;    // 下个节点需要被唤醒
static final int CONDITION = -2;  	// 线程在等待条件触发
static final int PROPAGATE = -3; 	//（共享锁）状态需要向后传播
```

shouldParkAfterFailedAcquire 传入当前节点和前节点，根据前节点的状态，判断线程**是否需要阻塞**。

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
  int ws = pred.waitStatus;
  if (ws == Node.SIGNAL)
      return true;
  if (ws > 0) {
      do {
          node.prev = pred = pred.prev;
      } while (pred.waitStatus > 0);
      pred.next = node;
  } else {
      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
  }
  return false;
}
```

- 前节点状态是 SIGNAL 时，当前线程需要阻塞；
- 前节点状态是 CANCELLED 时，通过循环将当前节点之前所有取消状态的节点移出队列；
- 前节点状态是其他状态时，需要设置前节点为 SIGNAL。

如果线程需要**阻塞**，由 **parkAndCheckInterrupt** 方法进行操作。

```java
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
```

parkAndCheckInterrupt 使用了 LockSupport，和 CAS 一样，最终使用 UNSAFE 调用 Native 方法实现线程阻塞（LockSupport 的 park 和 unpark 方法作用类似于 wait 和 notify ）。最后返回线程唤醒后的中断状态，关于中断，后文会分析。

到这里总结一下获取锁的过程：==**线程去竞争一个锁，可能成功也可能失败。成功就直接持有资源，不需要进入队列；失败的话进入队列阻塞，等待唤醒后再尝试竞争锁**==。

###### 5. 释放锁

通过上面详细的获取锁过程分析，释放锁过程大概可以猜到：**头节点是获取锁的线程，先移出队列**，再通知后面的节点获取锁。

```java
public void unlock() {
    sync.release(1);
}
```

ReentrantLock 的 unlock 方法很简单地调用了 **AQS** 的 **release**：

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

和 lock 的 tryAcquire 一样，unlock 的 tryRelease 同样由 **ReentrantLock** 实现：

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

因为锁是可以**重入**的，所以每次 lock 会让 state 加 1，对应地每次 unlock 要让 state 减 1，直到**为 0** 时将独占线程变量设置为空，返回**标记是否彻底释放锁**。

最后，调用 unparkSuccessor 将头节点的下个节点唤醒：

```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

寻找下个待唤醒的线程是从**队列尾向前**查询的，找到线程后调用 LockSupport 的 unpark 方法唤醒线程。被唤醒的线程重新执行 acquireQueued 里的循环，就是上文关于 acquireQueued 标记 1 部分，线程重新尝试获取锁。

###### 6. 中断锁

```java
static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```

在 acquire 里还有最后一句代码调用了 selfInterrupt，功能很简单，对当前线程产生一个**中断请求**。

为什么要这样操作呢？因为 LockSupport.park **阻塞**线程后，**有两种可能被唤醒**。

1、第一种情况，前节点是头节点，释放锁后，会调用 LockSupport.unpark 唤醒当前线程。整个过程没有涉及到中断，最终 acquireQueued 返回 false 时，不需要调用 selfInterrupt。

2、第二种情况，LockSupport.park 支持响应中断请求，能够被其他线程通过 interrupt() 唤醒。但这种唤醒并没有用，因为线程前面可能还有等待线程，在 acquireQueued 的循环里，线程会再次被阻塞。parkAndCheckInterrupt 返回的是 Thread.interrupted()，不仅返回中断状态，还会清除中断状态，保证阻塞线程忽略中断。最终 acquireQueued 返回 true 时，真正的中断状态已经被清除，需要调用 selfInterrupt 维持中断状态。

因此普通的 lock 方法并不能被其他线程中断，**ReentrantLock** 是可以**支持中断**，需要使用 **lockInterruptibly**。

两者的逻辑基本一样，不同之处是 parkAndCheckInterrupt 返回 true 时，lockInterruptibly 直接 **throw new InterruptedException()**。

###### 7. 非公平锁的实现

分析完公平锁的实现，还剩下非公平锁，主要区别是**获取锁的过程**不同。

```java
final void lock() {
    if (compareAndSetState(0, 1)) //如果一开始未上锁，直接抢占锁
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

在 NonfairSync 的 lock 方法里，第一步直接尝试将 state 修改为 1，很明显，这是**抢先获取锁**的过程。如果修改state 失败，则和公平锁一样，调用 acquire。

```java
final boolean nonfairTryAcquire(int acquires) {
  final Thread current = Thread.currentThread();
  int c = getState();
  if (c == 0) {
      if (compareAndSetState(0, acquires)) {
          setExclusiveOwnerThread(current);
          return true;
      }
  }
  else if (current == getExclusiveOwnerThread()) {
      int nextc = c + acquires;
      if (nextc < 0) // overflow
          throw new Error("Maximum lock count exceeded");
      setState(nextc);
      return true;
  }
  return false;
}
```

nonfairTryAcquire 和 tryAcquire 乍一看几乎一样，差异只是缺少调用 hasQueuedPredecessors。这点体验出公平锁和非公平锁的不同，**公平锁会关注队列里排队的情况，老老实实按照 FIFO 的次序；非公平锁只要有机会就抢占，才不管排队的事。**



#### 3 Synchronized 与 ReentrantLock 比较

##### ① 使用选择

除非需要使用 ReentrantLock 的高级功能，否则**优先使用 synchronized**。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会**确保锁的释放**。

##### ② 特点对比

1. **锁的实现**

synchronized 是 **JVM** 实现的，而 ReentrantLock 是 **JDK** 实现的。

2. **性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。**能用 synchronized 尽量用**。

3. **等待可中断**

当持有锁的线程长期**不释放锁**的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock **可中断**，而 synchronized **不行**。

4. **公平性**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是**非公平**的，ReentrantLock **默认**情况下也是**非公平**的，但是也可以是**公平**的。

5. **锁绑定多个条件**

一个 ReentrantLock 可以同时绑定**多个** Condition 对象。





#### 4 Condition

##### ① 概述

Condition 是在 Java5 中才出现的，它用来**替代**传统的 Object 的 **wait**()、**notify**() 实现线程间的**协作**，相比使用Object 的 wait()、notify()，使用 Condition 的 **await**()、**signal**() 这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用 Condition。

Condition 类能实现 synchronized 和 wait、notify 搭配的功能，另外比后者更灵活，Condition 可以实现**多路通知**功能，也就是在**一个 Lock 对象**里可以创建**多个 Condition**（即对象监视器）**实例**，线程对象可以注册在指定的 Condition 中，从而**可以有选择的进行线程通知，在调度线程上更加灵活**。而 synchronized 就相当于整个 Lock 对象中只有**一个单一**的 Condition 对象，所有的线程都注册在这个对象上。线程开始 notifyAll 时，需要通知所有的 WAITING 线程，没有选择权，会有相当大的效率问题。

1、Condition是个接口，基本的方法就是 await() 和 signal() 方法。

2、Condition 依赖于 Lock 接口，生成一个 Condition 的基本代码是 lock.newCondition()。 

```java
// 获取锁对象
private Lock lock = new ReentrantLock();
// 通过锁对象获取多个Condition对象
public Condition conditionA = lock.newCondition();
public Condition conditionB = lock.newCondition();
```

3、调用 Condition 的 **await**() 和 **signal**() 方法，都必须在 **lock 保护之内**，就是说必须在 lock.**lock**() 和lock.**unlock**() 之间才可以使用。

4、**Conditon 中的 await() 对应 Object 的 wait()，Condition 中的 signal() 对应 Object 的 notify()，Condition 中的 signalAll() 对应 Object 的 notifyAll()。**



##### ② Condition基本使用实例

**接下来，使用 Condition 来实现等待/唤醒，并且能够唤醒制定线程。**

先写业务代码：

```java
package com.demo.test;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class MyService {
    
    // 实例化一个ReentrantLock对象
    private ReentrantLock lock = new ReentrantLock();
    // 为线程A注册一个Condition
    public Condition conditionA = lock.newCondition();
    // 为线程B注册一个Condition
    public Condition conditionB = lock.newCondition();

    public void awaitA() {
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() + "进入了awaitA方法");
            long timeBefore = System.currentTimeMillis();
            // 执行conditionA等待
            conditionA.await();
            long timeAfter = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName()+"被唤醒");
            System.out.println(Thread.currentThread().getName() + "等待了: " + (timeAfter - timeBefore)/1000+"s");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void awaitB() {
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() + "进入了awaitB方法");
            long timeBefore = System.currentTimeMillis();
            // 执行conditionB等待
            conditionB.await();
            long timeAfter = System.currentTimeMillis();
            System.out.println(Thread.currentThread().getName() + "被唤醒");
            System.out.println(Thread.currentThread().getName() + "等待了: " + (timeAfter - timeBefore)/1000 + "s");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void signallA() {
        try {
            lock.lock();
            System.out.println("启动唤醒程序");
            // 唤醒所有注册conditionA的线程
            conditionA.signalAll();
        } finally {
            lock.unlock();
        }
    }
    
    public void signallB() {
        try {
            lock.lock();
            System.out.println("启动唤醒程序");
            // 唤醒所有注册conditionB的线程
            conditionB.signalAll();
        } finally {
            lock.unlock();
        }
    }
}
```

分别实例化了两个 Condition 对象，都是使用**同一个 lock 注册**。注意 conditionA 对象的等待和唤醒只对使用了conditionA 的线程有用，同理 conditionB 对象的等待和唤醒只对**使用了** conditionB 的线程有用。

继续写两个线程的代码：

```java
package com.demo.test;

public class MyServiceThread1 implements Runnable{

    private MyService service;

    public MyServiceThread1(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.awaitA();
    }
}
```

注意：MyServiceThread1 使用了 **awaitA**() 方法，**持有**的是 **conditionA**！

```java
package com.demo.test;

public class MyServiceThread2 implements Runnable{

    private MyService service;

    public MyServiceThread2(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.awaitB();
    }
}
```

注意：MyServiceThread2 使用了 **awaitB**() 方法，**持有**的是 **conditionB**！

最后看启动类：

```java
package com.demo.test;

public class ApplicationCondition {

    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        Runnable runnable1 = new MyServiceThread1(service);
        Runnable runnable2 = new MyServiceThread2(service);
        
        new Thread(runnable1, "a").start();
        new Thread(runnable2, "b").start();
        
        // 线程sleep2秒钟
        Thread.sleep(2000);
        // 唤醒所有持有conditionA的线程
        service.signallA();
        
        Thread.sleep(2000);
        // 唤醒所有持有conditionB的线程
        service.sgnallB();
    }

}
```

执行 ApplicationCondition，来看控制台输出结果：

![1582717412959](assets/G-3-3%20%E6%98%BE%E5%BC%8F%E9%94%81/1582717412959.png)

a 和 b 都进入各自的 await() 方法。首先执行的是

```java
Thread.sleep(2000);
// 唤醒所有持有conditionA的线程
service.signallA();
```

使用 conditionA 的线程被**唤醒**，而后再唤醒使用 conditionB 的线程。学会使用 Condition，那来用它实现生产者消费者模式。



##### ③ 生产者和消费者

首先来看业务类的实现：

```java
package com.demo.test;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class PCService {

    private Lock lock = new ReentrantLock();
    private boolean flag = false;
    private Condition condition = lock.newCondition();
    // 以此为衡量标志
    private int number = 1;

    /**
     * 生产者生产
     */
    public void produce() {
        try {
            lock.lock();
            while (flag == true) {
                condition.await();
            }
            System.out.println(Thread.currentThread().getName() + "-----生产-----");
            number++;
            System.out.println("number: " + number);
            System.out.println();
            flag = true;
            // 提醒消费者消费
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 消费者消费生产的物品
     */
    public void consume() {
        try {
            lock.lock();
            while (flag == false) {
                condition.await();
            }
            System.out.println(Thread.currentThread().getName() + "-----消费-----");
            number--;
            System.out.println("number: " + number);
            System.out.println();
            flag = false;
            // 提醒生产者生产
            condition.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

生产者线程代码：

```java
package com.demo.test;

/**
 * 生产者线程
 * @author lixiaoxi
 *
 */
public class MyThreadProduce implements Runnable{

    private PCService service;

    public MyThreadProduce(PCService service) {
        this.service = service;
    }

    @Override
    public void run() {
        for (;;) {
            service.produce();
        }
    }

}
```

消费者线程代码：

```java
package com.demo.test;

public class MyThreadConsume implements Runnable{

    private PCService service;

    public MyThreadConsume(PCService service) {
        this.service = service;
    }

    @Override
    public void run() {
        for (;;) {
            service.consume();
        }
    }    
}
```

启动类：

```java
package com.demo.test;

public class PCApplication {

    public static void main(String[] args) {
        PCService service = new PCService();
        Runnable produce = new MyThreadProduce(service);
        Runnable consume = new MyThreadConsume(service);
        new Thread(produce, "生产者  ").start();
        new Thread(consume, "消费者  ").start();
    }
}
```

执行 PCApplication，看控制台的输出：

![img](https://images2017.cnblogs.com/blog/249993/201710/249993-20171015191736793-803988474.png)

因为采用了无限循环，生产者线程和消费者线程会一直处于工作状态，可以看到，生产者线程执行完毕后，消费者线程就会执行，以这样的交替顺序，而且 number 也遵循着生产者生产 + 1，消费者消费 -1 的一个状态。这个就是**使用 ReentrantLock 和 Condition 来实现的生产者消费者模式**。







#### 4 ReentrantReadWriteLock

##### ① 概述

ReentrantLock 实现了标准的互斥重入锁，是一个标准的**排他锁**，即在同一个时刻只能有一个线程持有锁。我们对一个资源的访问有两种方式：**读和写**，读操作一般不会影响数据的一致性问题。但如果我们使用ReentrantLock，则在需要在**读操作的时候也独占锁**，这会导致并发效率大大降低。JUC 包提供了**读写锁ReentrantReadWriteLock，使得读写锁分离**，在上述情境下，应用读写锁相对于使用独占锁，并发性能得到较大提高。

**ReentrantReadWriteLock 表示两个锁，一个是读操作相关的锁，称为==共享锁==；一个是写相关的锁，称为==排他锁==**，描述如下：

线程进入**读锁**的前提条件：

- 没有其他线程的写锁

- 没有写请求或者**有写请求，但调用线程和持有锁的线程是同一个**

线程进入**写锁**的前提条件：

- 没有其他线程的读锁

- 没有其他线程的写锁



##### ② 源码解析

整体结构

```java
public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {

    /** 读锁 */
    private final ReentrantReadWriteLock.ReadLock readerLock;

    /** 写锁 */
    private final ReentrantReadWriteLock.WriteLock writerLock;

    final Sync sync;

    /** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */
    public ReentrantReadWriteLock() {
        this(false);
    }

    /** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }

    /** 返回用于写入操作的锁 */
    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }

    /** 返回用于读取操作的锁 */
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }


    abstract static class Sync extends AbstractQueuedSynchronizer {}

    static final class NonfairSync extends Sync {}

    static final class FairSync extends Sync {}

    public static class ReadLock implements Lock, java.io.Serializable {}

    public static class WriteLock implements Lock, java.io.Serializable {}
}
```

类的继承关系如下

```java
public class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable {}
```

ReentrantReadWriteLock 实现了 **ReadWriteLock** 接口，ReadWriteLock 接口定义了获取**读锁和写锁的规范**，具体需要实现类去实现；同时其还实现了 Serializable 接口，表示可以进行序列化，在源代码中可以看到 ReentrantReadWriteLock 实现了自己的序列化逻辑。









#### 参考资料

- [1] : https://www.cnblogs.com/xiaoxi/p/7651360.html Condition 详解

- [2] : https://www.cnblogs.com/xiaoxi/p/9140541.html "ReentrantReadWriteLock 源码详解"