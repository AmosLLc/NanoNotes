[TOC]

### 泛型约束与局限性

#### 0 本节要点

- 编译期进行泛型**类型擦除**会把**类型变量**替换为相应的**限定类型**。
- 泛型的诸多限制多半是由类型擦除造成的。



#### ==1 类型擦除==

虚拟机**没有**泛型类型对象，虚拟机不知道泛型，所有对象都属于普通类。无论何时定义一个泛型类型，都自动提供了一个相应的**原始类型**(raw type)。

Java 泛型是通过**类型擦除**实现的。

类型擦除的过程即**擦除(erased) 类型变量**, 并**替换**为相应的**限定类型** (无限定的变量用 **Object**)。相当于给类型擦除指定一个**边界**，指定边界之后，类型擦除之后就**不会变为 Object**。原始类型的名字就是删去类型参数后的泛型类型名。

##### ① 没有限定类型参数

如下泛型方法

```java
public Pair(T first, T second) { 
    this.first = first;  this.second = second; 
}
```

类型擦除后原始类型变为

```java
public Pair(Object first, Object second) { 
    this.first = first;  this.second = second; 
}
```

由于**没有限定类型**，所以 T 换为 **Object**。

##### ② 有限定类型参数

另一个类如下

```java
public class Test <T extends Comparable & Serializable> implements Serializable{
    private T lower;
    private T upper;
    public Test (T first, T second){
        if (first.compareTo(second) <= 0) { lower = first; upper = second; }
        else { lower = second; upper = first; }
    }
}
```

由于其有限定类型为 Comparable，所以其原始类型中 **T 变为 Comparable** 得到如下类。类型擦除也会出现在泛型方法中。

```java
// 擦除后变成限定类型
public class Test implements Serializable {
    private Comparable lower;
    private Coiparable upper;
    public Test (Coiparable first, Coiparable second) { . . . }
}
```

Java 泛型转换的事实：

- 虚拟机中没有泛型，只有普通的类和方法。
- 所有的类型参数都用它们的**限定类型替换**。
- **桥方法被合成来保持多态**。
- 为保持类型安全性，必要时插入强制类型转换。





#### 2 泛型的==约束与局限性==

局限性**多半是由类型擦除**引起。

**1. 不能用基本类型实例化类型参数**

不能用类型参数代替基本类型。因此没有 Pair\<double>, 只有 **Pair\<Double>**。其原因是类型擦除。擦除之后，Pair 类含有 **Object** 类型的域，而 Object 不能存储 double 值。

**2. 运行时类型查询只适用于==原始类型==**

虚拟机中的对象总有一个特定的非泛型类型。因此所有的类型查询只产生**原始**类型。
**getClass** 方法总是返回**原始类型**。例如：

```java
Pair<String> stringPair = . .
Pair<Employee> employeePair = . .
if (stringPair.getClass() == employeePair.getClass()) // they are equal
```

其比较的结果是 true, 这是因为两次调用 getClass 都将返回其原始类型 **Pair.class**。

**3. 不能创建参数化类型的数组**

不能实例化参数化类型的数组， 例如：

```java
Pair<String>[] table = new Pair<String>[10]; // 错误 传入String已经是参数化了
```

擦除之后，table 的**类型是 Pair[]**。 可以把它转换为 Object[]:

```java
Object[] objarray = table;
```

数组会**记住**它的元素类型， 如果试图存储其他类型的元素，就会抛出一个 ArrayStoreException 异常。

**但是**可以向**参数个数可变的方法**传递一个泛型类型的实例。如下面的参数可变的方法:

```java
public static <T> void addAll(Collections coll, T... ts){
    for (t : ts) coll.add(t);
}
```

为了调用这个方法，Java 虚拟机必须建立一个 Pair\<String> 数组，这就违反了前面的规则。不过，这种情况只会得到一个**警告**，而不是错误。
可以在 addAll 方法上标注解 @SafeVarargs 或注解 @SuppressWanings("unchecked") 来抑制此警告。可以使用  @SafeVarargs 标注来消除创建泛型数组的有关限制，但是有些危险。

**4. 不能通过类型参数创建对象**

**不能**使用像 **new T(...)  new T[...]  或  T.class**  这样的表达式中的类型变量。最好的是让调用者提供一个**构造器**表达式。

```java
// 非法
public Pair() { 
    first = new T(); 
    second = new T(); 
} 

Pair<String> p = Pair.makePair(String::new);    // 提供构造表达式 合法
```

如果需要**根据类型创建对象**，可以通过**反射**的方式实现。

```java
first = T.class.newInstance(); // 非法 T.class非法，会转为Object.class
// 可以通过以下的API得到class对象
public static <T> Pair<T> makePair(Class<T> cl){
    try { 
        return new Pair<>(cl.newInstance(), cl.newInstance()); }
    catch (Exception ex) { 
        return null; 
    }
}
// 使用如下方式调用
Pair<String> p = Pair.makePair(String.class);
```

**5. 不能创建泛型数组**

数组本身也有类型，用来监控存储在虚拟机中的数组。这个类型会被**擦除**。

```java
public static <T extends Comparable>T[] minmax(T[] a) { T[] mm = new T[2]; ...} // 非法
```

类型擦除会让这个方法**永远构造 Comparable[2] 数组**。如果现实需要能够存放**泛型对象**的容器，可以使用**原始类型**的数组。如。

```java
Pair[] options = new Pair {
    new Pair<String, Integer>("1", 2),
    new Pair<String, Integer>("2", 2)
};
```

泛型容器内部使用 **Object 数组**，如果要转换泛型容器为对应类型的数组，需要使用反射。

 最好让用户提供一个**数组构造器表达式**：

```java
String[] ss = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");
```











