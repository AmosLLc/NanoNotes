[TOC]

### 锁优化

这里的锁优化主要是指 JVM 对 **synchronized** 的优化。



#### 自旋锁

互斥同步进入阻塞状态的开销都很大，应该**尽量避免**。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时**执行忙循环（自旋）**一段时间，如果在这段时间内能获得锁，就可以**避免**进入阻塞状态。

自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作**占用 CPU** 时间，它只适用于共享数据的**锁定状态很短**的场景。如果太长就太多的忙循环了。

在 JDK 1.6 中引入了**自适应的自旋锁**。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。



#### 锁消除

锁消除是指对于被检测出**不可能存在竞争**的共享数据的**锁进行消除**。

锁消除主要是通过**逃逸分析**来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成**私有数据**对待，也就可以将它们的锁进行消除。

对于一些看起来没有加锁的代码，其实**隐式的加了很多锁**。例如下面的字符串拼接代码就隐式加了锁：

```java
public static String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
```

String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 **之前**，会转化为 StringBuffer 对象的连续 append() 操作：

```java
public static String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

每个 append() 方法中都有一个**同步块**。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此**可以进行消除**。



#### 锁粗化

如果一系列的连续操作都对**同一个对象**反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到**整个操作序列**的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。



#### 轻量级锁

JDK 1.6 引入了**偏向锁和轻量级锁**，从而让锁拥有了四个状态：**无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）**。

以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。

![1563602275691](assets/1563602275691.png)

下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。

![1563602285907](assets/1563602285907.png)

轻量级锁是相对于传统的重量级锁而言，它**使用 CAS 操作**来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以**先采用 CAS 操作**进行同步，如果 CAS 失败了**再改用互斥量**进行同步。

当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。

![1563602294897](assets/1563602294897.png)

如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入**同步块**继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要**膨胀为重量级锁**。



#### 偏向锁

偏向锁的思想是偏向于让**第一个**获取锁对象的线程，这个线程在**之后获取该锁**就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

当锁对象第一次被线程获得的时候，进入**偏向状态**，标记为 **1 01**。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就**不需要再进行任何同步**操作。

当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时**撤销偏向**（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。

![1563602307402](assets/1563602307402.png)









