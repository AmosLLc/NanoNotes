[TOC]

### 文件高级操作



#### 1 属性文件

Java 属性文件就是配置文件。其中以**键值对**的形式存放信息。注意，每个键值对结尾**没有分号**。

如：jdbc.properties

```properties
driverClass = com.mysql.jdbc.Driver
url = jdbc:myql:///jdbctest
username = root
password = 123456
```

Java程序可以**调用属性文件**。方式为：

```java
public class JDBCUtils {
	private static final String driverClass;
	private static final String url;
	private static final String username;
	private static final String password;
	
    // 静态语句块
	static {
		// 加载属性文件并解析
		Properties props = new Properties();
		// 使用类加载器获得属性文件的输入流
		InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("jdbc.properties");
		try {
            // 传入流
			props.load(is);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			System.out.println("加载is失败");
		}
        // 设置属性值
		driverClass = props.getProperty("driverClass");
		url = props.getProperty("url");
		username = props.getProperty("username");
		password = props.getProperty("password");
	}
}
```

步骤可以总结为：

- 编写属性文件 xxx.**properties**;

- 获取**属性文件对象**：Properties props = new Properties();

- 使用类加载器获得属性文件**输入流**。这里的路径，属性文件直接放在了 eclipse 的 src 文件夹下，当前类在包下，因为 package 指向的根目录也在 src 文件夹下，所以可以直接**写文件名**。

```java
InputStream is = 当前类.class.getClassLoader().getResourceAsStream("属性文件的路径");  
```

- 属性文件对象加载属性文件对应的输入流：**props.load(is)**;

- **获取**属性值 xxxx = props.getProperty("key");

java.uitl.Properties 类的好处：

- 可以**自动处理空格**，分隔符 = 前后的空格自动忽略。
- 可以自动忽略空行。
- 可以添加**注释**，# 或者 ！开头的行被忽视。
- 限制是不能直接处理中文。



 

#### 2 随机读写文件

Java.io 包提供了 **RandomAccessFile** 类用于**随机文件的创建和访问**。使用这个类，可以**跳转到文件的任意位置读写数据**。程序可以在随机文件中插入数据，而不会破坏该文件的其他数据。此外，程序也可以更新或删除先前存储的数据，而不用重写整个文件。

用于随机读写，更接近于操作系统的 API，在实现以些系统程序时，它比流更为方便高效。

RandomAccessFile 类是 Object 类的直接子类，包含两个主要的构造方法用来创建 RandomAccessFile 的对象，如表 10-11 所示。  

|                     构造方法                      |                             释义                             |
| :-----------------------------------------------: | :----------------------------------------------------------: |
| public RandomAccessFile(String name, String mode) | 指定随机文件流对象所对应的文件名，以 mode 表示对文件的访问模式 |
| public RandomAccessFile (File file, String mode)  | 以 file 指定随机文件流对象所对应的文件名，以 mode 表示访问模式 |

需要注意的是，mode 表示所创建的随机读写文件的**操作状态**，其取值包括：

- r：表示以只读方式打开文件。
- rw：表示以读写方式打开文件，使用该模式只用一个对象即可同时实现读写操作。

RandowAccessFile 类常用的方法及说明如下。

|           **方法**           |                         **功能描述**                         |
| :--------------------------: | :----------------------------------------------------------: |
|        long length()         |                         返回文件长度                         |
|     void seek(long pos)      |      移动文件位置指示器，pos 指定从文件开头的偏离字节数      |
|     int skipBytes(int n)     |           跳过 n 个字节，返回数为实际跳过的字节数            |
|          int read()          | 从文件中读取一个字节，字节的高 24 位为 0，若遇到文件结尾，返回-1 |
|    final byte readByte()     |                  从文件中读取带符号的字节值                  |
|    final char readChar()     |                从文件中读取一个 Unicode 字符                 |
| final void writeChar(inte c) |                    写入一个字符，两个字节                    |



#### 3 内存映射文件

内存映射文件允许创建和修改因为**太大而不能放入内存的文件**。

##### ① 基本使用

```java
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class LargeMappedFiles {

    private static int LENGTH = 0x0000FFF;

    public static void main(String[] args) throws IOException{
        MappedByteBuffer out = new RandomAccessFile("test.dat", "rw")
            .getChannel()
            .map(FileChannel.MapMode.READ_WRITE, 0, LENGTH);

        for(int i = 0; i < LENGTH; i++) {
            out.put((byte)'x');
        }

        for(int i = LENGTH/2; i < LENGTH/2 + 6; i++) {
            System.out.print((char)out.get(i));
        }
    }
}
```

- 本例中首先创建 MappedByteBuffer，并设置为**读写**模式；然后往缓冲器中写入字符 x；最后在文件**中间**开始读取 6 个字符。
- 通过 **RandomAccessFile** 类获取 FileChannel，使其具备读写功能。
- 通过 FileChannel 的 map 方法，获取 MappedByteBuffer，该方法包含三个参数，MapMode 映射类型、开始位置、映射总数量，意味着可以映射大文件的较小部分。
- MappedByteBuffer 是一个特殊的直接缓冲器，对该缓冲器的修改会反映到对应文件中；另外，其继承ByteBuffer，具有 ByteBuffer 的所有方法。



##### ② 总结

（1）内存映射文件和标准 IO 操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到 OS 内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快.

（2）MappedByteBuffer 是一种特殊的**直接缓冲器**，他们相比基础的 IO 操作来说就是**少了中间缓冲区**的数据拷贝开销。同时他们属于 JVM 堆外内存，**不受 JVM 堆内存大小的限制**。

（3）ByteBuffer.allocateDirect() ，通过 DirectMemory 的方式来创建**直接缓冲区**，他在内存上分配空间，与-Xmx和-XX:MaxDirectMemorySize有关，不能超过最大值。



**内存映射文件 I/O** 是一种读和写**文件**数据的方法，它可以比常规的基于流或者基于通道的 I/O **快得多**。

向内存映射文件写入可能是**危险**的，只是改变数组的单个元素这样的简单操作，就**可能会直接修改**磁盘上的文件。修改数据与将数据保存到磁盘是**没有分开**的。

下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。

```java
MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024);
```









