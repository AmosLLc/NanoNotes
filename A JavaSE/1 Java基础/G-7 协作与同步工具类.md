[TOC]

### 协作与同步工具类

java.util.concurrent（**JUC**）大大提高了并发性能，**AQS** 被认为是 **JUC 的核心**。AQS 是 AbstractQueuedSynchronizer 的简称。AQS 提供了一种实现**阻塞锁**和一系列依赖 FIFO 等待队列的**同步器的框架**。

**AQS** 是一个用来构建锁和同步工具的框架，包括常用的 **ReentrantLock、CountDownLatch、Semaphore** 等，注意 CyclicBarrier 不是。



#### CountDownLatch

##### 1. 概述

可理解为一个**倒计时门栓**，一开始是关闭的，所有**希望通过该门**的线程都需要**等待**，然后开始倒计时，倒计时变为 **0** 之后，门栓打开，等待的**所有线程都可以通过**，它是**一次性**的，打开之后不能再关上。

应用：用来控制==一个线程**等待**多个线程==。CountDownLatch 这个类使**一个线程等待其他线程各自执行完毕后**再执行。

维护了一个**计数器 cnt**，每次调用 countDown() 方法会让计数器的值**减 1**，**减到 0** 的时候，那些**因为**调用 **await()** 方法而在等待的线程就会被**唤醒**。

<img src="assets/1563602021597.png" alt="1563602021597" style="zoom:87%;" />

类中有**三个方法**是最重要的：

```java
// 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException {};   
// 和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException {};  
// 将count值减1
public void countDown() {};  
```

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountdownLatchExample {

    public static void main(String[] args) throws InterruptedException {
        // 线程数
        final int totalThread = 10;
        // 定义门栏变量
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        // 线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
		
        // 其他线程
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("run..");
                // -1
                countDownLatch.countDown();
            });
        }
        // 当前线程在此处等待其他线程执行完毕
        countDownLatch.await();
        // 全部完成后打印end
        System.out.println("end");
        executorService.shutdown();
    }
}
```

```html
run..run..run..run..run..run..run..run..run..run..end
```

CountDownLatch 是**一次性**的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它**不能再次被使用**。

##### 2. 源码解析

源码是基于 **AQS 的共享模式**的使用。

有一个静态内部类 Sync，继承了 AQS。主要覆写的是 AQS 中的 **tryAcquireShared** 和 **tryReleaseShared** 方法，也就是实现共享访问，从而实现对状态变量的控制。

```java
private static final class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 4982264981922014374L;
	// 传入count状态值
    Sync(int count) {
        setState(count);
    }

    int getCount() {
        return getState();
    }
	
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

    protected boolean tryReleaseShared(int releases) {
        // Decrement count; signal when transition to zero
        for (;;) {
            // 获取状态值
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c - 1;
            // 使用AQS中的CAS方法设置状态变量的值
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        }
    }
}
```

其他方法的几乎都是在操作 sync 这个内部变量。

```java
private final Sync sync;
```

构造方法如下，需要传入**计数器初始值**。

```java
public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}
```

**countDown** 方法如下。这里就是调用 AQS 的方法释放一个状态值。

```java
public void countDown() {
    sync.releaseShared(1);
}
```

**await** 方法如下。也是调用的 AQS 中的方法。

```java
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```



#### CyclicBarrier

##### 1. 概述

用来控制==多个线程互相等待==，只有当多个线程都到达时，这些线程才会**继续执行**。与上述的 CountDownLatch 类似，不过它是**循环**的，可以用作**重复**的同步。

相当于一个**栅栏**，特别适合用于**并行迭代计算**，每个线程负责一部分计算任务，然后在栅栏处等待其他线程完成，等待所有线程到齐后，交换数据和计算结果，进行**下一次**迭代（可重复）。

和 CountdownLatch 相似，都是通过维护**计数器**来实现的。线程执行 **await**() 方法之后计数器**会减 1**，并进行等待，直到**计数器为 0**，所有调用 **await**() 方法而在等待的线程才能继续执行。

<img src="assets/G-5%20%E5%8D%8F%E4%BD%9C%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/1582792463963.png" alt="1582792463963" style="zoom:57%;" />

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 **reset**() 方法可以**循环使用**，所以它才叫做**循环屏障**。

<img src="G-7 协作与同步工具类.assets/image-20200512001316960.png" alt="image-20200512001316960" style="zoom:42%;" />

CyclicBarrier 有两个构造函数，其中 parties 指示计数器的**初始值**，**barrierAction 在所有线程都到达屏障的时候会执行一次**。

```java
// 可传入一个barrierAction动作
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```

```java
public class CyclicBarrierExample {

    public static void main(String[] args) {
        final int totalThread = 10;
        // 定义一个循环栅栏
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread,
                () -> System.out.println("通过门栏执行此动作"));
        // 线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalThread; i++) {
            executorService.execute(() -> {
                System.out.print("before..");
                try {
                    // 每个线程都在此处等待
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.print("after..");
            });
        }
        executorService.shutdown();
    }
}
```

```html
before..before..before..before..before..before..before..before..before..before..通过门栏执行此动作
after..after..after..after..after..after..after..after..after..after..
```

##### 2. 源码解析

CyclicBarrier 的源码实现和 CountDownLatch 很不一样，CountDownLatch **基于 AQS 的共享模式**的使用，而 CyclicBarrier **基于 Condition 来实现**的。所以 CyclicBarrier 的源码相对来说简单许多。

在 CyclicBarrier 类的内部有一个**计数器**，每个线程在到达**屏障点**的时候都会**调用 await 方法将自己阻塞**，此时计数器会**减 1**，当计数器**减为 0** 的时候所有因调用 await 方法而**被阻塞的线程将被唤醒**。这就是实现**一组线程相互等待**的原理，下面我们先看看 CyclicBarrier 有哪些成员变量。

```java
// 同步操作锁
private final ReentrantLock lock = new ReentrantLock();
// 线程拦截器
private final Condition trip = lock.newCondition();
// 每次拦截的线程数
private final int parties;
// 换代前执行的任务
private final Runnable barrierCommand;
// 表示栅栏的当前代
private Generation generation = new Generation();
// 计数器
private int count;

// 静态内部类Generation
private static class Generation {
    boolean broken = false;
}
```







#### Semaphore

Semaphore 类似于操作系统中的**信号量**，可以控制对==**互斥资源的访问线程数**==。

计数信号量用来控制**同时访问**某个特定资源的操作数量，或者同时执行某个指定操作的数量。信号量还可以用来实现某种**资源池**，或者对**容器施加边界**。**Semaphore** 管理着一组**许可（permit）**,许可的初始数量可以通过构造函数设定，操作时首先要**获取到许可**，才能进行操作，操作完成后需要**释放**许可。如果没有获取许可，则**阻塞**到有许可被释放。

如果初始化了一个许可为 1 的**Semaphore**，那么就相当于一个**不可重入**的互斥锁（**Mutex**）。

以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。

```java
public class SemaphoreExample {

    public static void main(String[] args) {
        // 访问线程数
        final int clientCount = 3;
        // 总请求数
        final int totalRequestCount = 10;
        // 构造信号量
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalRequestCount; i++) {
            executorService.execute(()->{
                try {
                    // 获取信号量
                    semaphore.acquire();
                    // 显示还可以用的信号量个数
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 释放信号量
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
```

```html
2 1 2 2 2 2 2 1 2 2
```





#### FutureTask

在介绍 Callable 时我们知道它可以有**返回值**，**返回值**通过 **Future\<V>** 进行封装。FutureTask 实现了 **RunnableFuture** 接口，该接口继承自 **Runnable** 和 **Future\<V>** 接口，这使得 **FutureTask 既可以当做一个任务执行，也可以有返回值。**

```java
public interface RunnableFuture<V> extends Runnable, Future<V>
```

```java
public class FutureTask<V> implements RunnableFuture<V>
```

FutureTask 可用于**==异步==获取执行结果或取消执行任务**的场景。当一个计算任务需要执行**很长时间**，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后**再去获取结果**。

```java
public class FutureTaskExample {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 封装任务
        FutureTask<Integer> futureTask = new FutureTask<Integer>(new Callable<Integer>() 			{
            @Override
            public Integer call() throws Exception {
                int result = 0;
                // 此处故意计算很久
                for (int i = 0; i < 100; i++) {
                    Thread.sleep(100);
                    result += i;
                }
                // 返回Integer类型结果
                return result;
            }
        });
        // 线程传入futureTask
        Thread computeThread = new Thread(futureTask);
        computeThread.start();

        Thread fastThread = new Thread(() -> {
            System.out.println("FastThread时间:" + System.currentTimeMillis());
            System.out.println("other task is running...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        fastThread.start();
        // 获取futureTask的执行结果
        System.out.println("阻塞等待结果");
        System.out.println(futureTask.get());
        System.out.println("FutureTask计算完成时间:" + System.currentTimeMillis());
    }
}
```

```java
阻塞等待结果
// 接下来FastThread输出
FastThread时间:1582793216419	
other task is running...
// 等待十秒之后FutureTask计算完成输出 主线程停止阻塞    
4950
FutureTask计算完成时间:1582793226518
```





#### ForkJoin

主要用于**并行计算**中，和 **MapReduce** 原理类似，都是把大的计算任务**拆分**成多个**小任务**并行计算。

```java
public class ForkJoinExample extends RecursiveTask<Integer> {

    private final int threshold = 5;
    private int first;
    private int last;

    public ForkJoinExample(int first, int last) {
        this.first = first;
        this.last = last;
    }

    @Override
    protected Integer compute() {
        int result = 0;
        if (last - first <= threshold) {
            // 任务足够小则直接计算
            for (int i = first; i <= last; i++) {
                result += i;
            }
        } else {
            // 拆分成小任务
            int middle = first + (last - first) / 2;
            ForkJoinExample leftTask = new ForkJoinExample(first, middle);
            ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last);
            leftTask.fork();
            rightTask.fork();
            result = leftTask.join() + rightTask.join();
        }
        return result;
    }
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ForkJoinExample example = new ForkJoinExample(1, 10000);
    ForkJoinPool forkJoinPool = new ForkJoinPool();
    // 异步结果
    Future result = forkJoinPool.submit(example);
    System.out.println(result.get());
}
```

ForkJoin 使用 **ForkJoinPool** 来启动，它是一个特殊的线程池，线程数量取决于 **CPU 核数**。

```java
public class ForkJoinPool extends AbstractExecutorService
```

ForkJoinPool 实现了**工作窃取算法**来提高 CPU 的利用率。每个线程都维护了一个**双端队列**，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中**窃取一个任务**来执行。窃取的任务必须是**最晚的**任务，**避免和队列所属线程发生竞争**。例如下图中，Thread2 从 Thread1 的队列中拿出 futureTask的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中**只有一个任务**时还是会发生竞争。

![1582793895071](assets/G-5%20%E5%8D%8F%E4%BD%9C%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/1582793895071.png)







#### 参考资料

- CyclicBarrier源码详解：https://blog.csdn.net/qq_39241239/article/details/87030142