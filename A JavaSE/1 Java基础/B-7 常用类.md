[TOC]

### 常用类

#### 包装类

**基本类型都有对应的包装类型**，基本类型与其对应的包装类型之间的赋值使用**自动装箱与拆箱**完成。

##### 1. 自动装箱/拆箱

- 对象包器类为 **==final==不可变**，一旦构造就不能改变其包含的值。其内部基本数值类型是**私有**的，且声明为 final。
- 自动装箱过程是**编译器**自动在代码中插入**对象装箱代码**。拆箱也是如此。
- 每种包装类都有一个静态方法 **valueOf**(), 接收基本类型，返回引用类型，也有一个实例方法 **xxxValue**()，返回对应的基本类型。
- 6 种数值型的包装类有一个共同的父类 **Number** 类。

```java
byte    ---	 Byte
short   ---  Short
int	    ---  Integer
long    ---  Long
float   ---  Float
double  ---  Double
char    ---  Character
boolean ---  Boolean
```

```java
// <>中不能写基本类型，需要写其对应的包装器类
ArrayList<Integer> list = new ArrayList<>();    
list.add(3);    
list.add(Integer.valueOf(3));   // 与上句等价，自动装箱
int n = list.get(i);    
int n = list.get(i).intValue(); // 与上句等价，自动拆箱
```

##### 2. Integer类API

###### ① 基本API

```java
int intValue();     // 以int形式返回Integer对象的值
static String toString(int i);
static String toString(int i, int radix);   // 以一个新String对象的形式返回给定数值i的radix进制参数表示。默认10进制。
static int parseInt(String s);
static int parseInt(String s, int radix);   // 解析字符串参数对应的整数，第二个参数为进制
```

###### ② 二进制算法

Integer 类有一些二进制操作，包括**位翻转**与**循环移位**等。

**位翻转**

Integer 的静态方法，可以进行位翻转。

```java
public static int reverse(int i);
public static int reverseBytes(int i);
```

位翻转就是将 int 当做二进制，左边的位与右边的位进行互换，reverse 是按照位进行互换，reverseBytes 是按 byte 进行互换。高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着4 位一组交换、然后 8 位一组、16位一组交换之后就完成了。

##### 3. 缓存池

**new Integer(123)** 与 **Integer.valueOf(123)** 的区别在于：

- new Integer(123) 每次都会**==新建==一个对象**（用了 new 关键字）。
- Integer.valueOf(123) 会使用**缓存池中的对象**，多次调用会取得**同一个对象**的引用。

```java
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
Integer c = 12;
Integer d = 12;
System.out.println(c == d);   // true
```

**valueOf() 方法**的实现比较简单，就是先判断值是否在**缓存池**中，如果在的话就直接返回缓存池的内容。Integer 是不可变的，所以缓存的对象可以安全的被共享。是一种==**享元模式**==的思想。

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

在 Java 8 中，Integer 缓存池的大小==默认为 **-128\~127**==。

```java
static final int low = -128;    // 默认最小值
static final int high = 127;    // 默认最大值
static final Integer cache[];
// 静态初始化块
static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;
	// 初始化的时候就把值放入缓冲池中
    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

编译器会在**自动装箱**过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用**相同的对象**。下面 m, n 引用的是缓存中的**相同的对象**，因此可以**直接用 == 比较**。但是在 -128~127 区间外的不在缓存区内，**不能**直接用 == 判断比较，得用 equals() 方法。

```java
Integer m = 123;  // 123在缓存池中
Integer n = 123;
System.out.println(m == n); // true 
// 500不在缓存池中
Integer a = Integer.valueOf(500);
Integer b = Integer.valueOf(500);
System.out.println(a == b); 	// false
System.out.println(a.equals(b));// true
```

其他基本类型对应的**缓存池**范围如下：

- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F

在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。但是==只有Integer类可以**修改**默认的缓存范围==。在VM options加入参数：==-XX:AutoBoxChacheMax=7777==.就可以将最大缓存值设置为 7777.在此范围内的都可以用 == 进行是否相等判断。



#### String类

##### 1. 概述

String类对象为**==不可变==**字符串。**优点**：编译器可以让字符串**共享**。(可以想象各种字符串存放在公共的**存储池**中，字符串变量指向存储池中的位置)。

使用 equals() 方法来检验两个字符串是否**相等**。比较的是内容。一定不要用 “==” 比较字符串，此比较的是对象，完全可能有两个字符串对象的内容一样但是地址不同。

虚拟机中实际上只有**字符串常量**是共享的(**final** 修饰)，而 + 或 substring 等操作产生的结果**通常并不是**共享的。

"" 是空串，也是一个对象，有自己的长度 (0) 和内容(空)。

String 被声明为==final==，因此它**不可被继承**。

##### 2. String类重要API

String 类的 API 很重要啊，在笔试的时候经常操作字符串，会这些 API 可能会少很多工作。

- 构造方法

```java
String()  				// 初始化一个新创建的 String 对象，使其表示一个空字符序列
String(byte[] bytes) 	 // 通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String
String(byte[] bytes, String charsetName) // 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String
String(char[] value) 	 // 使用字符数组(char[])创建String对分配一个新的String 
String(StringBuffer buffer) 	// 分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列
String(StringBuilder builder) 	// 分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列
```

- 长度相关

```java
boolean isEmpty() // 当且仅当 length() 为 0 时返回 true
int length()      // 返回此字符串的长度
```

- 判断该字符串中是否包含指定的字符串序列

```java
boolean contains(CharSequence s) 	// 当且仅当此字符串包含指定的char值序列时，返回 true
```

- 返回指定索引处的字符值

```java
char charAt(int index) 	// 返回指定索引处的 char 值
```

- 字符串连接

```java
String concat(String str)  	// 将指定字符串连接到此字符串的结尾
```

- **从前向后**扫描，返回字符或者字符串参数在该字符串中**第一次出现**的索引

```java
int indexOf(int ch) 		// 返回指定字符在此字符串中第一次出现处的索引
int indexOf(String str)   	// 返回指定子字符串在此字符串中第一次出现处的索引
int indexOf(int ch, int fromIndex) 	// 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索
int indexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
```

- **从后向前**扫描，返回字符或字符串参数在该字符串中**第一次**出现的索引

```java
int lastIndexOf(int ch) 		// 返回指定字符在此字符串中最后一次出现处的索引
int lastIndexOf(String str)  	// 返回指定子字符串在此字符串中最右边出现处的索引 
int lastIndexOf(int ch, int fromIndex) 	// 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索
int lastIndexOf(String str, int fromIndex) // 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索
```

- 获取该字符串的一部分子字符串

```java
String substring(int beginIndex) 			// 返回一个新的字符串，它是此字符串的一个子字符串
String substring(int beginIndex, int endIndex) // 返回一个新字符串，它是此字符串的一个子字符串
// 这个方法经常与上面两个方法String.lastIndexOf()和String.indexOf()方法一起使用，使用这两个方法查找分割的位置，然后再使用String.subString()方法进行分割
```

- 重写Object的方法：

```java
boolean equals(Object anObject) // 将此字符串与指定的对象比较
int hashCode()                  // 返回此字符串的哈希码
String toString()               // 返回此对象本身（它已经是一个字符串）
```

- 实现 comparable 接口的比较方法：

```java
int compareTo(String anotherString)  // 按字典顺序比较两个字符串 
```

- 连接得到字符串

```java
static String join(CharSequence delimiter, CharSequence... elements)      // 在后面的每个字符串之间插入第一个字符串
String all = String.join("/", "a", "b", "c");  // all = "a/b/c";
```

- 不按大小写的比较方法

```java
int compareToIgnoreCase(String str)  // 按字典顺序比较两个字符串，不考虑大小写 
boolean equalsIgnoreCase(String anotherString) // 将此 String 与另一个 String 比较，不考虑大小写
```

- 基本类型：int, long, float, double, char, char数组，Object(对象)转换成 String 的方法:String.valueOf(xxx)

```java
static String valueOf(int i)        // 返回 int 参数的字符串表示形式
static String valueOf(long l)       // 返回 long 参数的字符串表示形式
static String valueOf(float f)      // 返回 float 参数的字符串表示形式
static String valueOf(double d)     // 返回 double 参数的字符串表示形式
static String valueOf(boolean b)    // 返回 boolean 参数的字符串表示形式
static String valueOf(char c)       // 返回 char 参数的字符串表示形式
static String valueOf(char[] data)  // 返回 char 数组参数的字符串表示形式
static String valueOf(Object obj)   // 返回 Object 参数的字符串表示形式
static String valueOf(char[] data, int offset, int count) // 返回 char 数组参数的特定子数组的字符串表示形式
```

- 把 String 字符串转换为字节数组

```java
byte[] getBytes() // 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中
byte[] getBytes(Charset charset)  	// 使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组	
byte[] getBytes(String charsetName)// 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中
```

- 对 String 中所有的字符都进行大小写转换

```java
String toLowerCase()   	// 使用默认语言环境的规则将此 String 中的所有字符都转换为小写
String toUpperCase()  		// 使用默认语言环境的规则将此 String 中的所有字符都转换为大写
String toLowerCase(Locale locale)  // 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写
String toUpperCase(Locale locale)  // 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写
```

- 判断该字出发是否匹配给定的正则表达式

```java
boolean matches(String regex)  // 告知此字符串是否匹配给定的正则表达式
```

- 使用正则表达式分割该字符串为字符串数组

```java
String[] split(String regex)   // 根据给定正则表达式的匹配拆分此字符串
String[] split(String regex, int limit)  // 根据匹配给定的正则表达式来拆分此字符串 
 // 注意，获取的数组中不包含作为分割符的字符(或字符串)
```

- 判断字符串的前缀后缀（注意加了 s）

```java
boolean startsWith(String prefix)  // 测试此字符串是否以指定的前缀开始
boolean startsWith(String prefix, int toffset) // 测试此字符串从指定索引开始的子字符串是否以指定前缀开
boolean endsWith(String suffix)    // 测试此字符串是否以指定的后缀结束
```

- 该字符串与指定的字符序列或者 StringBuffer 比较

```java
boolean contentEquals(CharSequence cs) // 将此字符串与指定的 CharSequence 比较
boolean contentEquals(StringBuffer sb) // 将此字符串与指定的 StringBuffer 比较 
```

- **把字符数组转换成 String**

```java
static String copyValueOf(char[] data) // 返回指定数组中表示该字符序列的 String
static String copyValueOf(char[] data, int offset, int count) // 返回指定数组中表示该字符序列的 String
```

- 把该字符串中的字符拷贝到指定的字符数组中去

```java
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) // 将字符从此字符串复制到目标字符数组
```

- **把该字符串转换成字符数组**：笔试经常用！

```java
char[] toCharArray() // 将此字符串转换为一个新的字符数组
```

- 使用新字符替换字符串中的旧字符

```java
String replace(char oldChar, char newChar) // 返回一个新的字符串，用newChar替换此字符串中所有的oldChar得到
String replace(CharSequence target, CharSequence replacement) // 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串
```

- 使用新子字符串替换该字符串中匹配正则表达式的那些旧子字符串：一个全部替换，一个只替换**第一个**

```java
// 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串 
String replaceAll(String regex, String replacement) 
// 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串    
String replaceFirst(String regex, String replacement) 
```

- 把该字符串规范化表示，去掉该字符串的前后空白符：

```java
String intern()    // 返回字符串对象的规范化表示形式 放到常量池
String trim()      // 返回字符串的副本，忽略前导空白和尾部空白。中间不去
```

- 判断该字符串的子字符串是否相等：

```java
boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等
boolean regionMatches(int toffset, String other, int ooffset, int len) // 测试两个字符串区域是否相等
```

##### 3. 源码分析

以下分析基于 Java11。

###### ① 实现接口

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
}
```

- java.io.Serializable：仅用于标识**序列化**的语意。

- Comparable\<String>：这个接口只有一个 **compareTo**(T o) 接口，用于对两个实例化对象**比较大小**。

- CharSequence：这个接口是一个**只读的字符序列**。包括 length(), charAt(int index), subSequence(int start, int end) 这几个API接口，值得一提的是，StringBuffer 和 StringBuild也 是实现了这个接口。

###### ② 主要属性

在 Java 8 中，String 内部使用 **char 数组**存储数据。char 可以存很多种不同的字符。

```java
public final class String 
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char[] value;     // 声明为final不可变
}
```

在 Java 9 **之后**，String 类的实现改用 **==byte 数组==**存储字符串，同时使用 **coder** 来标识使用了哪种**编码**。byte 存储的字符范围较小，所以额外需要 coder 标识编码。

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** 用数组存储实际的数据 */
    private final byte[] value;     

    /** 标识编码 */
    private final byte coder;
    
    // 哈希值
    private int hash;
    // 比较器
 　　public static final Comparator<String> CASE_INSENSITIVE_ORDER 
        = new CaseInsensitiveComparator();
}
```

value 数组被声明为 final，这意味着 value 数组初始化之后就**不能再引用其它数组**。并且 String 内部没有改变 value 数组的方法，因此可以保证 String **不可变**。

而 **hash** 是 String 实例化的 hashcode 的一个**缓存**，这样就不用每次比较都去计算哈希值了。

这个 **CASE_INSENSITIVE_ORDER** 就是持有一个静态内部类，用于**忽略大小写得比较两个字符串**。在 String 中已经有了一个 compareTo 的方法，为什么还要有一个 CaseInsensitiveComparator 的内部静态类呢？其实这一切都是为了**代码复用**。

###### ③ 主要方法

String 支持多种初始化方法，包括接收 String，char[], byte[], StringBuffer 等多种参数类型的初始化方法。但本质上，其实就是将接收到的**参数传递给全局变量 value[]**。

String 类提供了很多看似修改的方法，实际上都是通过**创建新的String 对象**来实现的。

以下是 String **构造函数**的源码，可以看到，在将一个**字符串对象**作为另一个字符串对象的构造函数参数时，并**不会完全复制** value 数组内容，而是都会**指向同一个 value 数组**。

```java
public String() {
    this.value = "".value;
    this.coder = "".coder;
}

public String(String original) {
    this.value = original.value;    // value是String类中内部存放数据的final数组
    this.hash = original.hash;
}
```

几个基本方法

```java
public int length() {
    return value.length;
}

public boolean isEmpty() {
    return value.length == 0;
}

public char charAt(int index) {
    if ((index < 0) || (index >= value.length)) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return value[index];
}
```

String 其实内部是通过 char[] 实现的，那么就不难发现 length()，isEmpty()，charAt() 这些方法其实就是在内部**调用数组**的方法。

再看看计算哈希值和判等方法。

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        hash = h = isLatin1() ? StringLatin1.hashCode(value)
            : StringUTF16.hashCode(value);
    }
    return h;
}
```

```java
private boolean isLatin1() {
    return COMPACT_STRINGS && coder == LATIN1;
}
```

即首先判断编码 coder 是否是 LATIN，然后根据结果选择用 StringLatin1 或者 StringUTF16 的 hashCode 方法。

StringLatin1.hashCode() 如下。

```java
public static int hashCode(byte[] value) {
    int h = 0;
    for (byte v : value) {
        h = 31 * h + (v & 0xff);
    }
    return h;
}
```

StringUTF16.hashCode(value) 如下。

```java
public static int hashCode(byte[] value) {
    int h = 0;
    int length = value.length >> 1;
    for (int i = 0; i < length; i++) {
        h = 31 * h + getChar(value, i);
    }
    return h;
}
```

再来看看 equals 方法。

```java
public boolean equals(Object anObject) {
    // 如果地址相同直接返回true
    if (this == anObject) {
        return true;
    }
    // 首先判断是否是String的类型
    if (anObject instanceof String) {
        // 获取这个对象的String
        String aString = (String)anObject;
        if (coder() == aString.coder()) {
            return isLatin1() ? StringLatin1.equals(value, aString.value)
                : StringUTF16.equals(value, aString.value);
        }
    }
    return false;
}
```

可以看到也是判断 coder 类型然后选择不同的 equals 方法进行判断。选其中一个看吧。

**StringLatin1.equals**(value, aString.value) 如下：

```java
public static boolean equals(byte[] value, byte[] other) {
    // 首先判断长度
    if (value.length == other.length) {
        // 如果两个长度相同每次取相同索引位置的地方的元素进行比较
        for (int i = 0; i < value.length; i++) {
            if (value[i] != other[i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
```

##### 4. 不可变的好处

**① 可以缓存 hash 值** 

因为 String 的 hash 值经常被使用，例如 String 用做 **HashMap 的 key**。不可变的特性可以使得 **hash 值也不可变**，因此只需要进行**一次**计算，即可缓存起来下次用。

**② String Pool 的需要** 

如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。一个存放 String 的池。

**③ 安全性** 

String 经常作为参数，String不可变性可以保证**参数不可变**。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。

**④ ==线程安全==** 

String 不可变性天生具备==线程安全==，可以在多个线程中安全地使用。可共享。String类是 **immutable** 类，可以安全的在多线程中共享。

##### 5. String Pool

字符串常量池（String Pool）保存着所有**字符串字面量**（literal strings），这些字面量在**编译时期**就确定。不仅如此，还可以使用 **String 的 ==intern()==** 方法在运行过程中**将字符串添加到 String Pool** 中。

在 Java 中有两种创建**字符串对象**的方式：1）采用**字面值**的方式赋值  2）采用 **new** 关键字新建一个**字符串对象**。这两种方式在性能和内存占用方面存在着差别。

```java
String str1 = new String(“aaa”);
String str2 = “aaa”;
```

虽然两个语句都是返回一个 String 对象的引用，但是 JVM 对这两种创建的方式是不一样的。看下面的**代码和图**进行理解！

```java
String s1 = new String("aaa");
String s2 = new String("aaa");

System.out.println(s1 == s2);	// false

String s3 = "aaa";
String s4 = "aaa";

System.out.println(s1 == s3);	// false
System.out.println(s3 == s4);	// true

String s5 = "bbb";
String s6 = "bbb";

System.out.println(s5 == s6);	// true

s1 = s1.intern();   // 检查String Pool中没有"aaa"则添加进去
s2 = s2.intern();

System.out.println(s1 == s2);	// true
System.out.println(s1 == s3);	// true
```

对于 **new 新建对象**的方式，，如果 String Pool 中没有，JVM 会在内部维护的 **String Pool** 中存放一个”aaa”的**对象**，并且在 **heap** 中**再创建一个 String 对象**，然后将该 **heap** 中的对象的**引用返回给用户**，如下图创建 S1 时，Pool 中没有 "aaa"，所以在 Pool 中存放入 "aaa"，此时再在 Pool 外再创建一个 "aaa"，此时 S1 指向的是 Pool 外面的 "aaa"。

当执行

```java
String s2 = new String("aaa");
```

时，首先去看 Pool 中，已经有了 "aaa" ，所以 Pool 中就不管了。然后再 Pool 外再新建一个 "aaa"。S2 指向的其实是 Pool 外的另一个 "aaa" 对象。所以 S1 和 S2 其实是各自指向自己的 Pool 外的对象它们只是把 "aaa" 放入 Pool 就不用了（注意：这时候其实已经创建了 **3 个对象**）。所以有：

```java
System.out.println(s1 == s2);	// false
```

然后执行

```java
String s3 = "aaa";
String s4 = "aaa";
```

这就是第二中以字面量的方式创建字符串的方式，JVM 首先会在 **String Pool** 中查找是否存在”aaa”对象，如果已经有**则不创建**，没有的话则在 String Pool 中**创建一个对象**。即**字面量**形式创建会**==自动==地将字符串放入 String Pool 中**。

所以创建的 s3 和 s4 都是直接从 Pool **取出引用**而同时指向的 Pool 中的 "aaa"。所以有

```java
System.out.println(s1 == s3);	// false 因为不是一个对象
System.out.println(s3 == s4);	// true  因为是同一个对象
```

<img src="B-7 常用类.assets/image-20200504165902815.png" alt="image-20200504165902815" style="zoom:67%;" />

当一个字符串调用 **intern**() 方法时，如果 String Pool 中已经存在一个字符串和该字符串**值相等**（使用 equals() 方法进行确定），那么**就会返回** String Pool 中字符串的**引用**；否则，就会在 String Pool 中**添加**一个新的字符串，并返回这个新字符串的引用。

所以执行下面时

```java
s1 = s1.intern();   // 检查String Pool中没有"aaa"则添加进去
s2 = s2.intern();
```

s1 和 s2 会把 "aaa" 放入 Pool 中，但是已经有了就不放了。这时候 s1 和 s2 会修改它们的指针转而指向 Pool 中的同一个 "aaa" 对象，所以这时候有 s1 和 s2 和 s3 都指向了 Pool 中的同一个对象。

```java
System.out.println(s1 == s2);	// true
System.out.println(s1 == s3);	// true
```

在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到**==堆==**中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。

**String Pool 总结：**

  1、单独使用 "" 引号创建的字面量字符串都是**常量**，**编译期**就已经确定存储到 String Pool 中。使用只包含常量的字符串连接符如 "aa"+ "bb" 创建的也是常量，**编译期**就能确定已经存储到 String Pool 中。

  2、使用 **new String("")** 创建的对象会存储到 heap 中，是**运行期**新创建的。

  3、使用包含变量的字符串连接如 "aa" + s 创建的对象是**运行期**才创建的，存储到 heap 中。

  5、运行期调用 String 的i ntern() 方法可以向 String Pool 中动态添加对象。

##### 6. 详解new String("aaa")

使用这种方式一共会创建**两个字符串对象**（前提是 String Pool 中还没有 "aaa" 字符串对象）。

- "aaa" 属于字符串**字面量**，因此编译时期会在 **String Pool** 中创建一个字符串对象，指向这个 "abc" 字符串字面量；
- 而使用 new 的方式会在**堆中**创建一个字符串对象。

创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。

```java
public class NewStringTest {
    public static void main(String[] args) {
        String s = new String("aaa");
    }
}
```

使用 javap -verbose 进行**反编译**，得到以下内容：

```java
// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String."<init>":(Ljava/lang/String;)V
         9: astore_1
// ...
```

在 Constant Pool 中，#19 存储这字符串**字面量** "abc"，#3 是 **String Pool** 的字符串**对象**，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在**堆**中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。

考题拓展：

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
```

其实会创建 **3 个**对象。第一句在 **Pool 中和堆中**各创建一个对象，第二句由于 Pool 已经有了 "aaa" 所以**不再创建**，仅在堆中创建，所以一共创建了 3 个对象。



##### 7. StringBuilder/StringBuffer类

当**对字符串进行修改**的时候，需要使用 StringBuffer 和 StringBuilder 类。

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且**不产生新的未使用对象**。

`String` 类中使用 **final** 关键字修饰**字符数组**来保存字符串，`private final char value[]`，所以` String` 对象是**不可变**的。

> 补充：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 `private final byte[] value`;

而 `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是**没有用 `final` 关键字修饰**，所以这两种对象**都是可变**的。

`StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是`AbstractStringBuilder` 实现的。

字符串**修改较为频繁**时使用，StringBuilder 与 StringBuffer 实现**几乎相同**，只是**StringBuilder** 线程**不安全**（不能同步访问）， **StringBuffer** **线程安全**。由于 StringBuilder 相较于 StringBuffer 有速度优势，**所以多数情况下建议使用 StringBuilder 类**。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

修改时**不产生新**的未使用变量。

继承体系如下图所示：

<img src="assets/B-7%20%E5%B8%B8%E7%94%A8%E7%B1%BB/1582383197264.png" alt="1582383197264" style="zoom:77%;" />

**基本原则**：如果要操作少量的数据，用 String ；单线程操作大量数据，用 StringBuilder ；多线程操作大量数据，用 StringBuffer。

StringBuilder 的 append 方法。

```java
@Override
@HotSpotIntrinsicCandidate
public StringBuilder append(String str) {
    super.append(str);
    return this;
}

public AbstractStringBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int len = str.length();
    ensureCapacityInternal(count + len);
    putStringAt(count, str);
    count += len;
    return this;
}
```

StringBuffer 的 append 方法。

```java
@Override
@HotSpotIntrinsicCandidate
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}

public AbstractStringBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int len = str.length();
    ensureCapacityInternal(count + len);
    putStringAt(count, str);
    count += len;
    return this;
}
```

可以看出两者其实最终都调用的同一个 append 方法，但是 StringBuffer 是用了 synchronized 锁住的。

---

> **String, StringBuffer, StringBuilder对比**

**1. 可变性** 

- String 不可变
- StringBuffer 和 StringBuilder 可变

**2. 线程安全** 

- String 不可变，因此是**线程安全**的
- StringBuilder 不是**线程安全**的
- StringBuffer 是线程安全的，内部使用 **synchronized** 进行同步，所以**速度慢**

---

#### Arrays类

##### 1. 概述

创建一个数字数组时，所有元素初始化为 0。boolean 数组的元素初始化为 false。对象数组的**元素**则初始化为 **null**，因此需要对每个对象进行对象引用才行，否则使用时会有 NPE 异常。

**一旦创建**数组就**不能改变其大小**，但可以改变元素。

数组拷贝：允许一个数组变量拷贝给另一个数组变量。两个变量将指向同一个数组。一个操作会==**影响**==另一个。

如果希望把一个数组的**全部值**拷贝到一个新数组里，可使用 Arrays 类的 **copyOf()** 方法。



```java
int[] a = new int[3];     // 创建新的数字数组 自动初始化为0
int[] b = {1, 2, 3, 4}    // 创建并初始化数组

a.length                  // 数组长度，不加方法的括号
    
for(int element : a){}    // 使用for each遍历可以不关注下标

String[] args   // 命令行参数
java Test -g ruler test     // args[0] = "-g"  args[1] = "ruler"  args[2] = "test"
 
Arrays.sort(b);  // 对数组b进行排序，排序结果就在b里面，会把原数组打乱
```

##### 2. Arrays类的API

有的 API 在笔试的时候非常有用！

- **排序**：使用 **Arrays.sort()** 方法对**数值型**数组排序，使用的是**快速排序**算法。也可传入比较器对象进行排序。

```java
public static void sort(int[] a);  // 对数组进行排序
```

- **二分查找**：(注意：二分法查找是针对**排序好**的数组才可以使用)。

```java
static int binarySearch(type[] a, type v);   //  在整个数组中按照二分查找法查找数据，查找成功返回下标，否则返回-1
static int binarySearch(type[] a, int start, int end, type v);  // 在整个数组中按照二分查找法从传入的开始位置和结束位置查找数据，查找成功返回下标，否则返回-1
```

- **数组转列表**

```java
String[] a = {"11", "22", "33"};		
List<String> stringList = Arrays.asList(a);	// 将字符串数组转换为列表
```

- toString 方法

```java
String static toString(type[] b);   	    // 将数组中的元素拼接成一个字符串 [1, 2, 3, 4]
String static deepToString(type[] a);   	    // 将二维数组拼接为字符串形式
int[][] magicSquare = {{1, 2}, {3, 4}, {5, 6}}; // 定义一个二维数组
String s = Arrays.deepToString(magicSquare);    // 将多维转字符串
// s = "[[1, 2], [3, 4], [5, 6]]";
```

- 复制

```java
int[] b = {1, 2, 3, 4}    // 创建并初始化数组
int[] copyb = Arrays.copyOf(b, b.length);   // 将数组b全部重新拷贝给另一个数组两者指向不同。第二个参数为长度。
type static copyOfRange(type[] a, int start, int end);  // 将源数组按照传入的开始位置和结束位置拷贝到一个新的数组中;
```

- 其他常用方法

```java
type static valueOf(type[] a, int length);  // 将数据按照传入的长度拷贝到一个新的数组中
static void fill(type[] a, type v);     	// 将数组中的所有元素值都设置为v
static boolean equals(type[] a, type[] b);  // 如果两个数组的长度和每个元素值都相等，那么返回true,否则返回false
```

#####  3. 源码解析

这里看看几个常用方法的源码。

###### ① Arrays.sort()

源码如下：

```java
public static void sort(int[] a) {
    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}
```

调用的是 DualPivotQuicksort.sort() 方法。这他娘的好复杂，以后再看吧。。

```java
static void sort(int[] a, int left, int right,
                 int[] work, int workBase, int workLen) {
    // Use Quicksort on small arrays
    if (right - left < QUICKSORT_THRESHOLD) {
        sort(a, left, right, true);
        return;
    }
    /*
     * Index run[i] is the start of i-th run
     * (ascending or descending sequence).
     */
    int[] run = new int[MAX_RUN_COUNT + 1];
    int count = 0; run[0] = left;

    // Check if the array is nearly sorted
    for (int k = left; k < right; run[count] = k) {
        // Equal items in the beginning of the sequence
        while (k < right && a[k] == a[k + 1])
            k++;
        if (k == right) break;  // Sequence finishes with equal items
        if (a[k] < a[k + 1]) { // ascending
            while (++k <= right && a[k - 1] <= a[k]);
        } else if (a[k] > a[k + 1]) { // descending
            while (++k <= right && a[k - 1] >= a[k]);
            // Transform into an ascending sequence
            for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
            }
        }

        // Merge a transformed descending sequence followed by an
        // ascending sequence
        if (run[count] > left && a[run[count]] >= a[run[count] - 1]) {
            count--;
        }

        /*
         * The array is not highly structured,
         * use Quicksort instead of merge sort.
         */
        if (++count == MAX_RUN_COUNT) {
            sort(a, left, right, true);
            return;
        }
    }

    // These invariants should hold true:
    //    run[0] = 0
    //    run[<last>] = right + 1; (terminator)

    if (count == 0) {
        // A single equal run
        return;
    } else if (count == 1 && run[count] > right) {
        // Either a single ascending or a transformed descending run.
        // Always check that a final run is a proper terminator, otherwise
        // we have an unterminated trailing run, to handle downstream.
        return;
    }
    right++;
    if (run[count] < right) {
        // Corner case: the final run is not a terminator. This may happen
        // if a final run is an equals run, or there is a single-element run
        // at the end. Fix up by adding a proper terminator at the end.
        // Note that we terminate with (right + 1), incremented earlier.
        run[++count] = right;
    }

    // Determine alternation base for merge
    byte odd = 0;
    for (int n = 1; (n <<= 1) < count; odd ^= 1);

    // Use or create temporary array b for merging
    int[] b;                 // temp array; alternates with a
    int ao, bo;              // array offsets from 'left'
    int blen = right - left; // space needed for b
    if (work == null || workLen < blen || workBase + blen > work.length) {
        work = new int[blen];
        workBase = 0;
    }
    if (odd == 0) {
        System.arraycopy(a, left, work, workBase, blen);
        b = a;
        bo = 0;
        a = work;
        ao = workBase - left;
    } else {
        b = work;
        ao = 0;
        bo = workBase - left;
    }

    // Merging
    for (int last; count > 1; count = last) {
        for (int k = (last = 0) + 2; k <= count; k += 2) {
            int hi = run[k], mi = run[k - 1];
            for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                    b[i + bo] = a[p++ + ao];
                } else {
                    b[i + bo] = a[q++ + ao];
                }
            }
            run[++last] = hi;
        }
        if ((count & 1) != 0) {
            for (int i = right, lo = run[count - 1]; --i >= lo;
                 b[i + bo] = a[i + ao]
                );
            run[++last] = right;
        }
        int[] t = a; a = b; b = t;
        int o = ao; ao = bo; bo = o;
    }
}
```

###### ② Arrays.binarySearch()

看看二分查找的算法。

```java
public static int binarySearch(int[] a, int key) {
    return binarySearch0(a, 0, a.length, key);
}
```

调用的是本类中的 binarySearch0 方法。可以学习一波。

```java
// Like public version, but without range checks.
private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) {
    // 左边索引
    int low = fromIndex;
    // 右边索引
    int high = toIndex - 1;
	// 左索引小于右索引
    while (low <= high) {
        // 求中间索引
        int mid = (low + high) >>> 1;
        // 求中间值
        int midVal = a[mid];
        // 中间值小于目标值
        if (midVal < key)
            // 左索引跑到在中间索引右边
            low = mid + 1;
        // 中间值大于目标值
        else if (midVal > key)
            // 更新右索引
            high = mid - 1;
        // 找到模板值
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}

```



#### Object类

重点啊！经常问这个问题。Object 类是**所有类**的父类。数组也继承了`Object`类。然而，接口是不继承`Object`类的。

##### 1. 概览

Object 类的 API（面试题：问**有哪些方法**？）

```java
// native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。
public final native Class<?> getClass();
// native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap
public native int hashCode();
// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等
public boolean equals(Object obj);
// naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常
protected native Object clone() throws CloneNotSupportedException
// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子;类都重写这个方法
public String toString();
// native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个
public final native void notify();
// native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程
public final native void notifyAll();
// native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间
public final native void wait(long timeout) throws InterruptedException
// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒
public final void wait(long timeout, int nanos) throws InterruptedException
// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException
// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable { }
```

**native**: Java关键字，Native Method 用以修饰**非 Java 代码实现**的方法(C || C++)， 类似 Java 调用非 Java 代码的接口。

 Java 的任何类都继承了这些函数，被 **final** 修饰的方法是不能被覆写的。例如，没有`final`修饰的`toString()`函数可以被覆盖，但是`final wait()`函数就不行。

##### 2. equals()

equals() 函数可以用来检查一个对象与调用这个 equals() 的这个对象**是否相等**。

Object 类默认的 eqauls() 函数进行比较的依据是：调用它的对象和传入的对象的引用是否相等。也就是说，**默认**的 equals() 进行的是**引用比较**。如果两个**引用是相同**的，equals() 函数返回 true；否则，返回 false。

- 对于基本类型，== 判断两个值是否**相等**，基本类型没有 equals() 方法。
- **对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。**

```java
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y));  // true 等价
System.out.println(x == y);       // false 对象相等
Integer m = 1;
Integer n = 1;
System.out.println(m == n);  	 // true 注意赋值方法，此处m n的值均从Integer的缓存池中获取
```

###### ① 等价的特性

覆写 equals() 函数的时候要遵守一些规则。

**I 自反性**：对于任意非空的引用值 x，x.equals(x) 返回值为真。

```java
x.equals(x); 	// true
```

**II 对称性**：对于任意非空的引用值 x 和 y，x.equals(y) 必须和 y.equals(x) 返回相同的结果。

```java
x.equals(y) == y.equals(x); // true
```

**III 传递性**：对于任意的非空引用值 x, y 和 z, 如果 x.equals(y) 返回真，y.equals(z) 返回真，那么 x.equals(z) 也必须返回真。

```java
if (x.equals(y) && y.equals(z))
    x.equals(z);  // true;
```

**IV 一致性**：对于任意非空的引用值 x 和 y，无论调用 x.equals(y) 多少次，都要返回相同的结果。在比较的过程中，对象中的数据不能被修改。

```java
x.equals(y) == x.equals(y); // true
```

**V 与 null 的比较**

对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false。

```java
x.equals(null); // false;
```

###### ② 覆写equals方法

写出**完美equals方法**的建议（源自 JavaCore）：

- 检测 this 与 otherObject 是否**引用同一对象**。
- 检测 otherObject **是否为 null**。
- 比较 this 与 otherObject 是否属于**同一个类**。
- 将 otherObject **类型转换**为相应的类类型变量。
- 现在开始对**所有需要比较的域进行比较**。使用 **==** 比较**基本类型域**，使用 **equals 比较对象域**。

```java
// 以下是Employee类的equals方法
public boolean equals(Object otherObject){
     // 检测this与otherObject是否引用同一对象
    if(this == otherObject) return true;   
    // 检测otherObject是否为null
    if(otherObject == null) return false;   
    // 比较this与otherObject是否属于同一种类型
    if(getClass() != otherObject.geClass()) return false;
    // 将otherObject转换为相应的类类型变量：类型转换
    Employee other = (Employee) otherObject;    
    // 现在开始对所有需要比较的域进行比较。使用 == 比较基本类型域，使用equals比较对象域。
    return Object.equals(name, other.name) && salary == other.salary && Objects.equals(hireDay, other.hireDay);
}
```

参考一下 **String** 类的 equals 方法，简直就是套路，果然牛皮。

```java
public boolean equals(Object anObject) {
    // 如果地址相同直接返回true
    if (this == anObject) {
        return true;
    }
    // 首先判断是否是String的类型
    if (anObject instanceof String) {
        // 获取这个对象的String
        String aString = (String)anObject;
        if (coder() == aString.coder()) {
            // 下面就是对两个字符串的每一个字符进行对比（就是上述第四条）
            return isLatin1() ? StringLatin1.equals(value, aString.value)
                : StringUTF16.equals(value, aString.value);
        }
    }
    return false;
}
```

###### ③ 合理使用equals方法

Object 的 equals 方法容易**抛空指针异常**，应使用常量或确定有值的对象来调用 equals。

举个例子：

```java
// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常
String str = null;
if (str.equals("123")) {
    //...
} else {
    //..
}
```

运行上面的程序会抛出空指针异常，但是我们把第二行的条件判断语句改为下面这样的话，就不会抛出空指针异常，else 语句块得到执行。

```java
"123".equals(str);    // false 
```

不过更推荐使用 `java.util.Objects#equals`(JDK7 引入的工具类)。

```java
Objects.equals(null,"123");  // false
```

我们看一下`java.util.Objects#equals`的源码就知道原因了。

```java
public static boolean equals(Object a, Object b) {
    // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。
    return (a == b) || (a != null && a.equals(b));
}
```

##### 3. hashCode()

hashCode() 返回**散列值**，而 equals() 是用来判断两个对象是否**等价**。**等价的两个对象散列值一定相同**，但是散列值相同的两个对象不一定等价。散列值是由对象导出的一个**整形值**。

如果两个对象的 **equals 值比较相等**，那么它们的 **hashcode 值一定相等**；如果两个对象的 **equals 值比较不相等**，那么他们的 hashcode 值**可能相等**，也可能不相等。

每个对象都有一个**默认的散列码**，其值为对象的**存储地址**。如果对象不重写该方法，Object 类的 hashCode 方法就返回对象的**存储地址**。

在覆写 **equals**() 方法时应当**总是覆写** hashCode() 方法，保证**等价的两个对象散列值**也**相等**，一般两个需要**同时**覆写。

----

> **一个反例**

下面的代码中，新建了**两个等价**的对象，并将它们添加到 HashSet 中。我们希望将这两个对象**当成一样**的，只在集合中添加一个对象，但是因为 EqualExample **没有覆写** hasCode() 方法，因此这两个对象的散列值是**不同**的，最终导致集合添加了两个对象。

```java
EqualExample e1 = new EqualExample(1, 1, 1);	// 因为上述的只是覆写了equals()
EqualExample e2 = new EqualExample(1, 1, 1);    // 没有覆写 hashCode()
System.out.println(e1.equals(e2));   		    // true
HashSet<EqualExample> set = new HashSet<>();
set.add(e1);
set.add(e2);
System.out.println(set.size());   // 2
```

Hashtable 实现一个哈希表，为了成功地在哈希表中存储和检索对象，用作键的对象必须实现 **hashCode 方法和 equals 方法**。因为哈希表通过 hashCode **检索对象**。

----

所以啊，==**必须同时覆写 equals() 和 hashCode() 方法！**==如果重新定义类中的 equals 方法，就必须**重新**定义 hashCode 方法。

因为两种定义必须一致：如果 x.equals(y) 返回 **true**，那么 x.hashCode() 就必须与 y.hashCode() 具有**相同的值**。

理想的散列函数应当具有**均匀性**，即不相等的对象应当**均匀分布**到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。**R 一般取 31**，因为它是一个**奇素数**，如果是**偶数**的话，当出现**乘法溢出，信息就会丢失**，因为与 2 相乘相当于向左移一位。

一个数与 31 相乘可以转换成移位和减法：`31*x == (x<<5)-x`，编译器会自动进行这个优化。

```java
// 覆写 hashCode() 方法
@Override
public int hashCode() {
    int result = 17;
    // xyz为类的实例变量
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
```

可以使用**工具类覆写 hashCode** 方法。

```java
// 一个简单的覆写hashCode方法
@Override
public int hashCode() {
	return Objects.hash(firstName, lastName);   // 传入多个对象到hash()返回hashCode
}
```

这里借用了 **Objects** 这个工具类。

<img src="assets/B-7%20%E5%B8%B8%E7%94%A8%E7%B1%BB/1582422689095.png" alt="1582422689095" style="zoom:80%;" />



##### 4. toString()

该方法默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为 **hashCode 散列码**的无符号十六进制表示，@前面为类名。

```java
public class ToStringExample {
    private int number;
    public ToStringExample(int number) {
        this.number = number;
    }
}
```

```java
ToStringExample example = new ToStringExample(123);
System.out.println(example.toString());
```

```html
ToStringExample@4554617c    // 类名@地址值(默认的hashCode)
```

- 建议每个类都覆写 toString() 方法。方便调试。
- 静态的 Arrays.toString() 方法可以直接**打印数组**（内部已经覆写了该方法）。打印多维数组使用 Arrays.deepToString() 方法。

```java
System.out.print(System.out);
java.io.PrintStream@2f6684      // 输出类名和HashCode

int[] a = {1, 2, 3};
Arrays.toString(a);             // [1, 2, 3]    Arrays类已经覆写了toString()
```

##### 5. clone()

```java
protected native Object clone() throws CloneNotSupportedException	// 创建并返回此对象的一个副本
```

clone 方法是创建并返回一个对象**复制后**的结果。

如果一个类没有实现 Cloneable 接口（只是一个标记接口），那么对此类对象进行复制时，会出现 CloneNotSupportedException 异常。clone 是 **protected** 的方法。

clone 生成的新对象与原对象的关系，区别在于两个对象间**是否存在相同的引用或对应的内存地址是否存在共用情况**；若存在，则为“**浅复制”**，不存在否则为“深复制”，“深复制”时需要将共同关联的引用也复制完全。

详细用法见接口章节中的 Cloneable 接口。

##### 6. getClass()

```java
public final native Class<?> getClass();  // 返回此Object的运行类
```

首先，该方法由 final 声明本地方法，**不能被重写**，作用是返回**运行时类对象**，通过这个类对象可以获取该运行时类的相关属性和方法。

class 是一个类的属性，能获取该类编译时的类对象；而 getClass() 是一个类的**方法**，它是获取该类运行时的类对象。

##### 7. notify()

```java
public final native void notify();　　
```

**唤醒**可能等待**该对象**的**对象锁的其他线程**。由 JVM（与优先级无关）随机**挑选**一个**处于 wait 状态**的线程。

调用 notify()之前，线程**必须获取该对象的对象锁**，执行完 notify() 方法后，**不会马上释放锁**，直到退出 synchronized 代码块，当前线程才会释放锁；notify 一次只能随机**通知一个线程**进行唤醒。

##### 8. notifyAll()

```java
public final native void notifyAll();
```

使**所有**正在等待池中等待**同一个共享资源**的全部线程从等待状态退出，进入可运行状态，让它们**同时竞争对象锁**，只有获得锁的线程才能进入就绪状态。

##### 9. wait()

```java
public final native void wait(long timeout) throws InterruptedException  // 在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。 
public final void wait(long timeout, int nanos) throws InterruptedException
public final void wait() throws InterruptedException // 用于让当前线程失去操作权限，当前线程进入等待序列
```

wait 方法会引起**当前线程阻塞**，直到另外一个线程在**对应的对象**上调用 notify 或 notifyAll 方法，或达到了方法参数中**指定的时间**。

调用 wait 方法的当前线程一定要拥有对象的**监视器锁**。

wait 方法会把**当前线程**放在对应的**等待队列**中，在这个对象上的所有同步请求都**不会**得到响应。线程调用将不会调用线程，线程一直处于**休眠**状态。要注意的是，wait 方法把当前线程放置到**这个对象**的等待队列中，解锁也仅仅是在这个对象上；当前线程在等待过程中仍然持有其他对象的锁。

如果当前线程被其他线程在当前线程等待之前或正在等待时调用了 **interrupt**() 中断了，那么就会抛出 InterruptException异常。

---

> **为什么wait方法一般要写在while循环里？**

答：在某个线程调用 notify 到**等待线程被唤醒**的过程中，有可能出现另一个线程得到了锁并修改了条件使得条件不再满足；只有某些等待线程的条件满足了，但通知线程调用了notifyAll有可能出现“伪唤醒”。

> **wait方法和sleep方法的区别？**

**wait** 方法属于 **Object** 类，当调用 wait 方法时，线程会**放弃对象锁**，进入等待此对象的**等待锁定池**，只有**针对此对象**调用 notify 方法后本线程才会进入**对象锁定池**，准备**获取对象锁**进入运行状态。

**sleep** 方法属于 **Thread** 类，sleep 方法导致程序暂停执行指定的时间，让出 CPU 给其他线程，但是它的**监控状态依然保持**，当指定的时间到了又会恢复运行状态。在调用 sleep 方法过程中，线程**不会释放对象锁**。

---

##### 10. finalize()

该方法用于垃圾回收，一般由 JVM 自动调用，不需要程序员手动调用该方法。



#### 其他类

##### 1. BigDecimal / BigInteger 类

BigInteger 和 BigDecimal 类可以处理**任意长度**数字序列的数值，用于**精确计算**。

BigInteger不是基本数据类型之一，是一个类，然而它的初始化方式却没有 String 那么方便可以直接赋值，而是需要调用它的**构造器**进行初始化。

BigInger(String val) 这个构造器，可以直接将十进制的**字符串**格式变成大整数。

既然不是基本数据类型，所以大数的加减乘除也**不能**使用 +、-、*、/ 这些运算符号，Java也没有对这些运算符号进行重定义，取而代之的是用一些方法来代替，比如 add()、subtract()、mutiply()、divide() 这四种方法。

```Java
BigInteger a = BigInteger.valueOf(100);
// API BigInteger和BigDecimal 的方法类似
BigInteger abs()                    // 返回大整数的绝对值
BigInteger add(BigInteger val)      // 返回两个大整数的和
BigInteger divide(BigInteger val)   // 返回两个大整数的商
float floatValue()                  // 返回大整数的float类型的值
int intValue()                      // 返回大整数的整型值
long longValue()                    // 返回大整数的long型值
BigInteger max(BigInteger val)      // 返回两个大整数的最大者
BigInteger min(BigInteger val)      // 返回两个大整数的最小者
BigInteger mod(BigInteger val)      // 用当前大整数对val求模
BigInteger multiply(BigInteger val) // 返回两个大整数的积
BigInteger pow(int exponent) 返回当前大整数的exponent次方
BigInteger remainder(BigInteger val) 返回当前大整数除以val的余数
BigInteger subtract(BigInteger val)返回两个大整数相减的结果
String toString() 将当前大整数转换成十进制的字符串形式
```

##### 2. Random 类

###### ① Random 类概述

Random 类位于 java.util 包中，主要用于生成**伪随机数**。Random 类将 种子数 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关。创建 Random 实例时，若没有指定种子数，则会以**当前时间**作为种子数，来计算生成伪随机数。拥有相同种子的 Random 实例，在相同次数下，生成的伪随机数完全相同。

```java
Random random1 = new Random(10);
Random random2 = new Random(10);
System.out.println(random1.nextInt()); // -1157793070
System.out.println(random2.nextInt()); // -1157793070
```

Random 类是**线程安全**的，多个线程可以同时使用一个 Random 实例对象，不过如果并发性很高，会产生**竞争**，这是可以考虑使用多线程库中的 ==**ThreadLocalRandom**==类。

###### ② Random 类的常用方法

**random.nextBoolean()**：用于从该随机数生成器的序列中得到下一个伪均匀分布的 boolean 值

```java
Random random = new Random();
System.out.println(random.nextBoolean()); // true
```

**random.nextBytes()**：用于生成随机 byte 值并将其放入用户提供的 byte 数组中，生成的随机 byte 数等于 byte 数组的长度。

```java
Random random = new Random();
byte[] data = new byte[5];
random.nextBytes(data);
System.out.println(Arrays.toString(data)); // [29, 73, -58, -60, -101]
```

**random.nextInt()**：用于从该随机数生成器的序列中得到下一个伪均匀分布的 int 值

```java
Random random = new Random();
System.out.println(random.nextInt()); // 1414623307
```

**random.nextInt(int bound)**：用于从该随机数生成器的序列中得到下一个 0 到结束值之间伪均匀分布的 int 值，**[0, 结束值)**

```java
Random random = new Random();
System.out.println(random.nextInt(10)); // 5
```





#### 参考资料

- [Java枚举原理](https://blog.csdn.net/Creepin_/article/details/105246043)

- [Java之Object类](https://www.cnblogs.com/HuiH/p/11677018.html)













