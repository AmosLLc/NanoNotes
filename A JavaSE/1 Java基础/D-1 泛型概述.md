[TOC]

### 泛型概述

#### 0 本节重点

- 泛型可有泛型类、泛型方法、泛型接口。
- 泛型方法的返回类型之前是==**类型参数**==，可以对类型参数进行**限定**。如 **\<T extends Comparable>**



#### 1 泛型概述

- 使用泛型可以让编译器对**类型进行检查**，避免插入错误类型的对象。它提供了**编译期的类型安全**，确保你只能把正确类型的对象放入集合中，避免了在运行时出现 ClassCastException。
- 泛型的好处：安全性、可读性。安全性是指编译器会帮检测类型错误，使类型安全。



#### 2 泛型基本用法

##### ①. 泛型类

- 一个泛型类就是具有一个或多个**类型变量**的类。

```java
// 一个简单的泛型类
public class Pair<T> {
   private T first;
   private T second;

   public Pair() { first = null; second = null; }
   public Pair(T first, T second) { 
        this.first = first;  this.second = second; 
   }

   public T getFirst() { return first; }
   public T getSecond() { return second; }

   public void setFirst(T newValue) { first = newValue; }
   public void setSecond(T newValue) { second = newValue; }
}

// 两个类型变量的泛型类
public class Pair<T, U>{...}
```

用**具体的类型替换类型变量**就可以**实例化**泛型类型。

```java
public class PairTest1 {        // 测试类
   public static void main(String[] args)   {
      String[] words = { "Mary", "had", "a", "little", "lamb" };
      Pair<String> mm = ArrayAlg.minmax(words);
      System.out.println("min = " + mm.getFirst());
      System.out.println("max = " + mm.getSecond());
   }
}

class ArrayAlg{
   /**
    * Gets the minimum and maximum of an array of strings.
    * @param a an array of strings
    * @return a pair with the min and max value, or null if a is null or empty
    */
   public static Pair<String> minmax(String[] a) {
      if (a == null || a.length == 0) return null;
      String min = a[0];
      String max = a[0];
      for (int i = 1; i < a.length; i++)      {
         if (min.compareTo(a[i]) > 0) min = a[i];
         if (max.compareTo(a[i]) < 0) max = a[i];
      }
      return new Pair<>(min, max);
   }
}

```



##### ②. 泛型方法

- 一个方法是不是泛型的，与其所在的类是不是泛型的**没有**关系。

- 可以定义带有==**类型参数**==的方法。调用泛型方法时，在**方法名前的尖括号**中放人具体的类型。
- **\<T>**是**类型参数**，**T 是返回类型**，类型参数放在**返回值之前**。**\<T extends Comparable>** 也是类型参数，限定传入的类型。
- 与泛型类不同，调用方法时一般不需要特意指定类型参数的实际类型， 一般 Java 编译器可以自动推断出来。

```java
// 不是泛型类
class ArrayAlg{
    // <T>是类型参数，T 是返回类型，参数为类型T的不定数目参数
    public static <T> T getMiddle(T... a){
        return a[a.length / 2];
    }
    
    public static <T extends Comparable> T min(T[] a){...}
    
    public static <T> int indexOf(T[] arr, T elm) {
        for(int i = 0; i < arr.length; i++) {
            if(arr[i].equals(elm)) {
                return i;
            }
        }
        return -1;
    }
}

// 调用泛型方法 注意下面的写法
String middle = ArrayAlg.<String>getMiddle("]ohnM", "Test", "Public");
String middle = ArrayAlg.getMiddle("]ohnM", "Test", "Public");   // 省略类型参数
                                   
indexOf(new Integer[]{1, 3, 5, 6, 8}, 10);
```

- 泛型方法可以定义在**普通类**中，也可以定义在泛型类中。

```java
public class Box<T> {
    // T stands for "Type"
    private T t;
    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

##### ③. 泛型接口

接口也可以是泛型的，如下。使用时需要指定具体的类型。

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

```java
public class Book implements Comparable<Integer> {
    public int compareTo(Integer bookPage) {
        return compare(this.bookpage, anotherBook.bookPage);
    }
}
```





#### 3 类型参数的限定

- 对类型进行限定 

```java
// 限定min方法只能被实现了Comparab1e接口的类调用
public static <T extends Comparable> T min(T[] a){...}
```

- 如果有多个类型变量和多个限定类型，限定类型用 **& 分隔**，类型变量用**逗号分隔**。
- 如果用一个类作为限定，它必须是限定列表中的第一个。

```java
// 多个限定类型，且Students类为第一个
public static <T extends Students & Comparab1e & Serializable> Pair<T> min(T[] a){...}
```

- **上界**可以是一个具体的**类**，也可以是一个**接口**，此时 T 必须**实现**这个接口。

```java
/**
* 泛型方法 <T extends Comparable> 为类型限定参数  Pair<T> 为返回类型  T[]为入参
*/
public static <T extends Comparable> Pair<T> minmax(T[] a) {
      if (a == null || a.length == 0) return null;
      T min = a[0];
      T max = a[0];
      for (int i = 1; i < a.length; i++) {
         if (min.compareTo(a[i]) > 0) min = a[i];
         if (max.compareTo(a[i]) < 0) max = a[i];
      }
      return new Pair<>(min, max);
   }
```















