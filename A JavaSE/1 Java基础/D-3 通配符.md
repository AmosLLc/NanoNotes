[TOC]

### 通配符

#### 1 概述

**为什么要用通配符？**

在 java 中，**数组**是可以**协变**的，比如 dog extends Animal，那么 Animal[] 与 dog[] 是兼容的。而**集合是不能协变**的，也就是说 List\<Animal> 不是 List\<dog> 的父类，这时候就可以用到**通配符**了。

使用通配符对参数类型进行**限定**。



#### **2 通配符分类**

通配符是较难理解的一部分. 主要有以下三类:

- 无边界的通配符(Unbounded Wildcards), 就是==**\<?>**==, 比如 **List<?>**：
    无边界的通配符的主要作用就是让**泛型能够接受==未知类型==**的数据。
    
- 固定上边界的通配符(Upper Bounded Wildcards)：
    
    使用**固定上边界**的通配符的泛型, 就能够接受**指定类及其子类**类型的数据. 要声明使用该类通配符, 采用 
    
    ==**<? extends E> **== 的形式, 这里的 **E** 就是该泛型的**上边界**. 注意: 这里虽然用的是 extends 关键字, 却不仅限于继承了父类 E 的子类, 也可以代指实现了**接口** E 的类. 
    
- 固定下边界的通配符(Lower Bounded Wildcards)：
    使用固定**下边界**的通配符的泛型, 就能够接受指定**类及其父类类型**的数据. 要声明使用该类通配符, 采用   
    
    ==**<? super E>**== 的形式, 这里的 **E** 就是该泛型的**下边界**。注意: 你可以为一个泛型指定上边界或下边界, 但是**不能同时**指定上下边界。



#### **3 基本使用方法**

##### **1. 无边界的通配符的使用**

我们以在集合 List 中使用 <?> 为例。

```java
public static void printList(List<?> list) {
    for (Object o : list) {
        System.out.println(o);
    }
}

public static void main(String[] args) {
    List<String> l1 = new ArrayList<>();
    l1.add("aa");
    l1.add("bb");
    l1.add("cc");
    printList(l1);
    List<Integer> l2 = new ArrayList<>();
    l2.add(11);
    l2.add(22);
    l2.add(33);
    printList(l2);
}
```

这种使用 **List<?>** 的方式就是父类引用指向子类对象. 注意, 这里的 printList 方法不能写成 public static void printList(List\<Object> list)的形式, 虽然 Object 类是所有类的父类, 但是 List\<Object> 跟其他泛型的 List 如 List\<String> ,  List\<Integer> 不存在继承关系, 因此会报错.

有一点我们必须明确, **我们不能对 List<?> 使用 add 方法, 仅有一个例外, 就是 add(null)**. 为什么呢? 因为我们**不确定**该 List 的类型, 不知道 add 什么类型的数据才对, 只有 null 是所有引用数据类型都具有的元素。即只能读不能写，**问号  ？ 就是表示类型安全无知**。

请看下面代码:

```java
public static void addTest(List<?> list) {
    Object o = new Object();
    // list.add(o); // 编译报错
    // list.add(1); // 编译报错
    // list.add("ABC"); // 编译报错
    list.add(null);
}
```

由于我们根本不知道 list 会接受到具有什么样的泛型 List, 所以除了 null 之外什么也不能 add。
还有, **List<?> 也不能使用 get 方法, 只有 Object 类型是个例外**. 原因也很简单, 因为我们不知道传入的 List 是什么泛型的, 所以无法接受得到的 get, 但是 **Object** 是所有数据类型的父类, 所以只有接受他可以, 请看下面代码:

```java
public static void getTest(List<?> list) {
    // String s = list.get(0);  // 编译报错
    // Integer i = list.get(1); // 编译报错
    Object o = list.get(2);
}
```

不是有强制类型转换么? 是有, 但是我们不知道会传入什么类型, 比如我们将其强转为 String, 编译是通过了, 但是如果传入个 Integer 泛型的 List, 一运行还会出错。那么保证传入的 String 类型的数据不就好了么? 那样是没问题了, 但是那还用 <?> 干嘛呀? 直接 List\<String> 不就行了。



##### **2. 固定上边界的通配符的使用**

 仍旧以 List 为例来说明。

```java
public static double sumOfList(List<? extends Number> list) {
    double s = 0.0;
    for (Number n : list) {
        // 注意这里得到的n是其上边界类型的, 也就是Number, 需要将其转换为double.
        s += n.doubleValue();
    }
    return s;
}

public static void main(String[] args) {
    List<Integer> list1 = Arrays.asList(1, 2, 3, 4);
    System.out.println(sumOfList(list1));
    List<Double> list2 = Arrays.asList(1.1, 2.2, 3.3, 4.4);
    System.out.println(sumOfList(list2));
}
```

有一点我们需要记住的是, **List<? extends E> 不能使用 add 方法**, 请看如下代码:

```java
public static void addTest2(List<? extends Number> l) {
    // l.add(1);   // 编译报错
    // l.add(1.1); //编译报错
    l.add(null);
}
```

原因很简单, 泛型 **<? extends E>** 指的是 E 及其子类, 这里传入的可能是 Integer, 也可能是 Double, 我们在写这个方法时**不能确定传入的什么类型的数据**, 如果我们调用:

```java
List<Integer> list = new ArrayList<>();
addTest(list);
```

那么我们之前写的 add(1.1) 就会出错, 反之亦然, 所以**除了 null 之外什么也不能 add**. ==但是 **get 的时候是可以得到一个 Number**, 也就是**上边界类型**的数据的, 因为不管存入什么数据类型都是 Number 的**子类型**==, 得到这些就是一个**父类引用指向子类**对象。有点东西，这就是上边界的作用。



##### **3. 固定下边界通配符的使用**

这个较前面的两个有点难理解, 首先仍以 List 为例.

```java
public static void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}

public static void main(String[] args) {
    List<Object> list1 = new ArrayList<>();
    addNumbers(list1);
    System.out.println(list1);
    List<Number> list2 = new ArrayList<>();
    addNumbers(list2);
    System.out.println(list2);
    List<Double> list3 = new ArrayList<>();
    // addNumbers(list3); // 编译报错
}
```

我们看到, **List<? super E>** 是能够调用 **add 方法**的, 因为我们在 addNumbers 所 **add 的元素就是 Integer 类型的**, 而传入的 list 不管是什么, 都一定是 Integer 或其父类泛型的 List, 这时 add 一个 Integer 元素是没有任何疑问的. 但是, **我们==不能使用 get 方法==**, 除非使用 **Object** 类型来接收，请看如下代码:

```java
public static void getTest2(List<? super Integer> list) {
    // Integer i = list.get(0); // 编译报错
    Object o = list.get(1);
}
```

这个原因也是很简单的, 因为我们所传入的类都是 Integer 的类或其父类, 所传入的数据类型可能是 Integer 到Object 之间的任何类型, 这是**无法预料**的, 也就无法接收. 唯一能确定的就是 **Object**, 因为所有类型都是其**子类型**.
使用 <? super E> 还有个常见的场景就是 **Comparator**. 



