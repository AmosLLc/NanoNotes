[TOC]

### 字符操作

#### 1 概述

字节流处理文件的时候是**基于字节**的，而字符流处理文件则是基于一个个**字符**为基本单元的。

字符流操作的本质就是==「**字节流**操作」+「**编码**」==两个过程的**封装**，无论是写一个字符到文件，需要将字符**编码**成二进制，然后以字节为基本单位写入文件，或是你读一个字符到内存，你需要以字节为基本单位读出，然后**解码**成字符。



#### 2 编码与解码

**编码**就是把**字符**转换为**字节**，而**解码**是把**字节**重新组合成**字符**。

如果编码和解码过程使用不同的编码方式那么就出现了**乱码**。

- GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
- UTF-8 编码中，中文字符占 **3** 个字节，英文字符占 1 个字节；
- UTF-16be 编码中，中文字符和英文字符都占 2 个字节。

UTF-16be 中的 be 指的是 Big Endian，也就是**大端**。相应地也有 UTF-16le，le 指的是 Little Endian，也就是**小端**。

Java 的内存编码使用**双字节**编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。



#### 3 String 的编码方式

String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。

```java
String str1 = "中文";
// 指定编码方式
byte[] bytes = str1.getBytes("UTF-8");		
String str2 = new String(bytes, "UTF-8");
System.out.println(str2);
```

在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与**平台有关**，**一般为 UTF-8**。

```java
byte[] bytes = str1.getBytes();
```

Java 中的默认字符编码为：**UTF-8**，而我们知道 UTF-8 编码的字符使用 **1 到 4** 个字节进行存储，越常用的字符使用越少的字节数。

而 char 类型被定义为两个字节大小，也就是说，对于通常的字符来说，一个 char 即可存储一个字符，但对于一些增补字符集来说，往往会使用两个 char 来表示一个字符。



#### 4 基类 Reader 与 Writer

不管是磁盘还是网络传输，**最小的存储单元都是==字节==，而不是字符**。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。

Reader 作为读字符流的**基类**，它提供了最基本的字符读取操作。

先看看它的构造器：

```java
protected Object lock;

protected Reader() {
    this.lock = this;
}

protected Reader(Object lock) {
    if (lock == null) {
        throw new NullPointerException();
    }
    this.lock = lock;
}
```

Reader 是一个**抽象类**，这些构造器是给子类调用的，用于初始化 lock 锁对象，这一点后续会详细解释。

```java
public int read() throws IOException {
    char cb[] = new char[1];
    if (read(cb, 0, 1) == -1)
        return -1;
    else
        return cb[0];
}

public int read(char cbuf[]) throws IOException {
    return read(cbuf, 0, cbuf.length);
}

abstract public int read(char cbuf[], int off, int len)
```

基本的读字符操作都在这了，第一个方法用于读取一个**字符**出来，如果已经读到了文件末尾，将返回 **-1**，同样的以 ==**int**== 作为**返回值类型接收**，为什么不用 char？原因是一样的，都是由于 **-1** 这个值的**解释不确定性**。

第二个方法和第三个方法是类似的，从文件中读取指定长度的字符放置到目标数组当中。第三个方法是抽象方法，需要子类自行实现，而第二个方法却又是基于它的。

还有一些方法也是类似的：

```java
public long skip(long n);	// 跳过 n 个字符
public boolean ready();		// 下一个字符是否可读
public boolean markSupported();	// 见 reset 方法
public void mark(int readAheadLimit); 	// 见 reset 方法
public void reset();	// 用于实现重复读操作
abstract public void close();	// 关闭流
```

这些个方法其实都见名知意，并且和我们的 InputStream 大体上都差不多。

Writer 是**写的字符流**，它用于将一个或多个字符写入到文件中，当然具体的 write 方法依然是一个**抽象**的方法，待子类来实现。



#### 5 适配器 InpustStramReader/OutputStreamWriter

适配器类，能将 InputStream/OutputSteam **转换**为 Reader/Writer。

- **InputStreamReader** 实现从字节流**解码**成**字符流**；
- **OutputStreamWriter** 实现字符流**编码**成为**字节流**。

适配器字符流**继承自基类** Reader 或 Writer。主要的作用就是将一个**字节流转换成一个字符流**，我们先以读适配器为例。

首先就是它最核心的**成员**：

```java
private final StreamDecoder sd;
```

StreamDecoder 是一个**解码器**，用于将**字节的各种操作转换成字符**的相应操作。

然后就是构造器：

```java
public InputStreamReader(InputStream in) {
    super(in);
    try {
        sd = StreamDecoder.forInputStreamReader(in, this, (String)null); 
    } catch (UnsupportedEncodingException e) {
        throw new Error(e);
    }
}

public InputStreamReader(InputStream in, String charsetName) 
    throws UnsupportedEncodingException
{
    super(in);
    if (charsetName == null)
        throw new NullPointerException("charsetName");
    sd = StreamDecoder.forInputStreamReader(in, this, charsetName);
}
```

这两个构造器的目的都是为了**初始化这个解码器**，都调用的方法 forInputStreamReader，只是参数不同而已。我们不妨看看这个方法的实现：

```java
public static StreamDecoder forInputStreamReader(InputStream in, Object lock, String charsetName) throws UnsupportedEncodingException {
    String csn = charsetName;
    if (csn == null)
        csn = Charset.defaultCharset().name();
    try {
        if (Charset.isSupported(csn))
            return new StreamDecoder(in, lock, Charset.forName(csn));
    } catch (IllegalCharsetNameException x) { }
    throw new UnsupportedEncodingException (csn);
}
```

这是一个典型的==**静态工厂模式**==，参数 charsetName 其实代表的是一种**字符编码的名称**，如果为 null，那么将使用系统**默认**的字符编码：UTF-8 。工厂产生解码器实例。

最终我们能够得到一个**解码器实例**。

接着介绍的所有方法几乎都是依赖的这个**解码器**而实现的。

```java
public String getEncoding() {
    return sd.getEncoding();
}

public int read() throws IOException {
    return sd.read();
}

public int read(char cbuf[], int offset, int length){
    return sd.read(cbuf, offset, length);
}

public void close() throws IOException {
    sd.close();
}
```

解码器中相关的方法的实现代码还是相对复杂的，这里我们不做深入的研究，但大体上的实现思路就是：**「字节流读取 + 解码」**的过程。

当然了，OutputStreamWriter 中必然也存在一个**相反的 StreamEncoder 实例**用于**编码字符**。

除了这一点外，其余的操作并没有什么不同，或是通过字符数组向文件中写入，或是通过字符串向文件中写入，又或是通过 int 的低 16 位向文件中写入。



#### 6 文件字符流 FileReader/Writer

FileReader/Writer 不能指定编码类型，只能使用默认编码，如果**需要指定编码类型**需要使用I**npustStramReader/OutputStreamWriter**。

FileReader/Writer **没有缓冲**，也**不能按行读写**，一般**应该**在它们的外面**包装**上对应的==**缓冲类**==。

文件的字符流可以说非常简单，除了构造器，就不存在任何其他方法了，**完全依赖文件字节流**。

我们以 FileReader 为例，

FileReader 继承自 **InputStreamReader**，有且仅有以下三个构造器：

```java
public FileReader(String fileName) throws FileNotFoundException {
    super(new FileInputStream(fileName));
}

public FileReader(File file) throws FileNotFoundException {
    super(new FileInputStream(file));
}

public FileReader(FileDescriptor fd) {
    super(new FileInputStream(fd));
}
```

理论上来说，所有的**字符流**都应当以我们的**适配器为基类**，因为只有它提供了字符到字节之间的转换，无论你是写或是读都离不开它。

而我们的 FileReader 并没有扩展任何一个自己的方法，父类 InputStreamReader 中预实现的字符操作方法对他来说已经足够，只需要传入一个对应的字节流实例即可。

FileWriter 也是一样的，这里不再赘述了。



#### 7 字符数组流 CharArrayReader/Writer

**字符数组和字节数组流**是类似的，都是用于解决那种**不确定文件大小**，而需要读取其中**大量内容**的情况。

由于它们内部提供**动态扩容机制**，所以既可以完全容纳目标文件，也可以控制数组大小，不至于分配过大内存而浪费了大量内存空间。

先以 CharArrayReader 为例

```java
protected char buf[];

public CharArrayReader(char buf[]) {
    this.buf = buf;
    this.pos = 0;
    this.count = buf.length;
}

public CharArrayReader(char buf[], int offset, int length){
    // ....
}
```

构造器核心任务就是初始化一个字符数组到内部的 buf 属性中，以后所有对该字符数组流实例的读操作都**基于 buf** 这个字符数组。

关于 CharArrayReader 的其他方法以及 CharArrayWriter，这里不再赘述了，和上篇的字节数组流基本类似。

除此之外，这里还涉及一个 StringReader 和 StringWriter，其实本质上和字符数组流是一样的，毕竟 String 的本质就是 char 数组。



#### 8 缓冲数组流 BufferedReader/Writer

同样的，BufferedReader/Writer 作为一种**缓冲流**，也是==**装饰者流**==，用于提供**缓冲功能**。大体上类似于我们的字节缓冲流，这里简单介绍下。

```java
private Reader in;
private char cb[];
private static int defaultCharBufferSize = 8192;

public BufferedReader(Reader in, int sz){..}

public BufferedReader(Reader in) {
    this(in, defaultCharBufferSize);
}
```

cb 是一个字符数组，用于缓存从文件流中读取出来的部分字符，你可以在构造器中初始化这个数组的长度，否则将使用默认值 **8192** 。

```java
public int read() throws IOException {..}

public int read(char cbuf[], int off, int len){...}
```

关于 read，它依赖成员属性 in 的读方法，而 in 作为一个 Reader 类型，内部往往又依赖的某个 InputStream 实例的读方法。

**所以说，==几乎所有的字符流都离不开某个字节流实例。==**

关于 BufferedWriter，这里也不再赘述了，大体上都是类似的，只不过一个是读一个是写而已，都围绕着内部的字符数组进行。



##### ① 实现逐行输出文本文件的内容

```java
public static void readFileContent(String filePath) throws IOException {

    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }

    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}
```









