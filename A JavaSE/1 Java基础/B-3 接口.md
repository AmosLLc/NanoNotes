[TOC]

### 接口

#### 1 接口基础

- 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。**Java8 接口中可以有静态方法和默认方法**。静态方法必须有方法体。

- 从 Java 8 开始，接口也可以拥有**==默认==的方法实现**，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。Spring 中很多默认实现方法。必须用**default 修饰符标记**该方法。引入**默认方法主要是==函数式数据处理==**的需求，是为了**便于给接口增加新的功能**。

- 接口的成员（字段 + 方法）**默认都是 public** 的，并且不允许定义为 private 或者 protected。

- 接口不能定义实例变量。但接口中可以定义**常量**字段，这些域自动设置为**public static final**，实现接口的类继承这些常量，但是不推荐。

```java
package com.nano.javase;

/**
 * 飞行接口
 * @author nano
 */
public interface Fly {

    int x = 123;            // 默认为 public static final
    // int y;               // 必须初始化
    public int z = 0;       // 不用写public
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here

    void flyOnRiver();   // 接口方法

    // Java8之后定义默认方法
    default void flyOnSky(){
        System.out.println("在天空中飞");
    }

    // Java8之后可以在定义 接口中静态方法必须有方法体{}
    static void flyOnGround() {}
}
```

```java
package com.nano.javase;

/**
 * 鸟类
 * @author nano
 */
public class Bird extends Animal implements Fly{

    /**
     * 接口中的一般方法必须实现
     */
    @Override
    public void flyOnRiver() {
        System.out.println("鸟在河上飞");
    }

    /**
     * 接口中的默认方法可以不实现
     */
    @Override
    public void flyOnSky() {
        System.out.println("鸟在天空飞");
    }

    public static void main(String[] args) {
        // 使用接口引用实例对象 动态类型为Bird
        Fly fly = new Bird();
        fly.flyOnRiver();
        fly.flyOnSky();
        // 输出
        // 鸟在河上飞
		// 鸟在天空飞
        // 如果注释掉flyOnSky() 方法而使用接口中的默认方法 则输出如下
        // 鸟在河上飞
		// 在天空中飞  
    }
}
```

- 接口不是类，而是对类的一组需求描述。所以不能用 new 运算符实例化一个接口。但可以使用接口==引用实现了接口的类对象==。

- 使用 **instanceof** 检查一个对象是否实现了某接口。

```java
if(bird instanceof Fly){...}
```



#### 2 接口方法与类方法冲突

主要是接口与接口之间 (需要覆盖方法来解决二义性)，接口与超类之间的方法冲突(==超类优先==)。

```java
// 一个含有方法getName的接口
interface Named {
    String getName(){
        return getClass.getName();
    }
}

// 另一个含有getName方法的接口
class Person {
    public String getName(){
        return this.name;
    }
}

// 冲突1：实现了含有相同方法的两个接口
public class Student extends Person implements Named{
    public String getName(return Person.super.getName());   // 必须选择一个来解决此二义性问题
}

// 另一个类也有同样的getName方法
class Animal {
    private String name;
    public String getName(){
        return this.name;
    }
}

// 冲突2：继承的类和实现的接口都有相同的方法
class Student extends Animal implements Named{
    // 此时只会考虑超类的方法，接口的方法会被忽略，这就是“类优先”的原则
}
```





#### 3 接口默认方法

上面已经有默认方法的介绍，为什么要引入默认方法？

如果在 Fly 接口中新增 flyOnCity() 方法， Java8 之前在项目中所有实现了 Fly 接口的实现类都要实现 flyOnCity() 方法。如果项目中有 10000 个类实现了 Fly 接口， 也意味着要修改 10000 个实现类的代码。工作量巨大。

**引入默认方法，不仅给接口增加了功能，而且其他实现类不用做任何改变**。函数式编程中就体现了这个思想。





