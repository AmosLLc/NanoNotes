[TOC]



### 同步容器类

同步容器类包括 **Vector** 和 **HashTable**。

类 **Collections** 中有一些方法可以返回线程安全的**同步容器**（不是并发容器）。它是给**所有容器方法**都加上 **synchronized** 关键字实现的。这些是**线程安全**的，但是效率较低。

```java
public static <T> List<T> synchronizedList(List<T> list) {
        return (list instanceof RandomAccess ?
                new SynchronizedRandomAccessList<>(list) :
                new SynchronizedList<>(list));
}
```

但是给所有的方法加 synchronized 关键词时所有的方法必须使用**相同的锁**，不然可能造成伪同步的问题。在并发编程当中，虽然同步容器类是**线程安全**的，但是在某些情况下可能需要**额外的客户端加锁**来保护**复合操作**。

如下面一段代码：

```java
public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}

public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

上述两个方法中，虽然 Vector 是线程安全的，但是获取 Vector 大小与获取/删除之间没有锁保护，当获得 Vector 大小之后，如另外一个线程删除了 Vector 中的最末尾位置的元素，则每个函数的最后一句代码执行将报错。因此，对于复合操作，需要在符合操作上用锁来保证操作的原子性：

```java
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}

public static void deleteLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

同步容器的**单个操作是安全**的，但是**迭代操作不是**。如果在遍历容器时发生了结构性变化，就会抛出异常。同步容器没有解决这个问题，要避免这个异常，需要在遍历时给整个容器对象加锁。

同步容器不好，可以使用并发容器。并发容器都是线程安全的，且没有使用 synchronized 关键字，且没有迭代问题，直接支持一些复合操作。





