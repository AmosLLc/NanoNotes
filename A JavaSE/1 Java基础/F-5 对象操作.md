[TOC]

### 对象操作

#### 1 序列化

序列化就是将一个对象转换成**字节序列**，方便存储和传输。

- 序列化：ObjectOutputStream.**writeObject**()
- 反序列化：ObjectInputStream.**readObject**()

==**不会**对静态变量进行序列化==，因为序列化只是保存**对象的状态**，静态变量属于**类**的状态。





#### 2 Serializable

序列化的类需要实现 **Serializable** 接口，它只是一个标记接口，**没有任何方法**需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。

```java
public static void main(String[] args) throws IOException, ClassNotFoundException {

    A a1 = new A(123, "abc");
    String objectFile = "file/a1";

    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile));
    // 序列化
    objectOutputStream.writeObject(a1);
    objectOutputStream.close();

    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile));
    // 反序列化
    A a2 = (A) objectInputStream.readObject();
    objectInputStream.close();
    System.out.println(a2);
}

// 实现Serializable接口的类
private static class A implements Serializable {
    private static int c = 0; 	// 静态变量不会被序列化
    private int x;
    private String y;

    A(int x, String y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "x = " + x + "  " + "y = " + y;
    }
}
```



#### 3 transient 关键字

transient 关键字可以使一些属性**不会**被序列化。

ArrayList 中存储数据的数组 **elementData** 是用 **transient** 修饰的，因为这个数组是**动态扩展**的，并不是所有的空间都被使用，因此就**不需要**所有的内容都被序列化。通过==**重写**==序列化和反序列化方法，使得可以只序列化数组中**有内容**的那部分数据。

```java
private transient Object[] elementData;
```

不止 ArrayList，还有好几个使用动态数组的集合类都是如此。



