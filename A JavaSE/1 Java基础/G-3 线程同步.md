[TOC]

### 线程同步与协作



每个线程有自己的程序计数器，有自己的**栈**，但是线程之间可能存在**共享内存**，可以访问与操作相同的对象。因此可能存在**竞争**问题。

#### 1 竞态条件

当多个线程访问与操作同一个对象时，最终执行的结果与执行时序有关，可能正确也可能不正确。

如果多个线程对同一个共享数据进行访问而不采取**同步操作**的话，那么操作的结果是不一致的。

以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。

```java
public class ThreadUnsafeExample {

    private int cnt = 0;
	
    //  自增操作
    public void add() {
        cnt++;
    }

    public int get() {
        return cnt;
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    // 线程池
    ExecutorService executorService = Executors.newCachedThreadPool();
    // 多个线程操作cnt变量
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    // 等待完成
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
997
```

出大问题。

解决的方法：

- 使用 **synchronized** 关键字；
- 使用**显示锁**；
- 使用**原子变量**。





#### 2 内存可见性

当多个线程访问与操作同一个对象，当一个线程对一个共享变量修改时，另一个线程不一定马上就能看到，甚至永远看不到。除了**内存**，数据还会被缓存到CPU 的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或 CPU 缓存读取，而不一定从内存中去读取，当修改一个变量时，也可能是先写到缓存，之后再同步更新到内存中。这在多线程下就可能造成**内存可见性**问题。

解决方法：

- 使用 **volatile** 关键字（不能解决静态条件问题）；
- 实现 **synchronized** 关键字或显示锁进行同步。







