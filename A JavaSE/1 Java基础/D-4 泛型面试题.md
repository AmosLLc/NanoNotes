[TOC]



### 泛型面向题

#### Java 的泛型是如何工作的 ? 什么是类型擦除 ?

泛型是通过**类型擦除**来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如 List\<String> 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5之前的版本开发二进制类库进行**兼容**。你**无法在运行时访问到类型参数**，因为编译器已经把泛型类型转换成了**原始类型**。根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。



#### 什么是泛型中的限定通配符和非限定通配符 ?

这是另一个非常流行的 Java 泛型面试题。限定通配符对类型进行了限制。有两种限定通配符，一种是 **\<? extends T>** 它通过确保类型必须是 T 的子类来设定类型的**上界**，另一种是 **\<? super T>** 它通过确保类型必须是 T 的父类来设定类型的**下界**。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 **\<?>** 表示了非限定通配符，因为 <?> 可以用**任意类型**来替代。



####  List<? extends T>和List <? super T>之间有什么区别 ?

这和上一个面试题有联系，有时面试官会用这个问题来评估你对泛型的理解，而不是直接问你什么是限定通配符和非限定通配符。这两个 List 的声明都是**限定通配符**的例子，List<? extends T> 可以接受任何继承自 T 的类型的List，而 List<? super T> 可以接受任何 T 的父类构成的 List。例如 List<? extends Number> 可以接受List\<Integer> 或 List\<Float>。



#### 编写一段泛型程序来实现 LRU 缓存?

给个提示，LinkedHashMap 可以用来实现固定大小的 LRU 缓存，当 LRU 缓存已经满了的时候，它会把最老的键值对移出缓存。LinkedHashMap 提供了一个称为 removeEldestEntry() 的方法，该方法会被 put() 和 putAll() 调用来删除最老的键值对。当然，如果你已经编写了一个可运行的 JUnit 测试，你也可以随意编写你自己的实现代码。



#### ==你可以把List\<String>传递给一个接受List\<Object>参数的方法吗？==

对任何一个不太熟悉泛型的人来说，这个 Java 泛型题目看起来令人疑惑，因为乍看起来 String 是一种Object，所以List\<String> 应当可以用在需要List\<Object>的地方，但是**事实并非如此**。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现 Java 这样做是有意义的，因为 List\<Object> 可以存储任何类型的对象包括 String, Integer等等，而 List\<String> 却只能用来存储 Strings。　

```java
List<Object> objectList;
List<String> stringList;
objectList = stringList;  // compilation error incompatible types
```



#### Array中可以用泛型吗?

这可能是 Java 泛型面试题中最简单的一个了，当然前提是你要知道 Array 事实上**并不支持泛型**，这也是为什么 Effective Java 一书中建议使用 List 来代替 Array，因为 **List 可以提供编译期的类型安全保证，而 Array 却不能**。











