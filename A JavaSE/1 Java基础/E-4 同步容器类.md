[TOC]

### 同步容器类

#### 概述

同步容器类就是将**方法通过 synchronized 修饰达到线程安全的类**。这些类实现线程安全的方式是：将状态封装起来，并对每个方法进行同步，使得即使在多线程，每一次也仅有一个线程可以访问容器的状态。结果变成了类似于串行执行的效果。**仅仅只为实现同步**。

常见的同步容器类

- **Vector**(implements List)
- **Hashtable**(implements Map)
- **Stack**(extends Vector)。
- **Collections.synchronizedXxxx**。

同步容器在**单线程**的环境下能够保证**线程安全**，但是通过 synchronized 同步方法将访问操作串行化，导致并发环境下效率低下。而且同步容器在多线程环境下的**复合操作**（**迭代**、条件运算如没有则添加等）是**非线程安全**，需要**客户端代码**来实现**加锁**。所以同步容器迭代是需要加锁的。



#### Vector

##### 1. 同步

它的实现与 **ArrayList** 类似，但是使用了 **synchronized** 进行同步。在**方法**上加 **synchronized** 。因此是==**线程安全**==的。

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    return elementData(index);
}
```

##### 2. 与ArrayList的比较

- **ArrayList** 线程**不安全**，而 Vector 类采用了**同步机制**保证了线程**安全**。
- Vector 是**同步**的，因此==**开销**==就比 ArrayList 要**大**，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；
- Vector 每次扩容请求其大小的 **2 倍**空间，而 ArrayList 是 **1.5 倍**。
- 内部也有 **modCount** 记录**结构性变化次数**。

##### 3. 替代方案

可以使用 `Collections.synchronizedList();` 得到一个**线程安全的 ArrayList**。但是也是使用了 synchronized  锁机制。

```java
List<String> list = new ArrayList<>();
List<String> synList = Collections.synchronizedList(list);	// ※
```

也可以使用 JUC 并发包下的 **CopyOnWriteArrayList** 类。

```java
List<String> list = new CopyOnWriteArrayList<>();
```



#### Collections

类 **Collections** 中有一些方法可以返回线程安全的**同步容器**（不是并发容器）。它是给**所有容器方法**都加上 **synchronized** 关键字实现的。这些是**线程安全**的，但是效率较低。

<img src="E-6 同步容器类.assets/image-20200507110036360.png" alt="image-20200507110036360" style="zoom:82%;" />

```java
public static <T> List<T> synchronizedList(List<T> list) {
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList<>(list) :
            new SynchronizedList<>(list));
}
```

但是给所有的方法加 synchronized 关键词时所有的方法必须使用**相同的锁**，不然可能造成伪同步的问题。在并发编程当中，虽然同步容器类是**线程安全**的，但是在某些情况下可能需要**额外的客户端加锁**来保护**复合操作**。



#### 同步容器类的问题

由于加了锁，所以**开销**比较大。

如下面一段代码：

```java
public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
}

public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
}
```

上述两个方法中，虽然 **Vector 是线程安全**的，但是获取 Vector 大小与**获取/删除之间**没有锁保护，当获得 Vector 大小之后，如另外一个线程删除了 Vector 中的最末尾位置的元素，则每个函数的最后一句代码执行将报错。因此，对于**复合操作**，需要在**复合操作上用锁**来保证操作的原子性：

```java
public static Object getLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }
}

public static void deleteLast(Vector list) {
    synchronized (list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

**同步容器**的**单个操作是安全**的，但是**迭代操作不是**。如果在遍历容器时发生了**结构性变化**，就会**抛出异常**。同步容器没有解决这个问题，要避免这个异常，需要在遍历时给整个容器对象加锁。

**同步容器不好，可以使用并发容器。并发容器都是线程安全的，且没有使用 synchronized 关键字，且没有迭代问题，直接支持一些复合操作。**





