[TOC]

### Java内存模型

Java **内存模型**试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

#### 主内存与工作内存

处理器上的**寄存器**的读写的速度比**内存**快几个数量级，为了解决这种速度矛盾，在它们之间加入了**高速缓存**，而且缓存还有可能有多级：一级缓存、二级缓存、三级缓存。很多时候寄存器是直接从**缓存**中读取缓存数据的，但是**内存**中才是存放各种数据的大头。

加入高速缓存带来了一个新的问题：**缓存一致性**。如果多个缓存**共享同一块主内存**区域，那么多个缓存的数据可能会不一致，需要一些**协议**来解决这个问题。如下图所示。 

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582710294611.png" alt="1582710294611" style="zoom:56%;" />

所有的**变量**都存储在**主内存**中，每个线程还有自己的**工作内存**，工作内存存储在**高速缓存或者寄存器**中，保存了该线程使用的变量的**主内存副本拷贝**。

**线程**只能直接操作**工作内存**中的变量，不同线程之间的变量**值传递**需要通过**主内存**来完成。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712090309.png" alt="1582712090309" style="zoom:56%;" />



#### 内存间交互操作

Java 内存模型定义了 **8 个操作**来完成**主内存和工作内存**的交互操作。如下图所示。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712265240.png" alt="1582712265240" style="zoom:57%;" />

- **lock**（锁定）：作用于**主内存的变量**，把一个**变量**标识为**一条线程独占**的状态。
- **unclock**（解锁）：作用于**主内存**的变量，把一个处于**锁定状态的变量释放**出来，释放后的变量才可以被其他线程锁定。
- **read**（读取）：作用于**主内存**的变量，把一个变量的值从主内存传输到线程的工作内存，以便随后的 load 动作使用。
- **load**（载入）：作用于**工作内存**的变量，把 read 操作从主内存中得到的变量值**放入工作内存的变量副本**中。
- **use**（使用）：作用于**工作内存**的变量，把工作内存中一个变量的值传递给执行引擎。
- **assign**（赋值）：作用于**工作内存**的变量，把执行引擎接收到的值赋给工作内存的变量。
- **store**（存储）：作用于**工作内存**的变量，把工作内存中一个变量的值传送给**主内存**中，以便随后的 write 操作使用。
- **write**（写入）：作用于**主内存**的变量，把 store 操作从工作内存中得到的变量的值放入**主内存的变量**中。



#### 内存模型三大特性

##### 1. 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有**原子性**，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型**允许**虚拟机将**没有**被 volatile 修饰的 64 位数据（long，double）的读写操作划分为**两次 32 位**的操作来进行，即 **load、store、read 和 write** 操作**可以不具备**原子性。

有一个**错误认识**就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。

前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

```java
public void add() {
    // 这一句其实并不是原子操作
    cnt++;
}
```

**在多线程环境下，有可能线程 A 将 cnt 读取到本地内存中，此时其他线程可能已经将 cnt 增大了很多，线程 A 依然对过期的 cnt 进行自加，重新写到主存中，最终导致了 cnt 的结果不合预期，而是小于30000。**

为了方便讨论，将内存间的交互操作简化为 3 个：**load、assign、store**。

下图演示了两个线程同时对变量 **cnt** 进行操作，load、assign、store 这一系列操作**整体上来看==不具备==原子性**，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。**因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。**

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712597144.png" alt="1582712597144" style="zoom:60%;" />

使用 **AtomicInteger** 类能保证多个线程修改的**原子性**。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712684162.png" alt="1582712684162" style="zoom:70%;" />

使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：

```java
public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    // 只修改这条语句
    AtomicExample example = new AtomicExample(); 
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```

##### 2. 可见性

可见性指当一个线程**修改了共享变量的值**，其它线程能够**立即得知**这个修改。Java 内存模型是通过在变量修改后**将新值同步回主内存**，==在变量**读取前**从主内存**刷新变量值**来实现可见性的==。当多个线程访问与操作同一个对象，当一个线程对一个**共享变量**修改时，另一个线程不一定**马上就能看到**，甚至永远看不到。除了**内存**，数据还会被缓存到 CPU 的**寄存器以及各级缓存**中，当访问一个变量时，可能**直接从寄存器或 CPU 缓存读**取，而**不一定从内存**中去读取，当修改一个变量时，也可能是**先写到缓存**，之后再**同步更新到内存**中。这在多线程下就可能造成**内存可见性**问题。

主要有三种实现可见性的方式：

- ==**volatile**==，轻量级。**仅能保证可见性**，不能解决线程不安全问题。不能保证操作的原子性。
- ==**synchronized**==，对一个变量执行 unlock 操作之前，必须把变量值**同步回**主内存。
- ==**final**==，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，**不能解决线程不安全问题**，因为 volatile 并**不能保证操作的原子性**。

##### 3. 有序性

有序性是指：在**本线程**内观察，所有操作都是**有序**的。在一个线程观察另一个线程，所有操作都是**无序**的，无序是因为发生了**指令重排序**。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

**volatile** 关键字通过添加**内存屏障**的方式来**禁止指令重排**，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 **synchronized** 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。



#### Volatile

volatile 具备**两种特性**，第一就是保证共享变量对**所有线程的可见性**。

##### 1. 保证可见性

将一个共享变量声明为 volatile 后，会有以下效应：

- **1.当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的变量强制刷新到主内存中去；**

- **2.这个写会操作会导致其他线程中的缓存无效。**

##### 2. 禁止指令重排序

volatile 还有一个特性：**禁止指令重排序优化。**

**重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：**

- **1. 重排序操作不会对存在数据依赖关系的操作进行重排序。**比如：a=1; b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
- **2. 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变**。

重排序在单线程模式下是一定会保证最终结果的正确性，但是在**多线程**环境下，问题就出来了，看个例子。

```java
public class TestVolatile {
    int a = 1;
    boolean status = false;

    /**
     * 状态切换为true
     */
    public void changeStatus(){
        a = 2;// 1
        status = true;// 2
    }

    /**
     * 若状态为true，则running。
     */
    public void run(){
        if(status){// 3
            int b = a + 1;// 4
            System.out.println(b);
        }
    }
}
```

假设线程 A 执行 changeStatus 后，线程 B 执行 run，我们能保证在 4 处，b 一定等于 3 么？

**答案依然是无法保证！**也有可能 b 仍然为 2。上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，而上例中的 1 和 2 由于不存在数据依赖关系，则有可能会被重排序，先执行 status = true 再执行 a = 2。而此时线程 B 会顺利到达 4 处，而线程 A 中 a = 2 这个操作还未被执行，所以 b = a + 1的结果也有可能依然等于 2。

使用 volatile 关键字修饰共享变量便可以禁止这种重排序。**若用 volatile 修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序**

volatile 禁止指令重排序也有一些规则，简单列举一下：

**1. 当第二个操作是 voaltile 写时，无论第一个操作是什么，都不能进行重排序**。

**2. 当地一个操作是 volatile 读时，不管第二个操作是什么，都不能进行重排序**。

**3. 当第一个操作是 volatile 写时，第二个操作是 volatile 读时，不能进行重排序**。

简单总结下，volatile 是一种**轻量级的同步机制**，它主要有两个特性：一是保证共享变量对所有线程的**可见性**；二是**禁止指令重排序优化**。同时需要注意的是，volatile 对于单个的共享变量的读/写具有原子性，但是像 num++ 这种复合操作， volatile **无法保证其原子性**，解决方案就是使用并发包中的原子操作类，通过**循环 CAS** 地方式来保证 num++ 操作的原子性。



#### 先行发生原则

上面提到了可以用 volatile 和 synchronized 来保证**有序性**。除此之外，JVM 还规定了**先行发生原则**，让**一个操作无需控制就能先于另一个操作完成。**

##### 1. 单一线程原则

> Single Thread rule

在**一个线程**内，在程序前面的操作先行发生于后面的操作。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712904008.png" alt="1582712904008" style="zoom:60%;" />

##### 2. 管程锁定规则

> Monitor Lock Rule

一个 unlock 操作先行发生于**后面**对**同一个锁**的 lock 操作。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712956279.png" alt="1582712956279" style="zoom:57%;" />

##### 3. volatile 变量规则

> Volatile Variable Rule

对一个 **volatile** 变量的**写操作**先行发生于后面对这个变量的**读操作**。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713004016.png" alt="1582713004016" style="zoom:57%;" />

##### 4. 线程启动规则

> Thread Start Rule

Thread 对象的 **start**() 方法调用先行发生于此线程的**每一个**动作。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713062976.png" alt="1582713062976" style="zoom:57%;" />

##### 5. 线程加入规则

> Thread Join Rule

Thread 对象的**结束**先行发生于 **join**() 方法返回。

<img src="assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713101735.png" alt="1582713101735" style="zoom:57%;" />

##### 6. 线程中断规则

> Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

##### 7. 对象终结规则

> Finalizer Rule

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

##### 8. 传递性

> Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。







