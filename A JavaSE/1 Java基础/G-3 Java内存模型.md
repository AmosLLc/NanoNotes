[TOC]

### Java内存模型

#### 内存可见性

当多个线程访问与操作同一个对象，当一个线程对一个**共享变量**修改时，另一个线程不一定**马上就能看到**，甚至永远看不到。除了**内存**，数据还会被缓存到 CPU 的**寄存器以及各级缓存**中，当访问一个变量时，可能**直接从寄存器或 CPU 缓存读**取，而**不一定从内存**中去读取，当修改一个变量时，也可能是**先写到缓存**，之后再**同步更新到内存**中。这在多线程下就可能造成**内存可见性**问题。

解决方法：

- 使用 **volatile** 关键字（不能解决静态条件问题）；
- 实现 **synchronized** 关键字或显示锁进行同步。

Java **内存模型**试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。

#### 1 主内存与工作内存

处理器上的**寄存器**的读写的速度比**内存**快几个数量级，为了解决这种速度矛盾，在它们之间加入了**高速缓存**。

加入高速缓存带来了一个新的问题：**缓存一致性**。如果多个缓存**共享同一块主内存**区域，那么多个缓存的数据可能会不一致，需要一些**协议**来解决这个问题。如下图所示。 

![1582710294611](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582710294611.png)

所有的**变量**都存储在**主内存**中，每个线程还有自己的**工作内存**，工作内存存储在**高速缓存或者寄存器**中，保存了该线程使用的变量的**主内存副本拷贝**。

**线程**只能直接操作**工作内存**中的变量，不同线程之间的变量**值传递**需要通过**主内存**来完成。

![1582712090309](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712090309.png)



#### 2 内存间交互操作

Java 内存模型定义了 **8 个操作**来完成**主内存和工作内存**的交互操作。如下图所示。

![1582712265240](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712265240.png)

- **lock**（锁定）：作用于**主内存的变量**，把一个变量标识为**一条线程独占**的状态。
- **unclock**（解锁）：作用于**主内存**的变量，把一个处于**锁定状态的变量释放**出来，释放后的变量才可以被其他线程锁定。
- **read**（读取）：作用于**主内存**的变量，把一个变量的值从主内存传输到线程的工作内存，以便随后的 load 动作使用。
- **load**（载入）：作用于**工作内存**的变量，把 read 操作从主内存中得到的变量值**放入工作内存的变量副本**中。
- **use**（使用）：作用于**工作内存**的变量，把工作内存中一个变量的值传递给执行引擎。
- **assign**（赋值）：作用于**工作内存**的变量，把执行引擎接收到的值赋给工作内存的变量。
- **store**（存储）：作用于**工作内存**的变量，把工作内存中一个变量的值传送给**主内存**中，以便随后的 write 操作使用。
- **write**（写入）：作用于**主内存**的变量，把 store 操作从工作内存中得到的变量的值放入**主内存的变量**中。





#### 3 内存模型三大特性

##### ① 原子性

Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有**原子性**，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型**允许**虚拟机将**没有**被 volatile 修饰的 64 位数据（long，double）的读写操作划分为**两次 32 位**的操作来进行，即 **load、store、read 和 write** 操作**可以不具备**原子性。

有一个**错误认识**就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。

前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。

```java
public void add() {
    // 这一句其实并不是原子操作
    cnt++;
}
```

为了方便讨论，将内存间的交互操作简化为 3 个：**load、assign、store**。

下图演示了两个线程同时对变量 **cnt** 进行操作，load、assign、store 这一系列操作**整体上看==不具备==原子性**，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。**因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。**

![1582712597144](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712597144.png)

使用 **AtomicInteger** 类能保证多个线程修改的原子性。

![1582712684162](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712684162.png)

使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：

```java
public class AtomicExample {
    private AtomicInteger cnt = new AtomicInteger();

    public void add() {
        cnt.incrementAndGet();
    }

    public int get() {
        return cnt.get();
    }
}
```

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    AtomicExample example = new AtomicExample(); // 只修改这条语句
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
}
```

```html
1000
```



##### ② 可见性

可见性指当一个线程**修改了共享变量的值**，其它线程能够**立即得知**这个修改。Java 内存模型是通过在变量修改后**将新值同步回主内存**，==在变量**读取前**从主内存**刷新变量值**来实现可见性的==。

主要有三种实现可见性的方式：

- ==**volatile**==，轻量级。**仅能保证可见性**，不能解决线程不安全问题。不能保证操作的原子性。
- ==**synchronized**==，对一个变量执行 unlock 操作之前，必须把变量值**同步回**主内存。
- ==**final**==，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，**不能解决线程不安全问题**，因为 volatile 并**不能保证操作的原子性**。



##### ③ 有序性

有序性是指：在**本线程**内观察，所有操作都是**有序**的。在一个线程观察另一个线程，所有操作都是**无序**的，无序是因为发生了**指令重排序**。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

**volatile** 关键字通过添加**内存屏障**的方式来**禁止指令重排**，即重排序时不能把后面的指令放到内存屏障之前。

也可以通过 **synchronized** 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。





#### 4 先行发生原则

上面提到了可以用 volatile 和 synchronized 来保证**有序性**。除此之外，JVM 还规定了**先行发生原则**，让**一个操作无需控制就能先于另一个操作完成。**

##### ① 单一线程原则

> Single Thread rule

在一个线程内，在程序前面的操作先行发生于后面的操作。

![1582712904008](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712904008.png)



##### ② 管程锁定规则

> Monitor Lock Rule

一个 unlock 操作先行发生于**后面**对**同一个锁**的 lock 操作。

![1582712956279](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582712956279.png)

##### ③ volatile 变量规则

> Volatile Variable Rule

对一个 volatile 变量的**写操作**先行发生于后面对这个变量的**读操作**。

##### ![1582713004016](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713004016.png)④ 线程启动规则

> Thread Start Rule

Thread 对象的 **start**() 方法调用先行发生于此线程的**每一个**动作。

![1582713062976](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713062976.png)

##### ⑤ 线程加入规则

> Thread Join Rule

Thread 对象的**结束**先行发生于 **join**() 方法返回。

![1582713101735](assets/G-3-1%20Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1582713101735.png)

##### ⑥ 线程中断规则

> Thread Interruption Rule

对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。

##### ⑦ 对象终结规则

> Finalizer Rule

一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

##### ⑧ 传递性

> Transitivity

如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。







