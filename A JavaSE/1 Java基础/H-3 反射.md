[TOC]

### 反射

#### 1 反射概述

能够分析类能力的程序称为**反射**。可以在**运行时**分析类的能力，运行时查看对象。
每个类都有一个  **Class**  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 **.class** 文件，该文件内容保存着 **Class 对象**。

类加载相当于 **Class 对象**的加载，类在**第一次使用**时才动态加载到 JVM 中。也可以使用 `Class.forName("com.mysql.jdbc.Driver")` 这种方式来控制类的加载，该方法会返回一个 **Class 对象**。

反射可以提供**运行时**的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。



##### ① 反射的优点

- **可扩展性**  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- **类浏览器和可视化开发环境**  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- **调试器和测试工具**  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

##### ② 反射的缺点

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

- **性能开销**  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制**  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露**  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。



#### 2 Class类

##### ① 概述

- 所有对象都有一个被称为运行时的**类型标识**，这个信息跟踪着每个对象所属的类。保存这些信息的类称为**Class 类**。
- **Object** 类中的 **getClass()** 方法会返回一个 Class 类型的实例。
- 获取 Class 类对象的几种方法。

```java
// 方法1
Employee e;
Class cl = e.getClass();    // 通过对象继承的Object类的getClass()方法获取

// 方法2
String className = "java.util.Random";  // 类名或接口名的字符串 全限定名
Class cl = Class.forName(className);    // 使用静态方法Class.forName()可能会抛出异常

// 方法3
Class cl1 = Random.class;   // If you improt java.util.*;
Class cl2 = int.class;
Class cl3 = Double[].class;
// 如果T是任意的Java类型，则T.class将代表匹配的类对象。
```

- Class 类实际是一个**泛型类**。如 Employee.class 的类型是 Class\<Employee>。
- 虚拟机为**每个类型**管理一个 Class 对象。可以用 == 运算符实现两个类对象比较的操作。

```java
if(e.getClass() == Employee.class){...}
```

- newInstance() 方法可以**动态创建一个类的==实例对象==**。会调用**默认**构造方法，没有就会报错。

```java
String s = "java.util.Random";
Object m = Class.forName(s).newInstance();  // 根据类名字符串获取对应的对象
```

##### ② 相关API

```java
// java.lang.Class类
static Class forName(String className);     // 根据传入的类名字符串返回对应Class类对象
Object newInstance();       // 返回这个类的一个新的实例，调用无参构造方法。有参构造器使用下面的API

// java.lang.reflect.Constructor类
Object newInstance(Object[] args);      // 构造一个这个构造器所属类的新实例，使用提供的参数
```

 

#### 3 利用反射分析类

- java.lang.reflect 有三个类 Field (描述类的**域**)、Method (描述类的**方法**)和 Constructor (描述类的**构造器**)。利用这三个类可以分析一个类的结构。
- Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：
    - **Field** ：可以使用 **get**() 和 **set**() 方法读取和修改 Field 对象关联的**字段**（属性）；
    - **Method** ：可以使用 **invoke**() 方法调用与 Method 对象关联的**方法**；
    - **Constructor** ：可以用 **Constructor** 表示构造方法。

|       类        |         用途         |
| :-------------: | :------------------: |
|    **Field**    |    描述类的**域**    |
|   **Method**    |   描述类的**方法**   |
| **Constructor** | 描述类的**构造方法** |

##### ① 相关API

```java
/**
* java.lang.Class类
*/
Field[] getFileds();        // 获取该类或其超类的public域
Field[] getDeclaredField(); // 获取全部域
Method[] getMethods();      // 获取该类或其超类的public方法
Method[] getDeclaredMethods();      // 获取全部方法
Constructor[] getConstructors();    // 获取该类或其超类的public构造器
Constructor[] getDeclaredConstructors();    // 获取全部构造器
```

上述三组方法返回的是三种类型的数组。可以对其进行分析得到类的信息。

```java
/**
* java.lang.reflect.Field           
* java.lang.reflect.Method          
* java.lang.reflect.Constructor
*/
// 下面的API是上述三个类都有的方法
Class getDeclaringClass();  // 返回一个用于描述类中定义的构造器、方法或域的Class对象
int gerModifires();         // 返回域、方法或构造器的修饰符的整型数值。Modifier类可以分析这个值从而判断出private、public等修饰符
String getName();           // 返回对应的字符串名称
// 下面的API是Method和Constructor类有的方法
Class[] getExceptionTypes();// 返回异常类型
Class[] getParameterTypes();// 返回参数类型
// 仅在Method类中有
Class getReturnType();      // 返回描述返回类型的Class对象
```

------



##### ② 在运行时通过反射分析对象

可以使用 Field 类来对对象的**域值**进行获取与设置。

```java
/**
* java.lang.reflect.Field类
*/
Object get(Object obj);     // 返回obj对象中用Field对象表示的域值
void set(Object obj, Object newValue);  // 用一个新的值设置Obj对象中Field对象表示的域
```

```java
public class Employee{
    private double salary;        // Employee类的域
    private String name;
}

Employee harry = new Employee(44231.0, "Harry");    // 构造Employee类的对象harry
Class cl = harry.getClass();                        // 获取对应的Class类
Field[] fields = cl.getDeclaredFields();            // 通过Class类获取声明的所有方法
// 因为Employee类的域为private，因此受限于访问控制。此处设置为允许访问
AccessibleObject.setAccessible(fields, ture);       // 允许全部的private域被访问
Field fd = cl.getDeclaredField("name");             // 根据域的名称仅获取一个Field类
fd.setAccessible(true);                             // 仅设置name域被访问
// 以下是设置和获取对象阈值的方法！！！
Object v = fd.get(harry);                           // 通过域和对象共同获取对象的域值
fd.set(harry, "Harry Porter");                      // 通过域和对象对域值进行设置
```



#### 4 使用反射编写泛型数组代码

以下是利用反射进行**数组容量拓展**的方法。

```java
/**
 * 此方法可以复制原有的对象数组并实现扩容
 * @param a 是准备扩容的数组
 * @return 返回一个容量更大且包含a的数组
 */
public static Object goodCopyOf(Object a, int newLength) {
    Class cl = a.getClass();      // 获取a的Class对象
    if (!cl.isArray()) return null;   
    Class componentType = cl.getComponentType();  // 获取类型
    int length = Array.getLength(a);              // 获取原本数组的长度
    // 根据类型和新长度产生新的空白数组
    Object newArray = Array.newInstance(componentType, newLength);    
    // 把原本的数组a拷贝到新的容量大的数组中
    System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength)); 
    return newArray;
}
```



#### 5 调用任意方法

- Method类有一个 ==**invoke() 方法**==，允许调用包装在当前 **Method对象** 中的方法。即调用 **Method 对象指向的方法**。
- invoke 方法的签名。第一个是隐式参数，其余的是显示参数。静态方法第一个参数为null。
- 如果返回类型是基本类型，invoke 方法会返回其**包装器**类型。
- invoke 方法的返回类型和参数都是 Object 类型的，这就意味着需要进行多次**类型转换**。

```java
// 调用这个对象所描述的方法，传递给定参数，并返回方法的返回值。对于静态方法把null作为隐式参数传递
Object invoke(Object implictParameter, Object... explicitParameters);  
```

```java
// 例子
Employee harry = new Employee(44231.0, "Harry");    // 构造Employee类的对象harry
Class cl = harry.getClass();                        // 获取对应的Class类
Method m1 = cl.getMethod("getName");                // 通过方法名获取Method对象
String s = (String)m1.invoke(harry);                // 通过Method对象调用方法并类型转换结果

Method m2 = Employee.class.getMethod("getSalary", double.class);  // 获取另一个方法
// 如果返回类型是基本类型，invoke方法会返回其包装器类型
double salary = (Double)m2.invoke(harry);           // 注意salary是基本类型 返回的是包装器类
```













