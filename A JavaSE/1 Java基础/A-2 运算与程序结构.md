[TOC]

###  运算与程序结构

#### 按值传递参数

Java 的参数是以**==值传递==**的形式传入方法中，而**不是**引用传递。

##### 1. 基本数据类型

一个方法**不可能修改**一个基本类型的数据。

```java
public class Swap {

    public static void main(String[] args) {
        int x = 10;
        int y = 20;
        swap(x, y);
        System.out.println("x(2) = " + x);
        System.out.println("y(2) = " + y);
    }
    
    public static void swap(int x, int y) {
        int temp = x;
        x = y;
        y = temp;
        System.out.println("x(1) = " + x);
        System.out.println("y(1) = " + y);
    }
}
```

```java
x(1) = 20
y(1) = 10
x(2) = 10
y(2) = 20
```

上面程序 main 函数调用 swap 函数来**交换 x，y 的值**，然而调用函数之后发现 main 中 x，y 的值**并未交换**。包括在 Java api 中找不到一个可以交换两个变量的方法。这与 Java 语言的特性有关。通过一个图就可以知道上面程序的运行结果了。

<img src="A-2 运算与程序结构.assets/image-20200503154406218.png" alt="image-20200503154406218" style="zoom:77%;" />

由上图可知，main 函数中的 x，y 和 swap 函数中的 x，y 分别存放在**不同的区域**，在 main 中调用 swap 函数的时候，会将 main 中的 x，y 的**值赋给** swap 中的 x，y。当 swap 函数中对 x，y 交换时只是对 swap 帧中的 x，y 做交换，并不会改变 main 中的 x，y。所以当函数返回时 main 中的 x，y 并**不会改变**。

##### 2. 引用类型

引用类型也是按值传递！不过传递的是对象的==**地址值**==！

以下代码中 Dog dog 的 dog 是一个指针，存储的是**对象的地址**。在将一个对象参数传入一个方法时，本质上是**将对象的地址以值**的方式传递到形参中。

```java
public class Dog {
    String name;
    Dog(String name) {
        this.name = name;
    }
	// Getter and setter
}
```

```java
public class PassByValueExample {
    public static void main(String[] args) {
        // dogA
        Dog dog = new Dog("A");
        System.out.println(dog.toString()); // Dog@30c7da1e
        func(dog);
        System.out.println(dog.toString()); // Dog@30c7da1e
        System.out.println(dog.getName());  // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.toString()); // Dog@30c7da1e
        // 此时dog指向另一个对象的地址 
        // 因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象
        // 在一方改变其所指向对象的内容时对另一方没有影响
        dog = new Dog("B");
        System.out.println(dog.toString()); // Dog@5b464ce8
        System.out.println(dog.getName());  // B
    }
}
```

方法得到的是所有**参数值**的一个**拷贝**，即**值拷贝**的方式，方法不能修改传递给它的任何参数变量的内容。**但是如果在方法中改变对象的字段值会改变原对象该字段值**，因为改变的是**同一个地址**指向的内容。对象引用作为参数**可以**改变对象的**状态**！如下所示。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        // 改变了原来对象指向的值
        dog.setName("B");
    }
}
```

总结

- 基本类型在传递值的时候就是传递的**基本值**，而引用类型方法传递的时候是传递的**地址值**。
- 一个方法不能修改一个**基本数据类型**的参数(即数值型或布尔型)。但一个方法可以改变一个对象参数的**状态**。



#### 参数数量可变的方法

多参数在方法中会转化成为==数组==。如 printf 方法的定义如下：

```java
public SprintStream printf(String fmt, Object... args){     // ...代表能接收任意数量的参数, ...挨着类型
    return format(fmt, args);   	// 多个参数其实会转化为数组 即Object[]数组
}
```

另一个多参数的例子：

```java
public static double max(double... values){
    for(double v : values){     // 可以使用foreach语法遍历
        // Other code
    }
}
```



#### switch 结构

switch 表达式支持的类型可以是 ==**byte, short, int, char，枚举， String（Java7之后）**==。都是**整数**类型（String 转为 hashCode 也为整数）。

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch **不支持 null**。

switch ==**不支持 long**==。

以下错误示范。

```java
// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
```

##### 1. 实现原理

switch 语句如果分支比较少，可以直接转换为**跳转指令**。如果分支较多，则会使用**跳转表**（32 位）。

| 条件值 |      跳转地址       |
| :----: | :-----------------: |
|  值1   | 代码块 1 的**地址** |
|  值2   |   代码块 2 的地址   |

跳转表的值必须是==**整数**==，且按大小顺序排序（编译器自动排序），可以使用高效的**二分查找**。

由于值必须是整数，所以 **String** 会通过 hashCode() 转换为**整数**。

> **switch 表达式类型为啥不支持 long？**

是因为 switch 的设计初衷是对那些只有**少数**的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。此外，下述的**==跳转表值==**的存储空间一般为 **32** 位（4 字节），**存储不下** long 型值（64 位 / 8 字节）。



