[TOC]

###  运算与程序结构

#### 1 按值传递参数

Java 的参数是以==值传递==的形式传入方法中，而不是引用传递。

以下代码中 Dog dog 的 dog 是一个指针，存储的是**对象的地址**。在将一个参数传入一个方法时，本质上是**将对象的地址以值**的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。 

```java
public class Dog {
    String name;
    Dog(String name) {
        this.name = name;
    }
    String getName() {
        return this.name;
    }
    void setName(String name) {
        this.name = name;
    }
    String getObjectAddress() {
        return super.toString();
    }
}
```

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@30c7da1e
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@30c7da1e
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@30c7da1e
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@5b464ce8
        System.out.println(dog.getName());          // B
    }
}
```

**如果在方法中改变对象的字段值会改变原对象该字段值**，因为改变的是**同一个地址**指向的内容。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

- Java 是**按值调用**的，即方法接收的是**调用者提供的值**。也就是说方法得到的是所有参数值的一个**拷贝**，即**值拷贝**的方式，方法不能修改传递给它的任何参数变量的内容。
- 一个方法不可能修改一个基本类型的数据。

```java
public void change(int x){
    x = 3 * x;
}

int a = 5;
change(a);      // a是基本类型参数，调用方法a的值不受影响
System.out.println(a);	// a = 5
```

- ==对象引用作为参数可以改变对象的状态！== 方法得到的是对象引用的**拷贝**，对象引用即其他拷贝同时引用同一个对象，因此方法内的操作会影响对象的状态。即参数传递的过程采用**拷贝引用**的方式。

```java
public void change(Employee x){
    x.raiseMoney(300);
}
Employee harry = new Employee();
change(harry);      // 方法得到的是对象引用的拷贝 harry对象状态改变
```

总结

- 一个方法不能修改一个**基本数据类型**的参数(即数值型或布尔型)。
- 一个方法可以改变一个对象参数的**状态**。
- 一个方法不能让对象参数引用一个新的对象。





#### 2 参数数量可变的方法

多参数在方法中会转化成为==数组==。如 printf 方法的定义如下：

```java
public SprintStream printf(String fmt, Object... args){     // ...代表能接收任意数量的参数, ...挨着类型
    return format(fmt, args);   	// 多个参数其实会转化为数组 即Object[]数组
}
```

另一个多参数的例子：

```java
public static double max(double... values){
    for(double v : values){     // 可以使用foreach语法遍历
        // Other code
    }
}
```





#### 3 switch 结构

表达式的类型可以是 ==**byte, short, int, char，枚举**==。从 Java 7 开始，可以在 switch 条件判断语句中使用 **String** 对象。

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

switch ==**不支持 long**==，是因为 switch 的设计初衷是对那些只有**少数**的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。此外，下述的==跳转表值==的存储空间一般为 **32** 位（4字节），**存储不下** long 型值（64 位 / 8 字节）。

以下错误示范。

```java
// long x = 111;
// switch (x) { // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
```

##### Switch 内部实现原理

switch 语句如果分支比较少，可以直 接转换为**跳转指令**。如果分支较多，则会使用**跳转表**。

| 条件值 |    跳转地址     |
| :----: | :-------------: |
|  值1   | 代码块 1 的地址 |
|  值2   | 代码块 2 的地址 |

跳转表的值必须是**整数**，且按大小顺序排序（编译器自动排序），可以使用高效的**二分查找**。由于值必须是整数，所以 **String** 会通过 hashCode() 转换为**整数**。





#### 4 带标签的break语句

在if或者while等用于跳出语句块。少用。

```java
read:       // 写在块之前，须有一个冒号。
while(a < 10){
    // ...
    if (b > 3){
        break read;     // 满足条件跳出语句块
    }
}
```











