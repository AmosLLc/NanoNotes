[TOC]

### 类的基础

#### 1 概述

- 引用超类的方法使用 super.method();
- 在**运行时**能够自动地选择调用那个方法的现象称为**动态绑定**。
- 虚拟机会给每个类创建一个**方法表**，列出所有方法的签名和实际调用的方法，减少搜索开销。



#### 2 构造器

- 没有构造器时系统提供无参构造器。所有实例设置为默认值。如果类写了构造方法，无参构造方法就没有了除非自己再定义。
- 如果构造的**第一句**为 this(...)，则此构造器会调用**本类**中其他构造器。
- 子类构造器**第一句**为 super(...) , 会调用**父类**的构造器，不写 super 会调用父类**默认构造器**。不写super且父类没有默认构造器就会出错。
- 私有构造方法的应用场景：① 不能创建类的实例，类只能被静态访问；②能创建类的实例，但是只能静态方法创建，如单例模式； ③ 用来被**其他**多个构造方法调用。



#### 3 初始化块

- 普通初始化块会在 ==构造方法调用之前== 执行，构造对象时就会执行。**每次**新建对象在构造方法之前调用。
- ==静态初始化块会在类第一次加载==的时候调用，可对类中的**静态域**进行初始化。且只执行一次。

```java
package com.nano.javase;

public class DogTest {
    // 普通初始化语句块 在构造方法之前执行
    {
		id = nextId;
        nextId++;
        System.out.println("Normal block here.");
    }
	// 静态初始化语句块1 在第一次类加载的时候执行
    static {
        System.out.println("Static block1 here.");
        Random generator = new Random();
        nextId = generator.nextInt(100);
    }
    // 静态初始化语句块2 在第一次类加载的时候执行
    static {
        System.out.println("Static block2 here.");
    }
  
    public static void main(String[] args) {
        // 实例化三个变量
        DogTest dogTest = new DogTest();
        DogTest dogTest1 = new DogTest();
        DogTest dogTest2 = new DogTest();
    }
}
```

执行结果如下：

```html
Static block1 here.
Static block2 here.
Normal block here.
Normal block here.
Normal block here.
```

静态变量和静态语句块**优先**于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在**代码中的顺序**。

存在继承的情况下，**初始化顺序**为（常考）：静态优先、父类优先、初始化块优先于构造方法

- 父类（静态变量、静态语句块）
- 子类（静态变量、静态语句块）
- 父类（实例变量、普通语句块）
- 父类（构造方法）
- 子类（实例变量、普通语句块）
- 子类（构造方法）

见如下例子：

```java
package com.nano.javase;

import lombok.Data;

/**
 * 动物父类
 * @author nano
 */
@Data
public class Animal {

    private String name;

    private String age;

    // 静态初始化块
    static {
        System.out.println("地球有了动物");
    }

    // 普通初始化块
    {
        System.out.println("动物父母相遇");
    }

    public Animal(String name, String age) {
        this.name = name;
        this.age = age;
        System.out.println("一只动物出生");
    }

    // 父类方法
    public void eatFood() {
        System.out.println("动物吃东西");
    }

}
```

```java
package com.nano.javase;

import lombok.Setter;

/**
 * 继承测试
 * @author nano
 */
public class Dog extends Animal{

    // 普通初始化块
    {
        System.out.println("小狗父母相遇");
    }
    // 静态初始化块
    static {
        System.out.println("地球有了小狗");
    }

    @Setter
    private String owner;

    public Dog(String name, String age, String owner) {
        super(name, age);
        this.owner = owner;
        System.out.println("一只小狗出生");
    }

    // 覆写父类方法
    @Override
    public void eatFood() {
        // 引用父类的方法
        super.eatFood();
        System.out.println("小狗吃东西");
    }

    public static void main(String[] args) {
        Animal animal = new Dog("Jack", "12", "Tom");
        animal.eatFood();
        // 再初始化几个对象
        Dog dog = new Dog("Alice", "12", "Tom");
        Animal animal1 = new Dog("Bob", "12", "Tom");
        
    }
}
```

```java
// 执行父类静态初始化块
地球有了动物
// 执行子类静态初始化块
地球有了小狗
// 执行父类普通初始化块
动物父母相遇
// 执行父类构造方法
一只动物出生
// 执行子类普通初始化块
小狗父母相遇
// 执行子类构造方法
一只小狗出生
// 执行父类方法
动物吃东西
// 执行子类方法
小狗吃东西
// 下面是再初始化两个对象时执行普通初始化块和构造方法
动物父母相遇
一只动物出生
小狗父母相遇
一只小狗出生
动物父母相遇
一只动物出生
小狗父母相遇
一只小狗出生
```





#### 4 包

- 从编译器角度看，嵌套的包之间没有任何关系。如 java.util与java.util.jar 之间没有任何关系。
- 如果有两个相同名称的方法，可以通过**全限定名**使用。类文件中的字节码都是使用**完整的包名**来引用其他类。
- 可静态导入静态方法与静态域。

```java
import static com.cz.test.change;   // 静态导入Test类中的change静态方法

change(harry);      // 使用change静态方法时不再需要类名的前缀
```

- 包名放在源文件开头，没有包名就属于默认包中。





#### 5 类设计技巧

- 一定要保证数据**私有**。不要破坏封装，使用private。
- 一定要对数据进行**初始化**，可以提供默认值，也可以在构造方法中设置默认值。
- 不是所有的域都需要独立的域访问器和域更改器。
- 将职责过多的类分解。
- 类名与方法名能体现作用。
- 优先使用不可变的类。













