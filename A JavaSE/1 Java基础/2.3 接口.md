[TOC]

### 接口

#### 接口基础

- 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。Java8 接口中可以有静态方法和默认方法。Java9 甚至可以定义 private 的方法。

- 从 Java 8 开始，接口也可以拥有**==默认==的方法实现**，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。Spring 中很多默认实现方法。必须用**default 修饰符标记**该方法。引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加新的功能。

- 接口的成员（字段 + 方法）**默认都是 public** 的，并且不允许定义为 private 或者 protected。

- 接口不能定义实例变量。但接口中可以定义常量字段，这些域自动设置为**public static final**，实现接口的类继承这些常量，但是不推荐。

```java
// 定义接口
public interface InterfaceExample {
    
    void func1();   // 抽象方法
    
    // 默认实现的方法
    default void func2(){
        System.out.println("func2");
    }

    int x = 123;            // 默认为 public static final
    // int y;               // 必须初始化
    public int z = 0;       // Modifier 'public' is redundant for interface fields
    // private int k = 0;   // Modifier 'private' not allowed here
    // protected int l = 0; // Modifier 'protected' not allowed here
    // private void fun3(); // Modifier 'private' not allowed here
}
```

```java
public class InterfaceImplementExample implements InterfaceExample {
    // 实现接口中的非默认方法 默认方法可以不实现
    @Override
    public void func1() {
        System.out.println("func1");
    }
}
```

- 接口不是类，而是对类的一组需求描述。所以不能用new运算符实例化一个接口。但可以使用接口==引用实现了接口的类对象==。

```java
// InterfaceExample ie1 = new InterfaceExample(); 	// 'InterfaceExample' 接口是抽象的不能实例化
InterfaceExample ie2 = new InterfaceImplementExample();	// 通常使用接口引用实现了接口的对象
ie2.func1();
System.out.println(InterfaceExample.x);
```

- 使用**instanceof**检查一个对象是否实现了某接口。

```java
if(anObject instanceof Comparable){...}
```

- Java SE8之后允许在接口中定义**静态方法**。之前不允许。



#### 接口方法与类方法冲突

主要是接口与接口之间 (需要覆盖方法来解决二义性)，接口与超类之间的方法冲突(==超类优先==)。

```java
// 一个含有方法getName的接口
interface Named {
    String getName(){
        return getClass.getName();
    }
}

// 另一个含有getName方法的接口
class Person {
    public String getName(){
        return this.name;
    }
}

// 冲突1：实现了含有相同方法的两个接口
public class Student extends Person implements Named{
    public String getName(return Person.super.getName());   // 必须选择一个来解决此二义性问题
}

// 另一个类也有同样的getName方法
class Animal {
    private String name;
    public String getName(){
        return this.name;
    }
}

// 冲突2：继承的类和实现的接口都有相同的方法
class Student extends Animal implements Named{
    // 此时只会考虑超类的方法，接口的方法会被忽略，这就是“类优先”的原则
}
```

