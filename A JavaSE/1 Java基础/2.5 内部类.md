[TOC]



### 内部类

#### 1. 概述

- 内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。
- 内部类与外部类具有引用关系。**隐式引用**是**编译器**自己加的。
- 只有内部类可以是**私有**类。内部类**不能有static**方法。内部类中声明的所有静态域都必须是 final。
- 内部类是一种**编译器**现象，与虚拟机无关。**编译器**将会把内部类翻译成用 **$** (美元符号）分隔外部类名与内部类名的常规类文件， 而虚拟机则对此一无所知。每个内部类都会被编译为一个独立的类。
- 如果内部类访问了私有数据域， 就有可能通过附加在外围类所在包中的其他类访问它们。这就存在一定的**安全问题**。但需要将攻击代码与被攻击类放在同一个包中。
- 内部类可以为 private 的。



#### 2. 匿名内部类

匿名内部类的实例。

```java
// 将一个匿名内部类定义在方法中
public void start(int interval, boolean beep){
    // 创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内
    ActionListener listener = new ActionListener(){
        @Override
        public void actionPerformed(ActionEvent event){
            System.out.println("At the tone, the time is " + new Date());
        }
    };
    Timer t = new Timer(interval, listener);
    t.start();
}
```

- 多用于实现回调接口。

- 如果**构造参数的闭小括号后面跟一个开大括号**， 正在定义的就是匿名内部类。

```java
Person count = new Person("Dracula") {...}
// an object of an inner class extending Person
```

- 习惯的做法是用匿名内部类实现事件监听器和其他回调。 如今最好还是使用 **lambda** 表达式。
- 高级技巧：使用匿名类实现==双括号初始化==。

```java
// 此处两个{}。第一个{}表明是一个匿名内部类。第二个{}表明为类里面的初始化代码块，会在构造对象时调用。
invite(new ArrayList<String>(){{ add("Harry"); add("Tony"); }});
```

- 调用 getClass方法时调用的是this.getClass(), 而**静态方法**没有 this。所以应该使用以下表达式：

```java
new Object()){}.getClass().getEnclosingClass()      // 获取静态方法的Class
```

在这里，newObject(){} 会建立Object的一个匿名子类的一个匿名对象，getEnclosingClass则得到其外围类， 也就是包含这个静态方法的类。



#### 3. 静态内部类

- 即含有static修饰的内部类。只有**内部类**可以声明为 **static**。
- 静态内部类可以有静态域和方法。
- 非静态内部类依赖于外部类的实例，而静态内部类不需要。
- 静态内部类不能访问外部类的**非**静态的变量和方法。

**外部类如何调用静态内部类中的属性和方法**

- 外部类可以通过创建静态内部类实例的方法来调用静态内部类的非静态属性和方法

- 外部类可以直接通过“ 外部类.内部类.属性（方法）” 的方式直接调用静态内部类中的静态属性和方法

**静态内部类如何调用外部类的属性和方法**

静态内部类如果要访问外部的静态成员变量或者成员方法，静态只能访问静态的。

- 静态内部类可以直接调用外部类的静态属性和方法
- 静态内部类可以通过创建外部类**实例**的方法调用外部类的**非静态**属性和方法

**如何创建静态内部类实例**

创建静态内部类的时候是不需要将静态内部类的实例对象绑定到外部类的实例对象上，静态内部类属于**外部类**，而**不是**属于外部类的**对象**。

- 在非外部类中

```java
外部类名.内部类名 name = new 外部类名.内部类名();
```

- 在外部类中

```java
内部类名 name = new 内部类名();
```

```java
public class Outer {
    // 定义一个实例变量和一个静态变量
    private int a;
    private static int b;

    // 定义一个静态方法和一个非静态方法
    public static void say() {
    }

    public void test() {
        // 在外部类中调用内部类的属性和方法
        // 可以通过静态内部类的全类名来调用静态内部类的静态属性（外部类名.静态内部类名.属性）
        Outer.Inner.c = 1; 
        // 可以通过静态内部类的全类名来调用静态内部类的静态方法（外部类名.静态内部类名.方法）
        Outer.Inner.go(); 
        // Outer.Inner.walk(); // 不能通过类静态内部类的全类名来调用内部类的非静态属性和方法
        Inner inner = new Inner(); //可以通过创建内部类实例来调用静态内部类的非静态属性和方法
        inner.d = 1;
        inner.walk(); 
    }

    // 静态内部类
    public static class Inner {
        // 在静态内部类中定义一个静态变量和一个实例变量
        static int c;
        int d;
        // 可以定义一个匿名代码块和一个静态代码块
        {
        }
        static {
        }

        // 定义一个静态方法和一个普通方法
        public static void go() {
        }

        public void walk() {
            // 在静态内部类中调用外部类的属性和方法
            int f = b; // 可以直接调用外部类的静态属性
            say();     // 可以直接调用外部类的静态方法
            // int e = a; 直接调用外部类的非静态属性出错编译出错
            // test(); 直接调用外部类的非静态方法时编译出错
            Outer outer = new Outer();
            int e = outer.a; // 可以通过创建外部类实例来调用外部类的非静态属性
            outer.test();    // 可以通过创建外部类实例来调用外部类的非静态方法
        }
    }
}
```



#### 4. 局部内部类

- 定义的位置：在一个类的成员方法中。或者说，定义在一个成员方法的中的类就是局部内部类。
- 局部内部类**不能用 public 或 private 修饰符**进行声明。不能用访问修饰符。
- 局部内部类还有一个优点。它们不仅能够访问包含它们的外部类， 还可以访问局部变量。不过那些局部变量必须事实上为 final。如果需要变值的话一个替代方案可以是使用长度为1的数组。数组引用为final但是其值可以变化。即局部内部类只能访问**方法**中声明的 **final 类型**的变量。
- 编译后会生成两个.class文件，一个是Outer.class ，另一个是Outer$LocalInner.class。
- 在外部类中不能创建内部类的实例；
- 可知局部内部类可随意访问外部类的成员变量和方法，即使是私有的。
- 内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法。





