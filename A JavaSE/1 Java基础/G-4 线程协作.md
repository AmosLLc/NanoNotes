[TOC]

### 线程协作与同步

当多个线程可以**一起工作**去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行**协作**。基本场景有：

- 生产者、消费者模式
- 同时开始
- 等待结束
- 异步结果
- 集合点



#### join()

在线程中调用另一个线程的 join() 方法，会将当前线程**挂起**，而不是忙等待，直到目标线程结束。

对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。

```java
public class JoinExample {

    private class A extends Thread {
        @Override
        public void run() {
            System.out.println("A");
        }
    }

    private class B extends Thread {

        private A a;

        B(A a) {
            this.a = a;
        }

        @Override
        public void run() {
            try {
                a.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }

    public void test() {
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    }
}
```

```java
public static void main(String[] args) {
    JoinExample example = new JoinExample();
    example.test();
}
```

```
A
B
```



#### wait() notify() notifyAll()

调用 wait() 使得线程等待**某个条件满足**，线程在等待时会被挂起，当**其他线程**的运行使得这个条件满足时，其它线程会调用 **notify() 或者 notifyAll()** 来唤醒挂起的线程。

它们都属于 **Object** 的一部分，而不属于 Thread，**每个对象**都具有上述方法。

wait() notify() 方法只能用在同步方法或者同步控制块中使用，即在 **synchronized 代码块内**部使用，否则会在运行时抛出 IllegalMonitorStateException。

使用 wait() 挂起期间，线程会**释放锁**。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。

除了用于锁的等待队列，每个对象还有一个另一个等待队列，表示**条件队列**，该队列用于线程间的协作。

```java
public class WaitNotifyExample {

    public synchronized void before() {
        System.out.println("before");
        // 唤醒
        notifyAll();
    }

    public synchronized void after() {
        try {
            // 等待
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("after");
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```html
before
after
```

wait 的具体过程是：

1、把当前线程放入条件等待队列，释放对象锁，阻塞等待，线程状态变成 WAITING 或 TIMED_WAITING。

2、等待时间到或者被其他线程调用notify/notifyAll 从条件队列中移除，这时需要重新竞争对象锁。如果能获得锁，线程状态变成 RUNNABLE，并从 wait 调用中返回。否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有获得锁后才会从 wait 调用中返回。

一般的调用模式是：

```java
synchronized (obj) {
    while(条件不成立) {
        obj.wait();
        // ...
    }
    // ...
}
```



**wait() 和 sleep() 的区别** 

- wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；
- wait() 会**释放锁**，sleep() 不会。



#### await() signal() signalAll()

java.util.concurrent 类库中提供了 **Condition 类**来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。

相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

使用 Lock 来获取一个 **Condition 对象**。

```java
public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    // 通过lock对象获取Condition对象
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

```java
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```html
before
after
```



