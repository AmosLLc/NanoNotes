[TOC]

## 优先队列

### 1 概述

**普通队列**是一种**先进先出**的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。

**优先队列**具有**最高级先出** （largest-in，first-out）的行为特征。





### 2 二叉堆

#### 二叉堆概述

数据结构的**二叉堆**能很好的实现优先队列的基本操作。

堆的基本要求就是堆中**所有结点的值必须大于或等于（或小于或等于）其孩子结点**的值，这也称为堆的性质；堆还有另一个性质，就是当 h > 0 时，所有叶子结点都处于第 h 或 h - 1 层（其中 h 为树的高度，完全二叉树），也就是说，**堆应该是一颗完全二叉树**。

堆（heap）也被称为**优先队列**（priority queue）。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在**堆底插入元素**，在**堆顶取出元素**，但是堆中元素的排列不是按照到来的先后顺序，而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则。

可以分为大顶堆和小顶堆。

#### 二叉堆的数组存储

首先来看堆是怎样表示的，一种可能的方法就是使用**数组**，因为堆在形式上是一颗完全二叉树，用数组来存储它**不会浪费**任何空间。

![image-20191219123741643](assets/image-20191219123741643.png)

用数组来表示堆不仅不会浪费空间还具有一定的**优势**：

- 每个结点的左孩子为下标 i 的 2 倍：

```java
leftChild(i) = i * 2
```

- 每个结点的右孩子为下标 i 的 2 倍加 1：

```java
rightChild(i) = i * 2 + 1
```

每个结点的父亲结点为下标的二分之一：

```java
parent(i) = i / 2
```

注意这里是**整数除**，2 和 3 除以 2 都为 1，大家可以验证一下。

- **注意：**这里是把下标为 **0** 的地方**空出来**了的，主要是为了方便理解，如果 0 不空出来只需要在计算的时候把 i值往右偏移一个位置就行了。



### 3 基本操作与代码实现

以下是二叉堆类的基本元素与基本操作。

```java
/**
 * 二叉堆
 *
 * @param <AnyType> 泛型类型
 * @author cz
 */
public class BinaryHeap<AnyType extends Comparable<? super AnyType>> {

    /**
     * 默认容量
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 当前堆中的元素个数
     */
    private int currentSize;

    /**
     * 存放堆元素的数组
     */
    private AnyType [] dataArray;

    /**
     * 构造器
     */
    public BinaryHeap() {
        this( DEFAULT_CAPACITY );
    }

    /**
     * Construct the binary heap.
     * @param capacity the capacity of the binary heap.
     */
    public BinaryHeap( int capacity ) {
        currentSize = 0;
        dataArray = (AnyType[]) new Comparable[ capacity + 1 ];
    }
    

    /**
     * 拓展数组
     *
     * @param newSize 新数组容量
     */
    private void enlargeArray(int newSize) {
        AnyType[] old = dataArray;
        dataArray = (AnyType[]) new Comparable[ newSize];
        for(int i = 0; i < old.length; i++) {
            dataArray[i] = old[i];
        }
    }

    /**
     * 返回二叉堆最小值
     *
     * @return 最小值
     */
    public AnyType findMin() {
        if( isEmpty() ) {
            throw new RuntimeException( );
        }
        // 当前构造的最小堆，数组第一个元素就是最小值
        return dataArray[1];
    }

    /**
     * 判断是否为空
     */
    public boolean isEmpty() {
        return currentSize == 0;
    }

    /**
     * 清空二叉堆
     */
    public void makeEmpty() {
        currentSize = 0;
    }


    /**
     * 测试用
     */
    public static void main( String [ ] args ) {
        int numItems = 10000;
        BinaryHeap<Integer> h = new BinaryHeap<>( );
        int i = 37;

        for( i = 37; i != 0; i = ( i + 37 ) % numItems ) {
            h.insert( i );
        }
        for( i = 1; i < numItems; i++ ) {
            if( h.deleteMin( ) != i ) {
                System.out.println( "Oops! " + i );
            }
        }

    }
}
```



#### 插入元素

当**插入**一个元素到堆中时，它可能不满足堆的性质，在这种情况下，需要**调整堆中元素的位置使之重新变成堆**，这个过程称为**堆化**（heapifying）；在最大堆中，要堆化一个元素，需要**找到它的父亲结点**，如果不满足堆的基本性质则**交换两个元素的位置**，重复该过程直到每个结点都满足堆的性质为止。

在堆的**==下一个可用位置创建一个空穴==**，否则该堆将不是完全树。将**待插入的元素**与**空穴的父结点**进行比较，如果比父节点小就交换空穴与父节点位置，空穴**上浮**，循环此过程。

下面我们来模拟一下这个过程：

下面我们在该堆中插入一个新的元素 26：

在二叉堆的下一个可用位置放置一个空穴，该空穴假定值为 26，但是不赋值，可以**==减少比较与交换操作==**。

![image-20191219123802820](assets/image-20191219123802820.png)

我们通过**索引**（上面的公式）可以很容易地找到新插入元素的**父亲结点**，然后**比较它们的大小**，如果新元素更大则交换两个元素的位置，这个操作就相当于把该元素**==上浮==**了一下。如下图中 26 与 16 交换位， 26 上浮。

![image-20191219123844301](assets/image-20191219123844301.png)

重复该操作直到 26 到了一个满足堆条件的位置，此时就完成了插入的操作，下图插入 26 完成。

![image-20191219123934771](assets/image-20191219123934771.png)

插入元素代码实现如下。下面的方法中，如果空穴上浮 d 层，那么反复交换需要执行 3d 次操作，而下面的方法只用到了 **d + 1** 次幅值。

```java
/**
 * 插入元素 注：下面的代码是插入元素到小顶堆中
 */
public void insert(AnyType newNode) {
    // 先检查数组容量是否需要扩容
    if( currentSize == dataArray.length - 1 ) {
        enlargeArray( dataArray.length * 2 + 1 );
    }

    // 空穴位置是当前元素数量＋1
    int hole = ++currentSize;

    // 不断将插入元素与空穴的父节点进行比较
    for(dataArray[ 0 ] = newNode; newNode.compareTo( dataArray[ hole / 2 ] ) < 0; hole /= 2 ) {
        // 交换空穴与其父节点位置 空穴上浮
        dataArray[hole] = dataArray[hole / 2];
    }

    // 最后才将插入值赋给空穴处 可以减少每次的交换操作
    dataArray[hole] = newNode;
}
```



#### 删除顶部元素

取出堆中的堆顶元素就是用**最后一个元素替换掉栈顶元素**，然后把最后一个元素删除掉，这样一来元素的总个数也满足条件，然后只需要把**栈顶元素依次往下调整**就好了，这个操作就叫做**Sift Down（下沉）**。

操作也是将堆顶元素置换为空穴，然后将空穴的**两个儿子中较小者**与其交换位置，直到下沉到对应位置。但是可能遇到**只有一个子结点**的情况，此时一种解决方法是始终保证算法把每一个结点都**看成有两个子结点**。为了实施这种解法，当堆的大小为偶数时在每个**下沉开始处**，可将其值**大于堆中任何元素的标记**放到堆的**终端后面**的位置上。也就是假想有一个大于或者小于任何元素的结点此时正在堆的**最后一个位置**上。

例如删除堆顶元素 62。

![image-20191219133042581](assets/image-20191219133042581.png)

用最后元素**==替换==**掉栈顶元素，然后删除最后一个元素：

![image-20191219133111364](assets/image-20191219133111364.png)

然后比较其孩子结点的大小：

![image-20191219133300378](assets/image-20191219133300378.png)

如果不满足堆的条件，那么就跟**孩子结点中较大**的一个交换位置：41 ＞ 30，所以16 与 41 交换位置。

![image-20191219133315335](assets/image-20191219133315335.png)

重复该步骤，直到 16 到达合适的位置：

![image-20191219133330143](assets/image-20191219133330143.png)

完成取出堆顶元素的操作：

![image-20191219133347962](assets/image-20191219133347962.png)

代码实现如下

```java
/**
 * 删除最小值 注意下面的代码是移除小顶堆的最小值代码
 *
 * @return 返回删除后的最小值
 */
public AnyType deleteMin() {
    // 判空
    if( isEmpty() ) {
        throw new RuntimeException( );
    }

    AnyType minItem = findMin();
    // 交换堆顶元素与最后一个元素
    dataArray[1] = dataArray[currentSize--];
    // 执行下沉操作
    percolateDown(1);
    return minItem;
}

/**
     * 下沉操作
     *
     * @param hole 空穴
     */
private void percolateDown(int hole) {
    int child;
    AnyType tmp = dataArray[hole];

    for( ; hole * 2 <= currentSize; hole = child ) {
        child = hole * 2;
        if( child != currentSize && dataArray[ child + 1 ].compareTo( dataArray[ child ] ) < 0 ) {
            child++;
        }
        if( dataArray[ child ].compareTo( tmp ) < 0 ) {
            dataArray[ hole ] = dataArray[ child ];
        } else {
            break;
        }
    }
    dataArray[hole] = tmp;
}
```



#### 根据数组构造堆

下列的代码是根据数组构造小顶堆。

```java
/**
 * 通过给定的任意数组构造一个二叉堆
 */
public BinaryHeap(AnyType[] items) {
    currentSize = items.length;
    dataArray = (AnyType[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

    int i = 1;
    for(AnyType item : items) {
        dataArray[i++] = item;
    }
    // 构建堆
    buildHeap();
}

/**
     * 构建堆
     */
private void buildHeap() {
    for( int i = currentSize / 2; i > 0; i-- ) {
        percolateDown( i );
    }
}
```



#### Java 中的 PriorityQueue

在 Java 中也实现了自己的优先队列`java.util.PriorityQueue`，与我们自己写的不同之处在于，Java 中内置的为**最小堆**，然后就是一些函数名不一样，底层还是维护了一个 **Object 类型的数组**，另外如果想要把最小堆变成**最大堆**可以给 PriorityQueue 传入自己的**比较器**，例如：

```java
// 默认为最小堆
PriorityQueue<Integer> pq = new PriorityQueue<>();

pq.add(5);
pq.add(2);
pq.add(1);
pq.add(10);
pq.add(3);

while (!pq.isEmpty()) {
    System.out.println(pq.poll() + ", ");
}
System.out.println();
System.out.println("————————————————————————");

// 使用Lambda表达式传入自己的比较器转换成最大堆
PriorityQueue<Integer> pq2 = new PriorityQueue<>((a, b) -> b - a);
pq2.add(5);
pq2.add(2);
pq2.add(1);
pq2.add(10);
pq2.add(3);

while (!pq2.isEmpty()) {
    System.out.println(pq2.poll() + ", ");
}
```









### 4 优先队列的应用

应用很多

- 数据压缩：赫夫曼编码算法；
- 最短路径算法：Dijkstra 算法；
- 最小生成树算法：Prim 算法；
- 事件驱动仿真：顾客排队算法；
- 选择问题：查找第 k 个最小元素；



#### 动态数据排序找前 K 个值

在某些数据处理的例子中，总数据量太大，无法排序（甚至无法全部装进内存）。例如，需要从十亿个元素中选出**最大的十个**，你真的想把一个 10 亿规模的数组排序吗？但有了优先队列，你只用一个能存储**十个元素的队列**即可。具体做法是让元素一个个输入，只要优先队列的个数大于 10，就不断删除最小元素，最后优先队列长度不大于 10 时停止删除，只剩 10 个自然就是所有元素中最大的 10 个了。很多情况我们会收集一些元素，处理当前键值最大（或最小）的元素，然后再收集更多的元素，再处理当前最大的（或最小的）元素，这可以看成我们按照事件的优先级顺序来处理，生活中很多任务都是有优先级高低之分的，所以优先队列可以高效地处理这些情况。





### 5 左式堆

设计一种堆结构像二叉堆那样高效的支持合并操作而且**只使用一个数组**似乎很困难。原因在于，**合并**似乎需要把一个数组拷贝到另一个数组中去，对于相同大小的堆，这将花费O(N)。正因为如此，所有**支持高效合并**的高级数据结构都需要使用指针。

像二叉堆那样，**左式堆**也有结构性和堆序性。不仅如此，左式堆也是二叉树，它和二叉堆之间的唯一区别在于：**左式堆不是理想平衡的，而实际上是趋向于非常不平衡**。
把任意节点 X 的**零路径长**(null path length, **NPL**) NPL(X) 定义为从 X 到一个**没有两个儿子**的节点的**最短路径**长。因此，具有 0 个或 1 个儿子的节点的 NPL 值为 0，而 NPL(NULL) = -1。注意，任意节点的零路径长比它的各个儿子节点的最小值多 1。

左式堆的性质是：对于堆中的每一个节点 X，**==左儿子==的零路径长==至少==与==右儿子==的零路径长一样大**。这个性质使左式堆明显更偏重于**使树向左增加深度**，左式堆的名称也由此而来。




### 6 斜堆

斜堆是左式堆的自调节形式，实现起来较为简单。

斜堆是具有堆序的二叉树，但不存在对树的结构限制。





**参考资料**

- 《数据结构与算法分析 Java语言描述》

- https://www.cnblogs.com/wmyskxz/p/9301021.html







