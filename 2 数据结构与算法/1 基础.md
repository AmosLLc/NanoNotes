[TOC]

### 基础



#### 数学模型

#####  1. 近似

N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 \~ N<sup>3</sup>/6。使用 \~f(N) 来表示所有随着 N 的增大除以 f(N) 的结果趋近于 1 的函数。

#####  2. 增长数量级

N<sup>3</sup>/6-N<sup>2</sup>/2+N/3 的增长数量级为 O(N<sup>3</sup>)。增长数量级将算法与它的具体实现隔离开来，一个算法的增长数量级为 O(N<sup>3</sup>) 与它是否用 Java 实现，是否运行于特定计算机上无关。

#####  3. 内循环

执行最频繁的指令决定了程序执行的总时间，把这些指令称为程序的内循环。

#####  4. 成本模型

使用成本模型来评估算法，例如数组的访问次数就是一种成本模型。





#### 大O表示法

- 对于一般的对数函数，不管基数是什么，结论都一样，通常增长率函数中用到的对数的底都是 2.

一般来说，计算机算法是问题规模 n 的函数 f(n)，算法的时间复杂度也因此记做：

```
T(n) = O(f(n))
```

算法执行时间的增长率与 f(n) 的增长率正相关，称作渐近时间复杂度（Asymptotic Time Complexity），简称时间复杂度。

常见的**大 O** 运行时间：

- **O(log n)** 也叫**对数时间**，这样是算法包括二分查找法

- **O(n)** 也叫**线性时间**，这样的算法包括简单查找

- **O(n*log n)** 这样是算法包括快速排序（快）

- **O(n2)** 这样的算法包括选择排序（慢）

- **O(n!)** 这样的算法包括旅行商问题的解决方案（慢）



其他表示法：

- **大O** 表示法分析得到算法**最大**的时间需求。
- **大Ω** 表示法分析得到算法最小的时间需求。
- **大Θ** 表示法分析得到的是位于上下界之间的复杂度，是最好的，但是大O用的最多。

##### 例子

以下两层循环，内循环常数时间执行 O(1) 复杂度，外循环 O(n) 复杂度，整体 O(n) 复杂度。

```java
for(i = 1 to n){
    for(i = 1 to 5){	
        sum = sum + 1
    }
}
```



#### 算法分析注意事项

#####  1. 大常数

在求近似时，如果低级项的常数系数很大，那么近似的结果是错误的。

#####  2. 缓存

计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。

#####  3. 对最坏情况下的性能的保证

在核反应堆、心脏起搏器或者刹车控制器中的软件，最坏情况下的性能是十分重要的。

#####  4. 随机化算法

通过打乱输入，去除算法对输入的依赖。

#####  5. 均摊分析

将所有操作的总成本除于操作总数来将成本均摊。例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N + 4 + 8 + 16 +...+ 2N = 5N - 4（N 是向数组写入元素的次数，其余都是调整数组大小时进行复制需要的访问数组次数），均摊后访问数组的平均次数为常数。





#### ThreeSum

此例子源于《算法》第四版。

ThreeSum 用于统计一个数组中和为 0 的三元组数量。

```java
public interface ThreeSum {
    int count(int[] nums);
}
```

1. **穷举法**

该算法的内循环为 `if (nums[i] + nums[j] + nums[k] == 0)` 语句，总共执行的次数为 N(N-1)(N-2) = N<sup>3</sup>/6-N<sup>2</sup>/2+N/3，因此它的近似执行次数为 \~N<sup>3</sup>/6，增长数量级为 **O(N<sup>3</sup>)**。

```java
// 穷举法 No Offer
public class ThreeSumSlow implements ThreeSum {
    @Override
    public int count(int[] nums) {
        int N = nums.length;
        int cnt = 0;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                for (int k = j + 1; k < N; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        cnt++;
                    }
                }
            }
        }
        return cnt;
    }
}
```

2. **二分查找方式**

将数组进行**排序**，对两个元素**求和**，并用二分查找方法查找是否存在该和的**相反数**，如果存在，就说明存在和为 0 的三元组。

应该注意的是，只有数组**不含有相同元素**才能使用这种解法，否则二分查找的结果会出错。

该方法可以将 ThreeSum 算法增长数量级降低为 O(N<sup>2</sup>logN)。

```java
public class ThreeSumBinarySearch implements ThreeSum {

    @Override
    public int count(int[] nums) {
        // 先排序
        Arrays.sort(nums);
        int N = nums.length;
        int cnt = 0;
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                int target = -nums[i] - nums[j];
                int index = BinarySearch.search(nums, target);
                // 应该注意这里的下标必须大于 j，否则会重复统计。
                if (index > j) {
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
```

```java
public class BinarySearch {

    public static int search(int[] nums, int target) {
        int l = 0, h = nums.length - 1;
        while (l <= h) {
            int m = l + (h - l) / 2;
            if (target == nums[m]) {
                return m;
            } else if (target > nums[m]) {
                l = m + 1;
            } else {
                h = m - 1;
            }
        }
        return -1;
    }
}
```

3. **双指针解法**

更有效的方法是先将**数组排序**，然后使用**双指针**进行查找，时间复杂度为 O(N<sup>2</sup>)。

```java
public class ThreeSumTwoPointer implements ThreeSum {

    @Override
    public int count(int[] nums) {
        // 此处应该检查一下数组长度是否大于等于3
        int N = nums.length;
        int cnt = 0;
        // 先排序
        Arrays.sort(nums);
        
        for (int i = 0; i < N - 2; i++) {
            int l = i + 1, h = N - 1, target = -nums[i];
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            while (l < h) {
                int sum = nums[l] + nums[h];
                if (sum == target) {
                    cnt++;
                    while (l < h && nums[l] == nums[l + 1]) l++;
                    while (l < h && nums[h] == nums[h - 1]) h--;
                    l++;
                    h--;
                } else if (sum < target) {
                    l++;
                } else {
                    h--;
                }
            }
        }
        return cnt;
    }
}
```



4.**倍率实验**

如果 T(N) \~ aN<sup>b</sup>logN，那么 T(2N)/T(N) \~ 2<sup>b</sup>。

例如对于暴力的 ThreeSum 算法，近似时间为 \~N<sup>3</sup>/6。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：

|   N   | Time(ms) | Ratio |
| :---: | :------: | :---: |
|  500  |    48    |   /   |
| 1000  |   320    |  6.7  |
| 2000  |   555    |  1.7  |
| 4000  |   4105   |  7.4  |
| 8000  |  33575   |  8.2  |
| 16000 |  268909  |  8.0  |

可以看到，T(2N)/T(N) \~ 2<sup>3</sup>，因此可以确定 T(N) \~ aN<sup>3</sup>logN。

```java
public class RatioTest {

    public static void main(String[] args) {
        int N = 500;
        int loopTimes = 7;
        double preTime = -1;
        while (loopTimes-- > 0) {
            int[] nums = new int[N];
            StopWatch.start();
            ThreeSum threeSum = new ThreeSumSlow();
            int cnt = threeSum.count(nums);
            System.out.println(cnt);
            double elapsedTime = StopWatch.elapsedTime();
            double ratio = preTime == -1 ? 0 : elapsedTime / preTime;
            System.out.println(N + "  " + elapsedTime + "  " + ratio);
            preTime = elapsedTime;
            N *= 2;
        }
    }
}
```

```java
// 计时器
public class StopWatch {

    private static long start;

    public static void start() {
        start = System.currentTimeMillis();
    }
    public static double elapsedTime() {
        long now = System.currentTimeMillis();
        return (now - start) / 1000.0;
    }
}
```



#### 线性结构与非线性结构

##### 线性结构

- 线性结构作为最常用的数据结构，其特点是数据元素之间存在**一对一**的线性关系
- 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
- 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
- 线性结构见的有：组队列、链表和栈

##### 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构。





#### 符号表

符号表（Symbol Table）是一种存储**==键值对==**的数据结构，可以支持**快速查找**操作。

符号表分为**有序和无序**两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。

有序符号表的键需要实现 **Comparable** 接口。

```java
public interface UnorderedST<Key, Value> {

    int size();

    Value get(Key key);

    void put(Key key, Value value);

    void delete(Key key);
}
```

```java
public interface OrderedST<Key extends Comparable<Key>, Value> {

    int size();

    void put(Key key, Value value);

    Value get(Key key);

    Key min();

    Key max();

    int rank(Key key);

    List<Key> keys(Key l, Key h);
}
```



##### 基础实现

###### 1. 链表实现无序符号表

```java
public class ListUnorderedST<Key, Value> implements UnorderedST<Key, Value> {

    private Node first;

    private class Node {
        Key key;
        Value value;
        Node next;

        Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    @Override
    public int size() {
        int cnt = 0;
        Node cur = first;
        while (cur != null) {
            cnt++;
            cur = cur.next;
        }
        return cnt;
    }

    @Override
    public void put(Key key, Value value) {
        Node cur = first;
        // 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value
        while (cur != null) {
            if (cur.key.equals(key)) {
                cur.value = value;
                return;
            }
            cur = cur.next;
        }
        // 否则使用头插法插入一个新节点
        first = new Node(key, value, first);
    }

    @Override
    public void delete(Key key) {
        if (first == null)
            return;
        if (first.key.equals(key))
            first = first.next;
        Node pre = first, cur = first.next;
        while (cur != null) {
            if (cur.key.equals(key)) {
                pre.next = cur.next;
                return;
            }
            pre = pre.next;
            cur = cur.next;
        }
    }

    @Override
    public Value get(Key key) {
        Node cur = first;
        while (cur != null) {
            if (cur.key.equals(key))
                return cur.value;
            cur = cur.next;
        }
        return null;
    }
}
```

###### 2. 二分查找实现有序符号表

使用一对平行数组，一个存储键一个存储值。

二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。

二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。

```java
public class BinarySearchOrderedST<Key extends Comparable<Key>, Value> implements OrderedST<Key, Value> {

    private Key[] keys;
    private Value[] values;
    private int N = 0;

    public BinarySearchOrderedST(int capacity) {
        keys = (Key[]) new Comparable[capacity];
        values = (Value[]) new Object[capacity];
    }

    @Override
    public int size() {
        return N;
    }

    @Override
    public int rank(Key key) {
        int l = 0, h = N - 1;
        while (l <= h) {
            int m = l + (h - l) / 2;
            int cmp = key.compareTo(keys[m]);
            if (cmp == 0)
                return m;
            else if (cmp < 0)
                h = m - 1;
            else
                l = m + 1;
        }
        return l;
    }

    @Override
    public List<Key> keys(Key l, Key h) {
        int index = rank(l);
        List<Key> list = new ArrayList<>();
        while (keys[index].compareTo(h) <= 0) {
            list.add(keys[index]);
            index++;
        }
        return list;
    }

    @Override
    public void put(Key key, Value value) {
        int index = rank(key);
        // 如果找到已经存在的节点键为 key，就更新这个节点的值为 value
        if (index < N && keys[index].compareTo(key) == 0) {
            values[index] = value;
            return;
        }
        // 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置
        for (int j = N; j > index; j--) {
            keys[j] = keys[j - 1];
            values[j] = values[j - 1];
        }
        keys[index] = key;
        values[index] = value;
        N++;
    }

    @Override
    public Value get(Key key) {
        int index = rank(key);
        if (index < N && keys[index].compareTo(key) == 0)
            return values[index];
        return null;
    }

    @Override
    public Key min() {
        return keys[0];
    }

    @Override
    public Key max() {
        return keys[N - 1];
    }
}
```



##### 其他实现

其他实现参考**二叉查找树、红黑树、散列表**等。



##### 符号表算法比较

|           算法           | 插入 | 查找 | 是否有序 |
| :----------------------: | :--: | :--: | :------: |
|   链表实现的无序符号表   |  N   |  N   |   yes    |
| 二分查找实现的有序符号表 |  N   | logN |   yes    |
|        二叉查找树        | logN | logN |   yes    |
|        2-3 查找树        | logN | logN |   yes    |
|    拉链法实现的散列表    | N/M  | N/M  |    no    |
|  线性探测法实现的散列表  |  1   |  1   |    no    |

应当优先考虑散列表，当需要有序性操作时使用红黑树。

##### Java 的符号表实现

- java.util.TreeMap：红黑树
- java.util.HashMap：拉链法的散列表









