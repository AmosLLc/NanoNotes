[TOC]

### 查找算法

常用的查找算法

- 顺序查找（线性查找）
- 二分查找
- 插指查找
- 裴波那契查找



#### 线性查找

```java
/**
 * 顺序查找
 * @author cz 
 */
public class SeqSearch {

	public static void main(String[] args) {
		// 无序的数组
		int[] array = { 1, 9, 11, -1, 34, 89 };
		int index = seqSearch(array, -11);
		if(index == -1) {
			System.out.println("没有找到到");
		} else {
			System.out.println("找到，下标为 =" + index);
		}
	}

	/**
	 * 这里我们实现的线性查找是找到一个满足条件的值，就返回索引值
	 * @param arr 待查找数组
	 * @param value 待查找值
	 * @return 是否找到
	 */
	public static int seqSearch(int[] arr, int value) {
		// 线性查找是逐一比对，发现有相同值，就返回下标
		for (int i = 0; i < arr.length; i++) {
			if(arr[i] == value) {
				return i;
			}
		}
		return -1;
	}
}
```





#### 二分查找

思路分析

使用二分查找的前提是数组是==有序==的！

1、首先确定该数组的中间的下标

mid = (left + right) / 2

2、然后让需要查找的数 findVal 和 arr[mid] 比较

findVal > arr[mid] , 说明要查找的数在 mid 的右边, 因此需要**递归**的向右查找

findVal < arr[mid], 说明要查找的数在 mid 的左边, 因此需要**递归**的向左查找

findVal == arr[mid] 说明找到就返回

3、什么时候需要结束递归

1) 找到就结束递归 

2) 递归完整个数组，仍然没有找到 findVal ，也需要结束递归，当 **left > right** 就需要退出

```java
/**
 * 二分查找
 * 要求数组必须有序
 * @author cz
 */
public class BinarySearch {

    public static void main(String[] args) {
        int arr[] = { 1, 8, 10, 89,1000, 1234 };
		int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);
		System.out.println("resIndex=" + resIndex);
    }

    /**
     * 二分查找算法 递归实现
     * @param array 数组
     * @param leftIndex 左边的索引
     * @param rightIndex 右边的索引
     * @param findValue 要查找的值
     * @return 如果找到就返回下标，如果没有找到就返回 -1
     */
    public static int binarySearch(int[] array, int leftIndex, int rightIndex, int findValue) {
        System.out.println("插值查找被调用1次");

        // 当 left > right 时，说明已经递归整个数组，但是没有找到，必须要此处，不然会无限递归下去
        if (leftIndex > rightIndex) {
            return -1;
        }
        // 找中间值
        int midIndex = (leftIndex + rightIndex) / 2;
        int midValue = array[midIndex];

        // 向右递归
        if (findValue > midValue) {
            return binarySearch(array, midIndex + 1, rightIndex, findValue);
            // 向左递归
        } else if (findValue < midValue) {
            return binarySearch(array, leftIndex, midIndex - 1, findValue);
        } else {
            // 等于时直接返回
            return midIndex;
        }
    }
    
    
    /**
     * 二分查找的非递归实现
     * @param array 待查找的数组, arr是升序排序
     * @param target 需要查找的数
     * @return 返回对应下标，-1表示没有找到
     */
    public static int binarySearch(int[] array, int target) {

        int leftIndex = 0;
        int rightIndex = array.length - 1;
        // 说明继续查找
        while(leftIndex <= rightIndex) {
            int midIndex = (leftIndex + rightIndex) / 2;
            if(array[midIndex] == target) {
                return midIndex;
            } else if ( array[midIndex] > target) {
                // 需要向左边查找
                rightIndex = midIndex - 1;
            } else {
                // 需要向右边查找
                leftIndex = midIndex + 1;
            }
        }
        return -1;
    }
}
```

```java
/**
 * 二分查找 迭代方式实现
 *
 *@param array 有序待查数组
 *@param findValue 待查数据
 *@return 关键字位置
 */
public static int iterativeBinarySearch(int[] array, int findValue){

    int leftIndex = 0;
    int rightIndex = array.length - 1;
    // 定义middle
    int midIndex = 0;

    if(findValue < array[leftIndex] || findValue > array[rightIndex] || leftIndex > rightIndex){
        return -1;
    }

    while(leftIndex <= rightIndex){
        midIndex = (leftIndex + rightIndex) / 2;
        if(array[midIndex] > findValue){
            // 比关键字大则关键字在左区域
            rightIndex = midIndex - 1;
        }else if(array[midIndex] < findValue){
            // 比关键字小则关键字在右区域
            leftIndex = midIndex + 1;
        }else{
            return midIndex;
        }
    }

    // 最后仍然没有找到，则返回-1
    return -1;
}
```



**拓展**
{1, 8, 10, 89, 1000, 1000，1234} 当一个有序数组中，当有多个相同的数值时，如何将所有满足的数值都查找到，比如这里的 1000。

```java
/*
 * 课后思考题：{1, 8, 10, 89, 1000, 1000，1234} 当一个有序数组中，
 * 有多个相同的数值时，如何将所有的数值的索引都查找到，比如这里的 1000
 *
 * 思路分析
 * 1. 在找到mid 索引值，不要马上返回
 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
 * 4. 将Arraylist返回
 */

public static List<Integer> binarySearch2(int[] array, int leftIndex, int rightIndex, int findValue) {

    // 当 left > right 时，说明递归整个数组，但是没有找到
    if (leftIndex > rightIndex) {
        return new ArrayList<>(1);
    }

    int midIndex = (leftIndex + rightIndex) / 2;
    int midValue = array[midIndex];

    if (findValue > midValue) {
        // 向右递归
        return binarySearch2(array, midIndex + 1, rightIndex, findValue);
    } else if (findValue < midValue) {
        // 向左递归
        return binarySearch2(array, leftIndex, midIndex - 1, findValue);
    } else {

        List<Integer> resIndexList = new ArrayList<>();
        // 向mid索引值的左边扫描，将所有等于1000的元素的下标加入到集合ArrayList
        int temp = midIndex - 1;
        while(true) {
            if (temp < 0 || array[temp] != findValue) {
                // 退出
                break;
            }
            // 否则，就temp 放入到 resIndexList
            resIndexList.add(temp);
            // temp左移
            temp -= 1;
        }
        resIndexList.add(midIndex);

        // 向mid索引值的右边扫描，将所有等于1000的元素的下标加入到集合ArrayList
        temp = midIndex + 1;
        while(true) {
            if (temp > array.length - 1 || array[temp] != findValue) {
                // 退出
                break;
            }
            // 否则就temp放入到resIndexList
            resIndexList.add(temp);
            // temp右移
            temp += 1;
        }

        return resIndexList;
    }

}
```



#### 插值查找

1、插值查找算法类似于二分查找，不同的是插值查找每次从**自适应** mid 处开始查找。

2、将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high表示右边索引 right.
 key 就是前面我们讲的  findVal。

3、二分查找中计算 mid 索引的公式

```java
int mid = (left + right) / 2;
```

插值查找中自适应计算 mid 索引的算法

```java
int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]);   // 插值索引
```

 对应前面的代码公式：

```java
 int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
```

**举例说明插值查找算法的数组**

数组  arr = [1, 2, 3, ......., 100]

假如需要查找的值  1 

使用二分查找的话，我们需要多次递归，才能找到 1，因为 mid 的值固定为中间值。

使用插值查找算法，mid 的值根据所查找的值进行自适应计算出来。

```java
int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
```

```java
int mid = 0 + (99 - 0) * (1 - 1)/ (100 - 1) = 0 + 99 * 0 / 99 = 0 
```

比如查找值 100

```java
int mid = 0 + (99 - 0) * (100 - 1) / (100 - 1) = 0 + 99 * 99 / 99 = 0 + 99 = 99 
```

```java
/**
 * 插值查找
 * @author cz
 */
public class InsertValueSearch {

    public static void main(String[] args) {

        // 此处产生1-100的数组 使得关键字分布比较均匀
		int [] arr = new int[100];
		for(int i = 0; i < 100; i++) {
			arr[i] = i + 1;
		}

		// 插指查找查找99
        System.out.println("插指查找开始");
        int index = insertValueSearch(arr, 0, arr.length - 1, 99);
        System.out.println("index = " + index);

        System.out.println("二分查找开始");
        int index2 = binarySearch(arr, 0, arr.length, 99);
        System.out.println("index2 = " + index2);

    }

    /**
     * 二分查找算法
     * @param array 数组
     * @param leftIndex 左边的索引
     * @param rightIndex 右边的索引
     * @param findValue 要查找的值
     * @return 如果找到就返回下标，如果没有找到就返回 -1
     */
    public static int binarySearch(int[] array, int leftIndex, int rightIndex, int findValue) {
        System.out.println("二分查找被调用1次");

        // 当 left > right 时，说明已经递归整个数组，但是没有找到，必须要此处，不然会无限递归下去
        if (leftIndex > rightIndex) {
            return -1;
        }
        // 找中间值
        int midIndex = (leftIndex + rightIndex) / 2;
        int midValue = array[midIndex];

        // 向右递归
        if (findValue > midValue) {
            return binarySearch(array, midIndex + 1, rightIndex, findValue);
            // 向左递归
        } else if (findValue < midValue) {
            return binarySearch(array, leftIndex, midIndex - 1, findValue);
        } else {
            // 等于时直接返回
            return midIndex;
        }
    }

    /**
     * 插指查找算法
     *
     * 插值查找算法也要求数组是有序的
     * @param array 数组
     * @param leftIndex 左边索引
     * @param rightIndex 右边索引
     * @param findValue 查找值
     * @return 如果找到，就返回对应的下标，如果没有找到返回-1
     */
    public static int insertValueSearch(int[] array, int leftIndex, int rightIndex, int findValue) {

        System.out.println("插值查找被调用1次");

        // 后面两个条件必须要，否则我们得到的 mid 可能越界（比如findValue值特别巨大，而findValue参与到了mid值的计算中）
        // 同时如果待查找的值比最小值小或比最大值还大，直接返回-1
        if (leftIndex > rightIndex || findValue < array[0] || findValue > array[array.length - 1]) {
            return -1;
        }

        // 使用自适应公式计算 mid 索引值
        int midIndex = leftIndex + (rightIndex - leftIndex) * (findValue - array[leftIndex]) / (array[rightIndex] - array[leftIndex]);
        int midValue = array[midIndex];
        if (findValue > midValue) {
            // 说明应该向右边递归
            return insertValueSearch(array, midIndex + 1, rightIndex, findValue);
        } else if (findValue < midValue) {
            // 说明向左递归查找
            return insertValueSearch(array, leftIndex, midIndex - 1, findValue);
        } else {
            // 找到就返回
            return midIndex;
        }

    }
}
```

```java
// 在1-100的有序数组中查找99，二分查找递归了多次，而插指查找法使用自适应寻找mid值极大减小的调用次数
插指查找开始
插值查找被调用1次
index = 98
二分查找开始
二分查找被调用1次
二分查找被调用1次
二分查找被调用1次
二分查找被调用1次
二分查找被调用1次
二分查找被调用1次
二分查找被调用1次
index2 = 98
```

**插值查找注意事项**：

对于数据量**较大**，**关键字分布比较均匀**的查找表来说，采用插值查找, 速度较快。比如上面代码中的1-100的有序数组分布就比较均匀。关键字分布不均匀的情况下，该方法不一定比折半查找要好



#### 裴波那契查找

- 也叫黄金分割查找。
- 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618。
- 也需要数组**有序**。

**原理**

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是通过中间或插值得到，而是位于黄金分割点附近，即 

```
mid = low+F(k-1)-1（F代表斐波那契数列）
```

如下图所示

![1569571346588](assets/1569571346588.png)

**对F(k - 1) - 1的理解：**
由斐波那契数列 F[k] = F[k-1] + F[k-2] 的性质，可以得到 

```
（F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1
```

 该式说明：只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1] - 1 和 F[k-2] - 1的两段，即如上图所示。从而中间位置为 

```java       
mid = low + F(k-1) - 1    
```

类似的，每一子段也可以用相同的方式分割
但顺序表长度 n **不一定刚好等于** F[k] - 1，所以需要将原来的顺序表长度 n **扩容增加**至 F[k] - 1。这里的 k 值只要能使得 F[k] - 1恰好大于或等于 n 即可, 顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为 n 位置的值即可。



```java
/**
 * 裴波那契算法
 * @author cz
 */
public class FibonacciSearch {

    public static int maxSize = 20;
    public static void main(String[] args) {
        int [] arr = {1, 8, 10, 89, 1000, 1234};

        System.out.println("index = " + fibonacciSearch(arr, 89));
    }

    /**
     * 因为后面我们 mid = low+F(k-1)-1 需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
     * 此处使用非递归方法得到一个斐波那契数列
     * @return 斐波那契数列
     */
    public static int[] getFibonacciArray() {
        int[] fibo = new int[maxSize];
        fibo[0] = 1;
        fibo[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            fibo[i] = fibo[i - 1] + fibo[i - 2];
        }
        return fibo;
    }


    /**
     * 斐波那契查找算法 非递归方式实现
     *
     * @param array 待查有序数组
     * @param findValue 我们需要查找的关键码(值)
     * @return 返回对应的下标，如果没有返回-1
     */
    public static int fibonacciSearch(int[] array, int findValue) {
        int low = 0;
        int high = array.length - 1;
        // 表示斐波那契分割数值的下标
        int k = 0;
        // 存放mid值
        int midValue = 0;
        // 获取到斐波那契数列
        int[] fiboArray = getFibonacciArray();
        // 获取到斐波那契分割数值的下标
        while(high > fiboArray[k] - 1) {
            k++;
        }
        // 因为 f[k] 值可能大于a的长度，因此我们需要使用Arrays类，构造一个新的数组并指向temp[]
        // 不足的部分会使用0填充
        int[] temp = Arrays.copyOf(array, fiboArray[k]);
        // 实际上需求使用a数组最后的数填充temp
        // 举例:
        // temp = {1,8, 10, 89, 1000, 1234, 0, 0}  =>  {1,8, 10, 89, 1000, 1234, 1234, 1234}
        for(int i = high + 1; i < temp.length; i++) {
            temp[i] = array[high];
        }

        // 使用while来循环处理，找到需要的数据
        while (low <= high) {
            // 只要这个条件满足，就可以找
            midValue = low + fiboArray[k - 1] - 1;
            // 我们应该继续向数组的左边查找
            if(findValue < temp[midValue]) {
                high = midValue - 1;
                // 为甚是 k--
                // 1. 全部元素 = 前面的元素 + 后边元素
                // 2. f[k] = f[k-1] + f[k-2]
                // 因为前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]
                // 即在 f[k-1] 的前面继续查找 k--
                // 即下次循环 mid = f[k-1-1] - 1
                k--;
            } else if ( findValue > temp[midValue]) {
                // 我们应该继续向数组的右边查找
                low = midValue + 1;
                // 为什么是k = k - 2
                // 1. 全部元素 = 前面的元素 + 后边元素
                // 2. f[k] = f[k-1] + f[k-2]
                // 3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]
                // 4. 即在f[k-2] 的前面进行查找 k = k - 2
                // 5. 即下次循环 mid = f[k - 1 - 2] - 1
                k = k - 2;
            } else {
                // 找到元素，需要确定返回的是哪个下标
                if(midValue <= high) {
                    return midValue;
                } else {
                    return high;
                }
            }
        }
        return -1;
    }
}
```



