[TOC]

## 排序基础

### 1 基础

#### 约定

待排序的元素需要实现 Java 的 **Comparable 接口**，该接口有 **compareTo()** 方法，可以用它来判断两个元素的大小关系。

约定都是**基于比较**的排序。

使用**辅助函数 less() 和 swap() 来进行比较和交换**的操作，使得代码的可读性和可移植性更好。

排序算法的成本模型是==比较和交换的次数==。

```java
public abstract class Sort<T extends Comparable<T>> {

    public abstract void sort(T[] nums);

    // 比较
    protected boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }

    // 交换
    protected void swap(T[] a, int i, int j) {
        T t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}
```



#### 相关术语

- 稳定：如果 a 原本在 b 前面，而 a = b，排序之后 a 仍然在 b 的前面；如果排序算法不改变**相等对象**的相对次序，则成为**稳定的**。
- 不稳定：如果 a 原本在 b 的前面，而 a = b，排序之后 a 可能会出现在 b 的后面；
- 内排序：所有排序操作都在内存中完成；
- 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
- 时间复杂度：一个算法执行所耗费的时间。
- 空间复杂度：运行完一个程序所需内存的大小。
- n：数据规模
- k：“桶”的个数
- In-place:  不占用额外内存
- Out-place: 占用额外内存









